<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
        name="viewport"
    />

    <!-- title -->
    
    <title> React基础 |  Hexo</title>

    <!-- keywords,description -->
     

    <!-- favicon -->
     <link rel="shortcut icon" href="/favicon.ico"> 

    <!-- search -->
    <script>
        var searchEngine = "https://www.google.com/search?q=";
        if (
            typeof searchEngine == "undefined" ||
            searchEngine == null ||
            searchEngine == ""
        ) {
            searchEngine = "https://www.google.com/search?q=";
        }
        var homeHost = "wujun234.github.io";
        if (
            typeof homeHost == "undefined" ||
            homeHost == null ||
            homeHost == ""
        ) {
            homeHost = window.location.host;
        }
    </script>

    
<link rel="stylesheet" href="/css/main.css">
 
<link rel="stylesheet" href="/css/github-markdown-light.css">
 
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">
 
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
 
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

    
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
 
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>
 
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

    
<script src="/js/main.js"></script>
  
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>
 
<script src="https://cdn.jsdelivr.net/npm/valine@v1.4.14/dist/Valine.min.js"></script>
  
    <script
        async
        src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"
    ></script>
    
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">Hexo</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	

	

		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/wujun234" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="file">
									<a href="/2023/01/28/2023%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">
                     
										    2023个人总结
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/01/11/AndroidStudio%E6%93%8D%E4%BD%9C/">
                     
										    AndroidStudio操作
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/02/06/Npm%E5%92%8CPackage%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6/">
                     
										    Npm和Package描述文件
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/02/08/Npm%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6/">
                     
										    Npm描述文件
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/02/08/Npm%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/">
                     
										    Npm版本控制
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/02/08/Npm%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/">
                     
										    Npm脚本命令
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/02/08/Npm%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">
                     
										    Npm配置文件
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/02/08/Nvm%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/">
                     
										    Nvm管理工具
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/01/11/SEO%E6%8A%80%E5%B7%A7/">
                     
										    SEO技巧
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/01/12/flask-sqlalchemy%E4%BD%BF%E7%94%A8/">
                     
										    flask-sqlalchemy使用
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/01/11/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/">
                     
										    git常用命令的使用
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/01/16/mysql%E7%9A%84processlist%E4%B8%AD%E5%A4%84%E7%90%86%E8%A1%A8%E8%BF%9E%E6%8E%A5/">
                     
										    mysql的processlist中处理表连接
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/01/11/nginx%E9%85%8D%E7%BD%AE/">
                     
										    nginx配置
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/01/11/nginx%E9%85%8D%E7%BD%AEhttps/">
                     
										    nginx配置https
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2018/05/09/react%E5%9F%BA%E7%A1%80/">
                     
										    react基础
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/01/11/ubuntu18%E5%AE%89%E8%A3%85nginx/">
                     
										    ubuntu18安装nginx
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">
    React基础
</h1>
<div class="article-meta">
    
    <span>easterCat</span>
    <span>2018-05-09 17:39:55</span>
    <div id="article-categories">
        
        <span>Categories：</span>
          
        <span>Tags：</span>
         
        <span>
            <i class="fa fa-tag" aria-hidden="true">
                <a href="/tags/React/"
                    >React</a
                >
            </i>
        </span>
          
    </div>
</div>

<div id="article-content" class="markdown-body"><span id="more"></span>

<p><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hello-world.html">react官网</a></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h4 id="1-无状态组件"><a href="#1-无状态组件" class="headerlink" title="1. 无状态组件"></a>1. 无状态组件</h4><ul>
<li>在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。</li>
<li>无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。</li>
<li>无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。</li>
</ul>
<pre><code>import React from &quot;react&quot;;

//创建方式一,相当于es5的函数声明的方式创建
 function NoState (props) &#123;
     return (
         &lt;div&gt;this is NoState Component&lt;/div&gt;
     )
 &#125;
</code></pre>
<pre><code>//创建方式二,相当于es5的函数表达式的方式创建
const NoState = (props) =&gt; &#123;
    return (
        &lt;div&gt;this is Nostate Component&lt;/div&gt;
    )
&#125;

export default NoState
</code></pre>
<hr>
<ul>
<li>无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。</li>
<li>无状态组件没有实例化得过程，因此无法访问组件this中的对象</li>
<li>无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理</li>
<li>无状态组件只能访问传入的props，同样的props会得到同样的渲染结果</li>
</ul>
<p>当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来<br>代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。<br>第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同</p>
<pre><code>// helloWorld.jsx
import React, &#123;Component&#125; from &#39;react&#39;;
class HelloWorld extends Component &#123;
    clickHander = () =&gt; &#123;
        console.log(this.props);
        console.log(this.props.name);
    &#125;

    render() &#123;
        return (
            &lt;div onClick=&#123;this.clickHander&#125;&gt;&#123; this.props.name &#125; say: Hello World!&lt;/div&gt;
        )
    &#125;
&#125;
export default HelloWorld;
</code></pre>
<h2 id="组件之间的交互"><a href="#组件之间的交互" class="headerlink" title="组件之间的交互"></a>组件之间的交互</h2><h4 id="父组件与子组件之间的交互"><a href="#父组件与子组件之间的交互" class="headerlink" title="父组件与子组件之间的交互"></a>父组件与子组件之间的交互</h4><ol>
<li>父组件修改子组件，只需要修改传入的props属性</li>
<li>子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行<br>子组件与子组件之间的交互</li>
<li>通过影响共同的父组件来进行交互</li>
</ol>
<pre><code>state = &#123;
    switch: 0,
    name: this.props.name1
&#125;
clickHander = () =&gt; &#123;
    const &#123;name1, name2&#125; = this.props;
    if (this.state.switch === 0) &#123;
        this.setState(&#123;
            switch: 1,
            name: name2
        &#125;)
    &#125; else &#123;
        this.setState(&#123;
            switch: 0,
            name: name1
        &#125;)
    &#125;
&#125;;
render() &#123;
    return (
        &lt;div onClick=&#123;this.clickHander&#125;&gt;hello world !&#123;this.state.name&#125;&lt;/div&gt;
    )
&#125;
</code></pre>
<p>先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。</p>
<p>state &#x3D; {} &#x2F;&#x2F; 等同于ES5构造函数中的this.state &#x3D; {}<br>在对象中，我们可以通过this.state的方式来访问state中所存储的属性<br>setState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变<br>react赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了<br>而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行<br>&#x2F;&#x2F; 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: ‘Jason’})&#x2F;&#x2F; 然后立即查看它的值console.log(this.state.name) &#x2F;&#x2F; 仍然为Tom，不会立即改变</p>
<h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p>react组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样</p>
<pre><code>// 当然可能命名会是其他的，大概表达一个意思，不深究哈
&#123;
    nodeName: &#39;div&#39;,
    className: &#39;hello-world&#39;,
    style: &#123;&#125;,
    parentNodes: &#39;root&#39;,
    childrenNodes: []
    ...
&#125;
</code></pre>
<p>而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的</p>
<pre><code>import React, &#123; Component &#125; from &#39;react&#39;;
class HelloWorld extends Component &#123;
    clickHander = () =&gt; &#123;
        console.log(this.refs)
    &#125; 
    render () &#123;
        return (
            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;
                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;
                &lt;div ref=&quot;world&quot; className=&quot;world&quot;&gt;World&lt;/div&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;
export default HelloWorld;
</code></pre>
<p>为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替<br>我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。<br>当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。</p>
<pre><code>// src/helloWorld.jsx
import React, &#123; Component &#125; from &#39;react&#39;;class HelloWorld extends Component &#123;
    clickHander = () =&gt; &#123;
        console.log(this.refs)
    &#125; refCallback = (elem) =&gt; &#123;
        console.log(elem);
    &#125; render () &#123;
        return (
            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;
                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;
                &lt;div ref=&#123;this.refCallback&#125; className=&quot;world&quot;&gt;World&lt;/div&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;export default HelloWorld;
</code></pre>
<h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p>件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数</p>
<h5 id="react组件有三种状态"><a href="#react组件有三种状态" class="headerlink" title="react组件有三种状态"></a>react组件有三种状态</h5><ul>
<li>Mounted：已经插入真实DOM</li>
<li>Updating：正在被重新渲染</li>
<li>Unmounted：已移出真实DOM</li>
<li></li>
</ul>
<h5 id="每个状态的处理函数"><a href="#每个状态的处理函数" class="headerlink" title="每个状态的处理函数"></a>每个状态的处理函数</h5><ul>
<li>will：函数在进入状态之前调用</li>
<li>did：函数在进入状态之后调用</li>
</ul>
<h5 id="组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中"><a href="#组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中" class="headerlink" title="组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中"></a>组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中</h5><ul>
<li>componentWillMount 在首次渲染完成之前，此时可修改组件的state</li>
<li>componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM</li>
</ul>
<h5 id="组件属性-我们前面提到的props与state-更新的前后时刻"><a href="#组件属性-我们前面提到的props与state-更新的前后时刻" class="headerlink" title="组件属性(我们前面提到的props与state)更新的前后时刻"></a>组件属性(我们前面提到的props与state)更新的前后时刻</h5><ul>
<li>componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state</li>
<li>componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素</li>
</ul>
<h6 id="组件取消挂载之前-取消之后就没必要提供钩子函数了"><a href="#组件取消挂载之前-取消之后就没必要提供钩子函数了" class="headerlink" title="组件取消挂载之前(取消之后就没必要提供钩子函数了)"></a>组件取消挂载之前(取消之后就没必要提供钩子函数了)</h6><p><code>componentWillUnmount</code></p>
<h6 id="两个特殊的处理函数"><a href="#两个特殊的处理函数" class="headerlink" title="两个特殊的处理函数"></a>两个特殊的处理函数</h6><ul>
<li><code>componentWillReceiveProps(object nextProps)</code>：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变-&gt;然后componentWillReceiveProps去判断是否需要重新渲染(<code>shouldComponentUpdate</code>)-&gt;如果不需要则继续running-&gt;如果需要则执行<code>componentWillUpdate</code>-&gt;渲染DOM树之后执行<code>componentDidUpdate</code>-&gt;进入running</li>
<li><code>shouldComponentUpdate(nextProps, nextState)</code>(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变-&gt;判断是否需要重新渲染新的props和state(<code>shouldComponentUpdate</code>) -&gt; 根据判断决定执行render过程还是继续·保持running状态</li>
</ul>
<h6 id="三个统一调用的方法-用于组件初始化，获取默认属性和状态"><a href="#三个统一调用的方法-用于组件初始化，获取默认属性和状态" class="headerlink" title="三个统一调用的方法,用于组件初始化，获取默认属性和状态"></a>三个统一调用的方法,用于组件初始化，获取默认属性和状态</h6><ul>
<li>getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享</li>
<li>getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props</li>
<li>render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出</li>
</ul>
<h6 id="已挂载的方法"><a href="#已挂载的方法" class="headerlink" title="已挂载的方法"></a>已挂载的方法</h6><ul>
<li>component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候</li>
</ul>
<blockquote>
<p>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。</p>
</blockquote>
<p><img src="http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg" alt="image"></p>
<h2 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h2><pre><code>import PropTypes from &#39;prop-types&#39;;

MyComponent.propTypes = &#123;
  // You can declare that a prop is a specific JS primitive. By default, these
  // are all optional.
  optionalArray: PropTypes.array,
  optionalBool: PropTypes.bool,
  optionalFunc: PropTypes.func,
  optionalNumber: PropTypes.number,
  optionalObject: PropTypes.object,
  optionalString: PropTypes.string,
  optionalSymbol: PropTypes.symbol,

  // Anything that can be rendered: numbers, strings, elements or an array
  // (or fragment) containing these types.
  optionalNode: PropTypes.node,

  // A React element.
  optionalElement: PropTypes.element,

  // You can also declare that a prop is an instance of a class. This uses
  // JS&#39;s instanceof operator.
  optionalMessage: PropTypes.instanceOf(Message),

  // You can ensure that your prop is limited to specific values by treating
  // it as an enum.
  optionalEnum: PropTypes.oneOf([&#39;News&#39;, &#39;Photos&#39;]),

  // An object that could be one of many types
  optionalUnion: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.instanceOf(Message)
  ]),

  // An array of a certain type
  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),

  // An object with property values of a certain type
  optionalObjectOf: PropTypes.objectOf(PropTypes.number),

  // An object taking on a particular shape
  optionalObjectWithShape: PropTypes.shape(&#123;
    color: PropTypes.string,
    fontSize: PropTypes.number
  &#125;),

  // You can chain any of the above with `isRequired` to make sure a warning
  // is shown if the prop isn&#39;t provided.
  requiredFunc: PropTypes.func.isRequired,

  // A value of any data type
  requiredAny: PropTypes.any.isRequired,

  // You can also specify a custom validator. It should return an Error
  // object if the validation fails. Don&#39;t `console.warn` or throw, as this
  // won&#39;t work inside `oneOfType`.
  customProp: function(props, propName, componentName) &#123;
    if (!/matchme/.test(props[propName])) &#123;
      return new Error(
        &#39;Invalid prop `&#39; + propName + &#39;` supplied to&#39; +
        &#39; `&#39; + componentName + &#39;`. Validation failed.&#39;
      );
    &#125;
  &#125;,

  // You can also supply a custom validator to `arrayOf` and `objectOf`.
  // It should return an Error object if the validation fails. The validator
  // will be called for each key in the array or object. The first two
  // arguments of the validator are the array or object itself, and the
  // current item&#39;s key.
  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;
    if (!/matchme/.test(propValue[key])) &#123;
      return new Error(
        &#39;Invalid prop `&#39; + propFullName + &#39;` supplied to&#39; +
        &#39; `&#39; + componentName + &#39;`. Validation failed.&#39;
      );
    &#125;
  &#125;)
&#125;;
</code></pre>
</div>


<div class="post-guide">
    <div class="item left">
        
        <a href="/2023/01/11/ubuntu18%E5%AE%89%E8%A3%85nginx/">
            <i class="fa fa-angle-left" aria-hidden="true"></i>
            Ubuntu18安装nginx
        </a>
        
    </div>
    <div class="item right">
        
    </div>
</div>
 
<div id="vcomments"></div>


<script>
    
    	// 评论
    	new Valine({
    		el: '#vcomments',
    		appId: '',
    		appKey: '',
    		placeholder: '请输入评论',
    		path: window.location.pathname,
    		avatar: 'retro',
    		highlight: false,
         recordIP: true,
         enableQQ: true,
    		requiredFields: ['nick','mail']
    	})
    
    
</script>

	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">easterCat</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>