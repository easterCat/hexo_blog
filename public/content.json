{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"easterCat","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2018-05-09T09:02:05.000Z","updated":"2023-01-11T02:56:11.681Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-02-26T08:36:55.000Z","updated":"2023-01-14T09:14:28.161Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"photos","date":"2018-05-09T09:27:51.000Z","updated":"2023-01-11T02:56:11.682Z","comments":true,"path":"photos/index.html","permalink":"http://yoursite.com/photos/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-02-26T08:36:55.000Z","updated":"2023-01-14T09:13:38.982Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"flask-sqlalchemy使用","slug":"flask-sqlalchemy使用","date":"2023-01-12T07:48:11.000Z","updated":"2023-01-12T07:49:45.674Z","comments":true,"path":"2023/01/12/flask-sqlalchemy使用/","link":"","permalink":"http://yoursite.com/2023/01/12/flask-sqlalchemy%E4%BD%BF%E7%94%A8/","excerpt":"","text":"查询123456789101112131415161718192021222324251. filter() 把过滤器添加到原查询上，返回一个新查询2. filter_by() 把等值过滤器添加到原查询上，返回一个新查询3. limit 使用指定的值限定原查询返回的结果4. offset() 偏移原查询返回的结果，返回一个新查询5. order_by() 根据指定条件对原查询结果进行排序，返回一个新查询6. group_by() 根据指定条件对原查询结果进行分组，返回一个新查询7. all() 以列表形式返回查询的所有结果8. first() 返回查询的第一个结果，如果未查到，返回 None9. first_or_404() 返回查询的第一个结果，如果未查到，返回 40410. get() 返回指定主键对应的行，如不存在，返回 None11. get_or_404() 返回指定主键对应的行，如不存在，返回 40412. count() 返回查询结果的数量13. paginate() 返回一个Paginate对象，它包含指定范围内的结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768691. &quot;&quot;&quot;2. 查询所有用户数据3. User.query.all()5. 查询有多少个用户6. User.query.count()8. 查询第1个用户9. User.query.first()10. User.query.get(1) # 根据id查询12. 查询id为4的用户[3种方式]13. User.query.get(4)14. User.query.filter_by(id=4).all() # 简单查询 使用关键字实参的形式来设置字段名15. User.query.filter(User.id == 4).all() # 复杂查询 使用恒等式等其他形式来设置条件17. 查询名字结尾字符为g的所有用户[开始 / 包含]18. User.query.filter(User.name.endswith(&quot;g&quot;)).all()19. User.query.filter(User.name.startswith(&quot;w&quot;)).all()20. User.query.filter(User.name.contains(&quot;n&quot;)).all()21. User.query.filter(User.name.like(&quot;%n%g&quot;)).all() 模糊查询23. 查询名字和邮箱都以li开头的所有用户[2种方式]24. User.query.filter(User.name.startswith(&quot;li&quot;), User.email.startswith(&quot;li&quot;)).all()26. from sqlalchemy import and_27. User.query.filter(and_(User.name.startswith(&quot;li&quot;), User.email.startswith(&quot;li&quot;))).all()29. 查询age是25 或者 \\`email\\`以\\`itheima.com\\`结尾的所有用户30. from sqlalchemy import or_31. User.query.filter(or_(User.age == 25, User.email.endswith(&quot;itheima.com&quot;))).all()33. 查询名字不等于wang的所有用户[2种方式]34. from sqlalchemy import not_35. User.query.filter(not_(User.name == &quot;wang&quot;)).all()36. User.query.filter(User.name != &quot;wang&quot;).all()38. 查询id为[1, 3, 5, 7, 9]的用户39. User.query.filter(User.id.in_([1, 3, 5, 7, 9])).all()41. 所有用户先按年龄从小到大, 再按id从大到小排序, 取前5个42. User.query.order_by(User.age, User.id.desc()).limit(5).all()44. 分页查询, 每页3个, 查询第2页的数据45. pn = User.query.paginate(2, 3)46. pn.items 获取该页的数据 pn.page 获取当前的页码 pn.pages 获取总页数","categories":[],"tags":[]},{"title":"git常用命令的使用","slug":"git常用命令的使用","date":"2023-01-11T04:09:38.000Z","updated":"2023-01-11T04:10:04.582Z","comments":true,"path":"2023/01/11/git常用命令的使用/","link":"","permalink":"http://yoursite.com/2023/01/11/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"git名词 workspace :工作区 Index&#x2F;Stage : 暂存区 Repository : 仓库区(或本地仓库) Remote :远程仓库区 常用操作分部解析 在任何目录创建新的git仓库,执行 git init**,** .git文件就是本地的一个仓库 git status 查看修改状态 git add ,是将文件放入了暂存区,可以使用git checkout “文件名” 将文件从暂存区重新拿到工作区 git commit ,是将文件从暂存区放入到本地.git仓库 git status, 查看文件的状态,在暂存区还是在本地仓库,还是已经在本地仓库,或者已经提交(通常这些vscode工具一目了然) git pull ,拉取的默认是你自己的分支,详细:git pull origin dev, git pull origin master 拉去远程master分支 git 配置123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 常用流程 git add . git commit -m ‘ ‘ git pull git push 常用git命令行快捷方式 gaa …… git add . gcam ‘’ …… git commit -m ‘’ gl ……. git pull gp ……. git push 执行cat ~&#x2F;.oh-my-zsh&#x2F;plugins&#x2F;git&#x2F;git.plugin.zsh 查看更多简写 常用命令 git log git reflog(涉及到的所有操作步骤) git reset –hard HEAD git checkout file 恢复暂存区的文件到工作区 git checkout branch 切换分支 git stash git stash pop git branch -r 查看远程分支 git branch -a 查看所有分支 git remote 列出所有的远程主机 git pull –all 拉取远程所有的分支 git commit –amend -message&#x3D;””(修改最近的一次提交注释) git checkout (branchname) 切换分支命令 git branch (branchname) 创建分支命令 git branch -d (branchname) 删除分支命令 git push origin –delete Chapater6 删除远程分支命令","categories":[],"tags":[]},{"title":"AndroidStudio操作","slug":"AndroidStudio操作","date":"2023-01-11T04:09:05.000Z","updated":"2023-01-11T04:09:10.364Z","comments":true,"path":"2023/01/11/AndroidStudio操作/","link":"","permalink":"http://yoursite.com/2023/01/11/AndroidStudio%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Android studio操作command + shift + R 当前文件替换 command + shift + F 全局查找 command + shift + R 全局替换 command + O 全局搜索类**&#x2F;文件&#x2F;关键字&#x2F;(包括系统类,自定义类)** command + option + O 全局搜索方法 option + enter 将StatelessWidget转 StatefulWidget 快速修复 ****快速生成构造方法 command + option + W 抽取代码为单独的Widget command + option + M 抽取代码为单独的方法**,或者抽取成get**方法 command + option + L 格式化代码 command + D 复制单行 option + shift + up&#x2F;down上下移动代码 command + \\ 热重载**(hot reload)** control+ R 运行项目 command+ delete 删除行 Shift 双击 ****万能搜索 stless 快速创建一个StatelessWidget stful 快速创建一个StatefulWidget","categories":[],"tags":[]},{"title":"studio操作","slug":"studio操作","date":"2023-01-11T04:08:43.000Z","updated":"2023-01-11T04:08:43.800Z","comments":true,"path":"2023/01/11/studio操作/","link":"","permalink":"http://yoursite.com/2023/01/11/studio%E6%93%8D%E4%BD%9C/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SEO技巧","slug":"SEO技巧","date":"2023-01-11T04:08:10.000Z","updated":"2023-01-11T04:08:24.509Z","comments":true,"path":"2023/01/11/SEO技巧/","link":"","permalink":"http://yoursite.com/2023/01/11/SEO%E6%8A%80%E5%B7%A7/","excerpt":"","text":"SEO技巧这篇文章其实是我本人的总结，因为工作中做完了一个官方网站并成功上线，最后组长检查代码看到我的keyword等一系列信息都是空的，把我骂得狗血淋头。一言不合就作总结，总结一些简单但是我们能做的seo小技巧，送给想把网站做到极致的人。 SEO要点： 语义化html标签，用合适的标签嵌套合适的内容，不可过分依赖div，对浏览器更友善就能更容易被抓取。 重要的内容html代码放在前面，放在左边。搜索引擎爬虫是从左往右，从上到下进行抓取的，利用布局来实现重要的代码在上面 重要内容要写在html架构里面，蜘蛛不会抓取js的内容， 尽量减少使用iframe，因为蜘蛛不会抓取iframe的内容。 为图片img加上alt属性，加了alt就不必加title了，避免搜索引擎认为我们恶意优化。alt能让图片没加载时都能有文字提示。 需要强调的地方加上title，本页面内跳转a标签内也要加title。 重要的地方可以保留文字，有些地方必须用图，但是蜘蛛不会爬img，这时应该设置文本，再用缩进隐藏的方法去掉文字，例如logo的优化就是这样做的。注意隐藏不能用display：none，蜘蛛不会检索display：none的内容，应用这个方法的标签一般是logo，标题等重要信息 尽量做到js、css、html的分离，不要在html中写样式代码。 注释的东西能去掉应该去掉，对搜索引擎更加友好 css放在头部，js放在尾部，尽量使用外链或者工具对css和js进行压缩 减少http的请求，使页面更快加载。 使用本地缓存更快地访问网站，使用cdn网络，加快用户访问速度。 使用G-ZIP压缩，浏览速度更快，搜索引擎抓取信息量更大 关键一点是头部的title，description，keyword的设置。 title设置不宜过长，要简短，网站的名字与相关的小内容，一般为10-20个字。不能重复 keywords设置10个关键词，没个词不能太长，简短且符合你网站的特点，不能重复 description，50个字内描述你的网站 description写原创的话，并包含2-3个关键词比较好","categories":[],"tags":[]},{"title":"nginx配置","slug":"nginx配置","date":"2023-01-11T04:05:22.000Z","updated":"2023-01-11T04:05:27.201Z","comments":true,"path":"2023/01/11/nginx配置/","link":"","permalink":"http://yoursite.com/2023/01/11/nginx%E9%85%8D%E7%BD%AE/","excerpt":"","text":"nginx配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226user www-data;#启动进程,通常设置成和cpu的数量相等worker_processes 2;pid /run/nginx.pid;include /etc/nginx/modules-enabled/*.conf;events &#123; worker_connections 768; # multi_accept on;&#125;http &#123; ## # Basic Settings ## sendfile on; tcp_nopush on; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; # Gzip Settings gzip on; gzip_min_length 1000; gzip_vary on; gzip_proxied any; gzip_comp_level 6; gzip_buffers 16 8k; gzip_http_version 1.1; gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; map $sent_http_content_type $expires &#123; &quot;text/html&quot; epoch; &quot;text/html; charset=utf-8&quot; epoch; default off; &#125; server &#123; listen 80; server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life; return 301 https://$host$request_uri; # gzip on; # gzip_types text/plain application/xml text/css application/javascript; # gzip_min_length 1000; # location / &#123; # expires $expires; # proxy_redirect off; # proxy_set_header Host $host; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # proxy_set_header X-Forwarded-Proto $scheme; # proxy_read_timeout 1m; # proxy_connect_timeout 1m; # proxy_pass http://127.0.0.1:3000/; # &#125; # location ~ /.well-known &#123; # allow all; # &#125; # location ^~ /.well-known/pki-validation/ &#123; # add_header Cache-Control no-cache; # default_type &quot;text/plain&quot;; # rewrite /.well-known/pki-validation/(.*) /$1 break; # root /var/www/whatever; # &#125; # location /nuxt3-tag &#123; # expires $expires; # proxy_redirect off; # proxy_set_header Host $host; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # proxy_set_header X-Forwarded-Proto $scheme; # proxy_read_timeout 1m; # proxy_connect_timeout 1m; # proxy_pass http://127.0.0.1:3000/nuxt3-tag; # &#125; # location /stable &#123; # rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent; # &#125; # location /nuxt3 &#123; # rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent; # &#125; # location /tag &#123; # rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent; # &#125; # location /stable/api &#123; # proxy_pass http://www.ptg.life:5000/api; # proxy_set_header Access-Control-Max-Age 86400; # proxy_set_header Host $host; # proxy_redirect off; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # proxy_connect_timeout 60; # proxy_read_timeout 60; # proxy_send_timeout 60; # &#125; # location /static/ &#123; # valid_referers none blocked *.ptg.life; # if ($invalid_referer) &#123; # return 403; # break; # &#125; # expires 30d; # autoindex on; # root /data; # &#125; &#125; server &#123; listen 443 ssl; server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life; # 新版的nginx只用listen 443 ssl就行,需要注释 # ssl on; keepalive_timeout 10m; server_tokens off; # 缓存SSL握手产生的参数和加密密钥的时长 ssl_session_timeout 10m; # 证书 ssl_certificate /etc/nginx/certificate.crt; ssl_certificate_key /etc/nginx/private.key; # 日志 access_log /var/log/nginx/nginx.vhost.access.log; error_log /var/log/nginx/nginx.vhost.error.log; # 根用iframe嵌入做个隐式url location / &#123; index index.html index.htm index.html inde.php; root /usr/share/nginx/html; &#125; location ~ /.well-known &#123; allow all; &#125; location ^~ /.well-known/pki-validation/ &#123; add_header Cache-Control no-cache; default_type &quot;text/plain&quot;; rewrite /.well-known/pki-validation/(.*) /$1 break; root /var/www/whatever; &#125; location /nuxt3-tag/ &#123; expires $expires; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_read_timeout 1m; proxy_connect_timeout 1m; proxy_pass http://127.0.0.1:3000/nuxt3-tag/; &#125; location /naifu/ &#123; expires $expires; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_read_timeout 1m; proxy_connect_timeout 1m; proxy_pass http://127.0.0.1:3000/naifu/; &#125; location /nuxt3 &#123; rewrite ^/(.*) $host://$http_host/nuxt3-tag permanent; &#125; location /tag &#123; rewrite ^/(.*) $host://$http_host/nuxt3-tag permanent; &#125; # flask的接口代理 location /stable/api &#123; proxy_pass http://127.0.0.1:5000/api; proxy_set_header Access-Control-Max-Age 86400; proxy_set_header Host $host; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_connect_timeout 60; proxy_read_timeout 60; proxy_send_timeout 60; &#125; location /static/ &#123; valid_referers none blocked *.ptg.life; if ($invalid_referer) &#123; return 403; break; &#125; expires 30d; autoindex on; root /data; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"nginx配置https","slug":"nginx配置https","date":"2023-01-11T04:04:52.000Z","updated":"2023-01-11T04:04:56.476Z","comments":true,"path":"2023/01/11/nginx配置https/","link":"","permalink":"http://yoursite.com/2023/01/11/nginx%E9%85%8D%E7%BD%AEhttps/","excerpt":"","text":"SSL 证书部署首先申请免费证书,推荐阿里或者七牛云https://cn.aliyun.com/product/cas?from_alibabacloud&#x3D;&amp;source&#x3D;5176.11533457&amp;userCode&#x3D;ywqc0ubl&amp;type&#x3D;copy 下载申请好的 ssl 证书文件压缩包到本地并解压到&#x2F;etc&#x2F;nginx&#x2F; 12/etc/nginx/certificate.crt;/etc/nginx/private.key; 将这两个文件上传至服务器的&#x2F;etc&#x2F;nginx&#x2F;目录里 12scp /Users/lilin/Downloads/certificate.crt root@xxx.xx.xxx.xx:/etc/nginx/scp /Users/lilin/Downloads/private.crt root@xxx.xx.xxx.xx:/etc/nginx/ nginx.conf配置配置 https server.注释掉之前的 http server 配置,新增 https server 123456789101112131415161718192021222324252627282930将http重定向httpsserver &#123; listen 80; server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life; return 301 https://$host$request_uri; &#125;server &#123; listen 443 ssl; server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life; # 新版的nginx只用listen 443 ssl就行,需要注释 # ssl on; keepalive_timeout 10m; server_tokens off; # 缓存SSL握手产生的参数和加密密钥的时长 ssl_session_timeout 10m; # 证书 ssl_certificate /etc/nginx/certificate.crt; ssl_certificate_key /etc/nginx/private.key; # 日志 access_log /var/log/nginx/nginx.vhost.access.log; error_log /var/log/nginx/nginx.vhost.error.log; # 根用iframe嵌入做个隐式url location / &#123; index index.html index.htm index.html inde.php; root /usr/share/nginx/html; &#125; &#125;","categories":[],"tags":[]},{"title":"ubuntu18安装nginx","slug":"ubuntu18安装nginx","date":"2023-01-11T04:04:03.000Z","updated":"2023-01-11T04:04:22.888Z","comments":true,"path":"2023/01/11/ubuntu18安装nginx/","link":"","permalink":"http://yoursite.com/2023/01/11/ubuntu18%E5%AE%89%E8%A3%85nginx/","excerpt":"","text":"apt安装sudo apt update12345sudo apt install nginxnginx -V默认安装路径 /etc/nginx/nginx.conf nginx安装位置1**whereis nginx** 启动1service nginx start 检查nginx配置文件1service nginx reload 重启1nginx -s reopen 停止1nginx -s stop 端口占用123456789101112查看端口netstat -lntpnginx端口tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 248057/nginx: master结束端口kill 248057重启nginxservice nginx restart","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-01-11T02:56:11.680Z","updated":"2023-01-11T02:56:11.680Z","comments":true,"path":"2023/01/11/hello-world/","link":"","permalink":"http://yoursite.com/2023/01/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"哈哈哈1223","slug":"哈哈哈1223","permalink":"http://yoursite.com/tags/%E5%93%88%E5%93%88%E5%93%881223/"}]},{"title":"react基础2","slug":"react基础2","date":"2018-05-09T09:49:24.000Z","updated":"2023-01-11T03:59:39.675Z","comments":true,"path":"2018/05/09/react基础2/","link":"","permalink":"http://yoursite.com/2018/05/09/react%E5%9F%BA%E7%A1%802/","excerpt":"","text":"react官网 组件1. 无状态组件 在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。 无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。 无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。 12345678import React from &quot;react&quot;;//创建方式一,相当于es5的函数声明的方式创建 function NoState (props) &#123; return ( &lt;div&gt;this is NoState Component&lt;/div&gt; ) &#125; 12345678//创建方式二,相当于es5的函数表达式的方式创建const NoState = (props) =&gt; &#123; return ( &lt;div&gt;this is Nostate Component&lt;/div&gt; )&#125;export default NoState 无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。 无状态组件没有实例化得过程，因此无法访问组件this中的对象 无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理 无状态组件只能访问传入的props，同样的props会得到同样的渲染结果 当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同 123456789101112131415// helloWorld.jsximport React, &#123;Component&#125; from &#x27;react&#x27;;class HelloWorld extends Component &#123; clickHander = () =&gt; &#123; console.log(this.props); console.log(this.props.name); &#125; render() &#123; return ( &lt;div onClick=&#123;this.clickHander&#125;&gt;&#123; this.props.name &#125; say: Hello World!&lt;/div&gt; ) &#125;&#125;export default HelloWorld; 组件之间的交互父组件与子组件之间的交互 父组件修改子组件，只需要修改传入的props属性 子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行子组件与子组件之间的交互 通过影响共同的父组件来进行交互 1234567891011121314151617181920212223state = &#123; switch: 0, name: this.props.name1&#125;clickHander = () =&gt; &#123; const &#123;name1, name2&#125; = this.props; if (this.state.switch === 0) &#123; this.setState(&#123; switch: 1, name: name2 &#125;) &#125; else &#123; this.setState(&#123; switch: 0, name: name1 &#125;) &#125;&#125;;render() &#123; return ( &lt;div onClick=&#123;this.clickHander&#125;&gt;hello world !&#123;this.state.name&#125;&lt;/div&gt; )&#125; 先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。 state &#x3D; {} &#x2F;&#x2F; 等同于ES5构造函数中的this.state &#x3D; {}在对象中，我们可以通过this.state的方式来访问state中所存储的属性setState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变react赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行&#x2F;&#x2F; 假设state.name的初始值为Tom，我们改变它的值this.setState({ name: ‘Jason’})&#x2F;&#x2F; 然后立即查看它的值console.log(this.state.name) &#x2F;&#x2F; 仍然为Tom，不会立即改变 refsreact组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样 123456789// 当然可能命名会是其他的，大概表达一个意思，不深究哈&#123; nodeName: &#x27;div&#x27;, className: &#x27;hello-world&#x27;, style: &#123;&#125;, parentNodes: &#x27;root&#x27;, childrenNodes: [] ...&#125; 而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的 123456789101112131415import React, &#123; Component &#125; from &#x27;react&#x27;;class HelloWorld extends Component &#123; clickHander = () =&gt; &#123; console.log(this.refs) &#125; render () &#123; return ( &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt; &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt; &lt;div ref=&quot;world&quot; className=&quot;world&quot;&gt;World&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;export default HelloWorld; 为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。 123456789101112131415// src/helloWorld.jsximport React, &#123; Component &#125; from &#x27;react&#x27;;class HelloWorld extends Component &#123; clickHander = () =&gt; &#123; console.log(this.refs) &#125; refCallback = (elem) =&gt; &#123; console.log(elem); &#125; render () &#123; return ( &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt; &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt; &lt;div ref=&#123;this.refCallback&#125; className=&quot;world&quot;&gt;World&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;export default HelloWorld; 组件生命周期件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数 react组件有三种状态 Mounted：已经插入真实DOM Updating：正在被重新渲染 Unmounted：已移出真实DOM 每个状态的处理函数 will：函数在进入状态之前调用 did：函数在进入状态之后调用 组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中 componentWillMount 在首次渲染完成之前，此时可修改组件的state componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM 组件属性(我们前面提到的props与state)更新的前后时刻 componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素 组件取消挂载之前(取消之后就没必要提供钩子函数了)componentWillUnmount 两个特殊的处理函数 componentWillReceiveProps(object nextProps)：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变-&gt;然后componentWillReceiveProps去判断是否需要重新渲染(shouldComponentUpdate)-&gt;如果不需要则继续running-&gt;如果需要则执行componentWillUpdate-&gt;渲染DOM树之后执行componentDidUpdate-&gt;进入running shouldComponentUpdate(nextProps, nextState)(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变-&gt;判断是否需要重新渲染新的props和state(shouldComponentUpdate) -&gt; 根据判断决定执行render过程还是继续·保持running状态 三个统一调用的方法,用于组件初始化，获取默认属性和状态 getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享 getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出 已挂载的方法 component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候 componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。 PropTypes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import PropTypes from &#x27;prop-types&#x27;;MyComponent.propTypes = &#123; // You can declare that a prop is a specific JS primitive. By default, these // are all optional. optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // Anything that can be rendered: numbers, strings, elements or an array // (or fragment) containing these types. optionalNode: PropTypes.node, // A React element. optionalElement: PropTypes.element, // You can also declare that a prop is an instance of a class. This uses // JS&#x27;s instanceof operator. optionalMessage: PropTypes.instanceOf(Message), // You can ensure that your prop is limited to specific values by treating // it as an enum. optionalEnum: PropTypes.oneOf([&#x27;News&#x27;, &#x27;Photos&#x27;]), // An object that could be one of many types optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // An array of a certain type optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // An object with property values of a certain type optionalObjectOf: PropTypes.objectOf(PropTypes.number), // An object taking on a particular shape optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // You can chain any of the above with `isRequired` to make sure a warning // is shown if the prop isn&#x27;t provided. requiredFunc: PropTypes.func.isRequired, // A value of any data type requiredAny: PropTypes.any.isRequired, // You can also specify a custom validator. It should return an Error // object if the validation fails. Don&#x27;t `console.warn` or throw, as this // won&#x27;t work inside `oneOfType`. customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( &#x27;Invalid prop `&#x27; + propName + &#x27;` supplied to&#x27; + &#x27; `&#x27; + componentName + &#x27;`. Validation failed.&#x27; ); &#125; &#125;, // You can also supply a custom validator to `arrayOf` and `objectOf`. // It should return an Error object if the validation fails. The validator // will be called for each key in the array or object. The first two // arguments of the validator are the array or object itself, and the // current item&#x27;s key. customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( &#x27;Invalid prop `&#x27; + propFullName + &#x27;` supplied to&#x27; + &#x27; `&#x27; + componentName + &#x27;`. Validation failed.&#x27; ); &#125; &#125;)&#125;;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react基础","slug":"react基础","date":"2018-05-09T09:39:55.000Z","updated":"2023-01-11T03:59:27.472Z","comments":true,"path":"2018/05/09/react基础/","link":"","permalink":"http://yoursite.com/2018/05/09/react%E5%9F%BA%E7%A1%80/","excerpt":"","text":"react官网 组件1. 无状态组件 在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。 无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。 无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。 12345678import React from &quot;react&quot;;//创建方式一,相当于es5的函数声明的方式创建 function NoState (props) &#123; return ( &lt;div&gt;this is NoState Component&lt;/div&gt; ) &#125; 12345678//创建方式二,相当于es5的函数表达式的方式创建const NoState = (props) =&gt; &#123; return ( &lt;div&gt;this is Nostate Component&lt;/div&gt; )&#125;export default NoState 无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。 无状态组件没有实例化得过程，因此无法访问组件this中的对象 无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理 无状态组件只能访问传入的props，同样的props会得到同样的渲染结果 当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同 123456789101112131415// helloWorld.jsximport React, &#123;Component&#125; from &#x27;react&#x27;;class HelloWorld extends Component &#123; clickHander = () =&gt; &#123; console.log(this.props); console.log(this.props.name); &#125; render() &#123; return ( &lt;div onClick=&#123;this.clickHander&#125;&gt;&#123; this.props.name &#125; say: Hello World!&lt;/div&gt; ) &#125;&#125;export default HelloWorld; 组件之间的交互父组件与子组件之间的交互 父组件修改子组件，只需要修改传入的props属性 子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行子组件与子组件之间的交互 通过影响共同的父组件来进行交互 1234567891011121314151617181920212223state = &#123; switch: 0, name: this.props.name1&#125;clickHander = () =&gt; &#123; const &#123;name1, name2&#125; = this.props; if (this.state.switch === 0) &#123; this.setState(&#123; switch: 1, name: name2 &#125;) &#125; else &#123; this.setState(&#123; switch: 0, name: name1 &#125;) &#125;&#125;;render() &#123; return ( &lt;div onClick=&#123;this.clickHander&#125;&gt;hello world !&#123;this.state.name&#125;&lt;/div&gt; )&#125; 先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。 state &#x3D; {} &#x2F;&#x2F; 等同于ES5构造函数中的this.state &#x3D; {}在对象中，我们可以通过this.state的方式来访问state中所存储的属性setState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变react赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行&#x2F;&#x2F; 假设state.name的初始值为Tom，我们改变它的值this.setState({ name: ‘Jason’})&#x2F;&#x2F; 然后立即查看它的值console.log(this.state.name) &#x2F;&#x2F; 仍然为Tom，不会立即改变 refsreact组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样 123456789// 当然可能命名会是其他的，大概表达一个意思，不深究哈&#123; nodeName: &#x27;div&#x27;, className: &#x27;hello-world&#x27;, style: &#123;&#125;, parentNodes: &#x27;root&#x27;, childrenNodes: [] ...&#125; 而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的 123456789101112131415import React, &#123; Component &#125; from &#x27;react&#x27;;class HelloWorld extends Component &#123; clickHander = () =&gt; &#123; console.log(this.refs) &#125; render () &#123; return ( &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt; &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt; &lt;div ref=&quot;world&quot; className=&quot;world&quot;&gt;World&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;export default HelloWorld; 为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。 123456789101112131415// src/helloWorld.jsximport React, &#123; Component &#125; from &#x27;react&#x27;;class HelloWorld extends Component &#123; clickHander = () =&gt; &#123; console.log(this.refs) &#125; refCallback = (elem) =&gt; &#123; console.log(elem); &#125; render () &#123; return ( &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt; &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt; &lt;div ref=&#123;this.refCallback&#125; className=&quot;world&quot;&gt;World&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;export default HelloWorld; 组件生命周期件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数 react组件有三种状态 Mounted：已经插入真实DOM Updating：正在被重新渲染 Unmounted：已移出真实DOM 每个状态的处理函数 will：函数在进入状态之前调用 did：函数在进入状态之后调用 组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中 componentWillMount 在首次渲染完成之前，此时可修改组件的state componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM 组件属性(我们前面提到的props与state)更新的前后时刻 componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素 组件取消挂载之前(取消之后就没必要提供钩子函数了)componentWillUnmount 两个特殊的处理函数 componentWillReceiveProps(object nextProps)：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变-&gt;然后componentWillReceiveProps去判断是否需要重新渲染(shouldComponentUpdate)-&gt;如果不需要则继续running-&gt;如果需要则执行componentWillUpdate-&gt;渲染DOM树之后执行componentDidUpdate-&gt;进入running shouldComponentUpdate(nextProps, nextState)(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变-&gt;判断是否需要重新渲染新的props和state(shouldComponentUpdate) -&gt; 根据判断决定执行render过程还是继续·保持running状态 三个统一调用的方法,用于组件初始化，获取默认属性和状态 getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享 getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出 已挂载的方法 component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候 componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。 PropTypes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import PropTypes from &#x27;prop-types&#x27;;MyComponent.propTypes = &#123; // You can declare that a prop is a specific JS primitive. By default, these // are all optional. optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // Anything that can be rendered: numbers, strings, elements or an array // (or fragment) containing these types. optionalNode: PropTypes.node, // A React element. optionalElement: PropTypes.element, // You can also declare that a prop is an instance of a class. This uses // JS&#x27;s instanceof operator. optionalMessage: PropTypes.instanceOf(Message), // You can ensure that your prop is limited to specific values by treating // it as an enum. optionalEnum: PropTypes.oneOf([&#x27;News&#x27;, &#x27;Photos&#x27;]), // An object that could be one of many types optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // An array of a certain type optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // An object with property values of a certain type optionalObjectOf: PropTypes.objectOf(PropTypes.number), // An object taking on a particular shape optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // You can chain any of the above with `isRequired` to make sure a warning // is shown if the prop isn&#x27;t provided. requiredFunc: PropTypes.func.isRequired, // A value of any data type requiredAny: PropTypes.any.isRequired, // You can also specify a custom validator. It should return an Error // object if the validation fails. Don&#x27;t `console.warn` or throw, as this // won&#x27;t work inside `oneOfType`. customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( &#x27;Invalid prop `&#x27; + propName + &#x27;` supplied to&#x27; + &#x27; `&#x27; + componentName + &#x27;`. Validation failed.&#x27; ); &#125; &#125;, // You can also supply a custom validator to `arrayOf` and `objectOf`. // It should return an Error object if the validation fails. The validator // will be called for each key in the array or object. The first two // arguments of the validator are the array or object itself, and the // current item&#x27;s key. customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( &#x27;Invalid prop `&#x27; + propFullName + &#x27;` supplied to&#x27; + &#x27; `&#x27; + componentName + &#x27;`. Validation failed.&#x27; ); &#125; &#125;)&#125;;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"hello,world","slug":"hello-world-1","date":"2018-05-09T07:30:13.000Z","updated":"2023-01-11T02:56:11.680Z","comments":true,"path":"2018/05/09/hello-world-1/","link":"","permalink":"http://yoursite.com/2018/05/09/hello-world-1/","excerpt":"","text":"今天是个好日子","categories":[],"tags":[{"name":"哈哈哈1223","slug":"哈哈哈1223","permalink":"http://yoursite.com/tags/%E5%93%88%E5%93%88%E5%93%881223/"}]}],"categories":[],"tags":[{"name":"哈哈哈1223","slug":"哈哈哈1223","permalink":"http://yoursite.com/tags/%E5%93%88%E5%93%88%E5%93%881223/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]}