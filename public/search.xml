<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>&#39;react基础2&#39;</title>
      <link href="/2018/05/09/react%E5%9F%BA%E7%A1%802/"/>
      <url>/2018/05/09/react%E5%9F%BA%E7%A1%802/</url>
      <content type="html"><![CDATA[<p><a href="https://reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">react官网</a></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h4 id="1-无状态组件"><a href="#1-无状态组件" class="headerlink" title="1. 无状态组件"></a>1. 无状态组件</h4><ul><li>在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。</li><li>无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。</li><li>无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">//创建方式一,相当于es5的函数声明的方式创建</span><br><span class="line"> function NoState (props) &#123;</span><br><span class="line">     return (</span><br><span class="line">         &lt;div&gt;this is NoState Component&lt;/div&gt;</span><br><span class="line">     )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建方式二,相当于es5的函数表达式的方式创建</span><br><span class="line">const NoState = (props) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;this is Nostate Component&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default NoState</span><br></pre></td></tr></table></figure><hr><ul><li>无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。</li><li>无状态组件没有实例化得过程，因此无法访问组件this中的对象</li><li>无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理</li><li>无状态组件只能访问传入的props，同样的props会得到同样的渲染结果</li></ul><a id="more"></a><p>当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来<br>代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。<br>第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// helloWorld.jsx</span><br><span class="line">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class="line">class HelloWorld extends Component &#123;</span><br><span class="line">    clickHander = () =&gt; &#123;</span><br><span class="line">        console.log(this.props);</span><br><span class="line">        console.log(this.props.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div onClick=&#123;this.clickHander&#125;&gt;&#123; this.props.name &#125; say: Hello World!&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default HelloWorld;</span><br></pre></td></tr></table></figure></p><h2 id="组件之间的交互"><a href="#组件之间的交互" class="headerlink" title="组件之间的交互"></a>组件之间的交互</h2><h4 id="父组件与子组件之间的交互"><a href="#父组件与子组件之间的交互" class="headerlink" title="父组件与子组件之间的交互"></a>父组件与子组件之间的交互</h4><ol><li>父组件修改子组件，只需要修改传入的props属性</li><li>子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行<br>子组件与子组件之间的交互</li><li>通过影响共同的父组件来进行交互</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    switch: 0,</span><br><span class="line">    name: this.props.name1</span><br><span class="line">&#125;</span><br><span class="line">clickHander = () =&gt; &#123;</span><br><span class="line">    const &#123;name1, name2&#125; = this.props;</span><br><span class="line">    if (this.state.switch === 0) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            switch: 1,</span><br><span class="line">            name: name2</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            switch: 0,</span><br><span class="line">            name: name1</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div onClick=&#123;this.clickHander&#125;&gt;hello world !&#123;this.state.name&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。</p><p>state = {} // 等同于ES5构造函数中的this.state = {}<br>在对象中，我们可以通过this.state的方式来访问state中所存储的属性<br>setState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变<br>react赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了<br>而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行<br>// 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: ‘Jason’})// 然后立即查看它的值console.log(this.state.name) // 仍然为Tom，不会立即改变</p><h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p>react组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 当然可能命名会是其他的，大概表达一个意思，不深究哈</span><br><span class="line">&#123;</span><br><span class="line">    nodeName: &apos;div&apos;,</span><br><span class="line">    className: &apos;hello-world&apos;,</span><br><span class="line">    style: &#123;&#125;,</span><br><span class="line">    parentNodes: &apos;root&apos;,</span><br><span class="line">    childrenNodes: []</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">class HelloWorld extends Component &#123;</span><br><span class="line">    clickHander = () =&gt; &#123;</span><br><span class="line">        console.log(this.refs)</span><br><span class="line">    &#125; </span><br><span class="line">    render () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;</span><br><span class="line">                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;</span><br><span class="line">                &lt;div ref=&quot;world&quot; className=&quot;world&quot;&gt;World&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default HelloWorld;</span><br></pre></td></tr></table></figure></p><p>为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替<br>我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。<br>当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// src/helloWorld.jsx</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;class HelloWorld extends Component &#123;</span><br><span class="line">    clickHander = () =&gt; &#123;</span><br><span class="line">        console.log(this.refs)</span><br><span class="line">    &#125; refCallback = (elem) =&gt; &#123;</span><br><span class="line">        console.log(elem);</span><br><span class="line">    &#125; render () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;</span><br><span class="line">                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;</span><br><span class="line">                &lt;div ref=&#123;this.refCallback&#125; className=&quot;world&quot;&gt;World&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;export default HelloWorld;</span><br></pre></td></tr></table></figure></p><h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p>件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数</p><h5 id="react组件有三种状态："><a href="#react组件有三种状态：" class="headerlink" title="react组件有三种状态："></a>react组件有三种状态：</h5><ul><li>Mounted：已经插入真实DOM</li><li>Updating：正在被重新渲染</li><li>Unmounted：已移出真实DOM</li><li><h5 id="每个状态的处理函数"><a href="#每个状态的处理函数" class="headerlink" title="每个状态的处理函数"></a>每个状态的处理函数</h5></li><li>will：函数在进入状态之前调用</li><li>did：函数在进入状态之后调用</li></ul><h5 id="组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中"><a href="#组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中" class="headerlink" title="组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中"></a>组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中</h5><ul><li>componentWillMount 在首次渲染完成之前，此时可修改组件的state</li><li>componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM</li></ul><h5 id="组件属性-我们前面提到的props与state-更新的前后时刻"><a href="#组件属性-我们前面提到的props与state-更新的前后时刻" class="headerlink" title="组件属性(我们前面提到的props与state)更新的前后时刻"></a>组件属性(我们前面提到的props与state)更新的前后时刻</h5><ul><li>componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state</li><li>componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素</li></ul><h6 id="组件取消挂载之前-取消之后就没必要提供钩子函数了"><a href="#组件取消挂载之前-取消之后就没必要提供钩子函数了" class="headerlink" title="组件取消挂载之前(取消之后就没必要提供钩子函数了)"></a>组件取消挂载之前(取消之后就没必要提供钩子函数了)</h6><p><code>componentWillUnmount</code></p><h6 id="两个特殊的处理函数"><a href="#两个特殊的处理函数" class="headerlink" title="两个特殊的处理函数"></a>两个特殊的处理函数</h6><ul><li><code>componentWillReceiveProps(object nextProps)</code>：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变-&gt;然后componentWillReceiveProps去判断是否需要重新渲染(<code>shouldComponentUpdate</code>)-&gt;如果不需要则继续running-&gt;如果需要则执行<code>componentWillUpdate</code>-&gt;渲染DOM树之后执行<code>componentDidUpdate</code>-&gt;进入running</li><li><code>shouldComponentUpdate(nextProps, nextState)</code>(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变-&gt;判断是否需要重新渲染新的props和state(<code>shouldComponentUpdate</code>) -&gt; 根据判断决定执行render过程还是继续·保持running状态</li></ul><h6 id="三个统一调用的方法-用于组件初始化，获取默认属性和状态"><a href="#三个统一调用的方法-用于组件初始化，获取默认属性和状态" class="headerlink" title="三个统一调用的方法,用于组件初始化，获取默认属性和状态"></a>三个统一调用的方法,用于组件初始化，获取默认属性和状态</h6><ul><li>getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享</li><li>getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props</li><li>render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出</li></ul><h6 id="已挂载的方法"><a href="#已挂载的方法" class="headerlink" title="已挂载的方法"></a>已挂载的方法</h6><ul><li>component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候</li></ul><blockquote><p>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。</p></blockquote><p><img src="http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg" alt="image"></p><h2 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import PropTypes from &apos;prop-types&apos;;</span><br><span class="line"></span><br><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">  // You can declare that a prop is a specific JS primitive. By default, these</span><br><span class="line">  // are all optional.</span><br><span class="line">  optionalArray: PropTypes.array,</span><br><span class="line">  optionalBool: PropTypes.bool,</span><br><span class="line">  optionalFunc: PropTypes.func,</span><br><span class="line">  optionalNumber: PropTypes.number,</span><br><span class="line">  optionalObject: PropTypes.object,</span><br><span class="line">  optionalString: PropTypes.string,</span><br><span class="line">  optionalSymbol: PropTypes.symbol,</span><br><span class="line"></span><br><span class="line">  // Anything that can be rendered: numbers, strings, elements or an array</span><br><span class="line">  // (or fragment) containing these types.</span><br><span class="line">  optionalNode: PropTypes.node,</span><br><span class="line"></span><br><span class="line">  // A React element.</span><br><span class="line">  optionalElement: PropTypes.element,</span><br><span class="line"></span><br><span class="line">  // You can also declare that a prop is an instance of a class. This uses</span><br><span class="line">  // JS&apos;s instanceof operator.</span><br><span class="line">  optionalMessage: PropTypes.instanceOf(Message),</span><br><span class="line"></span><br><span class="line">  // You can ensure that your prop is limited to specific values by treating</span><br><span class="line">  // it as an enum.</span><br><span class="line">  optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),</span><br><span class="line"></span><br><span class="line">  // An object that could be one of many types</span><br><span class="line">  optionalUnion: PropTypes.oneOfType([</span><br><span class="line">    PropTypes.string,</span><br><span class="line">    PropTypes.number,</span><br><span class="line">    PropTypes.instanceOf(Message)</span><br><span class="line">  ]),</span><br><span class="line"></span><br><span class="line">  // An array of a certain type</span><br><span class="line">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  // An object with property values of a certain type</span><br><span class="line">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  // An object taking on a particular shape</span><br><span class="line">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    fontSize: PropTypes.number</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  // You can chain any of the above with `isRequired` to make sure a warning</span><br><span class="line">  // is shown if the prop isn&apos;t provided.</span><br><span class="line">  requiredFunc: PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">  // A value of any data type</span><br><span class="line">  requiredAny: PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">  // You can also specify a custom validator. It should return an Error</span><br><span class="line">  // object if the validation fails. Don&apos;t `console.warn` or throw, as this</span><br><span class="line">  // won&apos;t work inside `oneOfType`.</span><br><span class="line">  customProp: function(props, propName, componentName) &#123;</span><br><span class="line">    if (!/matchme/.test(props[propName])) &#123;</span><br><span class="line">      return new Error(</span><br><span class="line">        &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; +</span><br><span class="line">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // You can also supply a custom validator to `arrayOf` and `objectOf`.</span><br><span class="line">  // It should return an Error object if the validation fails. The validator</span><br><span class="line">  // will be called for each key in the array or object. The first two</span><br><span class="line">  // arguments of the validator are the array or object itself, and the</span><br><span class="line">  // current item&apos;s key.</span><br><span class="line">  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;</span><br><span class="line">    if (!/matchme/.test(propValue[key])) &#123;</span><br><span class="line">      return new Error(</span><br><span class="line">        &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; +</span><br><span class="line">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&#39;react基础&#39;</title>
      <link href="/2018/05/09/react%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/05/09/react%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p><a href="https://reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">react官网</a></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h4 id="1-无状态组件"><a href="#1-无状态组件" class="headerlink" title="1. 无状态组件"></a>1. 无状态组件</h4><ul><li>在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。</li><li>无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。</li><li>无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">//创建方式一,相当于es5的函数声明的方式创建</span><br><span class="line"> function NoState (props) &#123;</span><br><span class="line">     return (</span><br><span class="line">         &lt;div&gt;this is NoState Component&lt;/div&gt;</span><br><span class="line">     )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建方式二,相当于es5的函数表达式的方式创建</span><br><span class="line">const NoState = (props) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;this is Nostate Component&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default NoState</span><br></pre></td></tr></table></figure><hr><ul><li>无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。</li><li>无状态组件没有实例化得过程，因此无法访问组件this中的对象</li><li>无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理</li><li>无状态组件只能访问传入的props，同样的props会得到同样的渲染结果</li></ul><a id="more"></a><p>当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来<br>代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。<br>第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// helloWorld.jsx</span><br><span class="line">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class="line">class HelloWorld extends Component &#123;</span><br><span class="line">    clickHander = () =&gt; &#123;</span><br><span class="line">        console.log(this.props);</span><br><span class="line">        console.log(this.props.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div onClick=&#123;this.clickHander&#125;&gt;&#123; this.props.name &#125; say: Hello World!&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default HelloWorld;</span><br></pre></td></tr></table></figure></p><h2 id="组件之间的交互"><a href="#组件之间的交互" class="headerlink" title="组件之间的交互"></a>组件之间的交互</h2><h4 id="父组件与子组件之间的交互"><a href="#父组件与子组件之间的交互" class="headerlink" title="父组件与子组件之间的交互"></a>父组件与子组件之间的交互</h4><ol><li>父组件修改子组件，只需要修改传入的props属性</li><li>子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行<br>子组件与子组件之间的交互</li><li>通过影响共同的父组件来进行交互</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    switch: 0,</span><br><span class="line">    name: this.props.name1</span><br><span class="line">&#125;</span><br><span class="line">clickHander = () =&gt; &#123;</span><br><span class="line">    const &#123;name1, name2&#125; = this.props;</span><br><span class="line">    if (this.state.switch === 0) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            switch: 1,</span><br><span class="line">            name: name2</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            switch: 0,</span><br><span class="line">            name: name1</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div onClick=&#123;this.clickHander&#125;&gt;hello world !&#123;this.state.name&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。</p><p>state = {} // 等同于ES5构造函数中的this.state = {}<br>在对象中，我们可以通过this.state的方式来访问state中所存储的属性<br>setState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变<br>react赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了<br>而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行<br>// 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: ‘Jason’})// 然后立即查看它的值console.log(this.state.name) // 仍然为Tom，不会立即改变</p><h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p>react组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 当然可能命名会是其他的，大概表达一个意思，不深究哈</span><br><span class="line">&#123;</span><br><span class="line">    nodeName: &apos;div&apos;,</span><br><span class="line">    className: &apos;hello-world&apos;,</span><br><span class="line">    style: &#123;&#125;,</span><br><span class="line">    parentNodes: &apos;root&apos;,</span><br><span class="line">    childrenNodes: []</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">class HelloWorld extends Component &#123;</span><br><span class="line">    clickHander = () =&gt; &#123;</span><br><span class="line">        console.log(this.refs)</span><br><span class="line">    &#125; </span><br><span class="line">    render () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;</span><br><span class="line">                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;</span><br><span class="line">                &lt;div ref=&quot;world&quot; className=&quot;world&quot;&gt;World&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default HelloWorld;</span><br></pre></td></tr></table></figure></p><p>为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替<br>我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。<br>当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// src/helloWorld.jsx</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;class HelloWorld extends Component &#123;</span><br><span class="line">    clickHander = () =&gt; &#123;</span><br><span class="line">        console.log(this.refs)</span><br><span class="line">    &#125; refCallback = (elem) =&gt; &#123;</span><br><span class="line">        console.log(elem);</span><br><span class="line">    &#125; render () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;</span><br><span class="line">                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;</span><br><span class="line">                &lt;div ref=&#123;this.refCallback&#125; className=&quot;world&quot;&gt;World&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;export default HelloWorld;</span><br></pre></td></tr></table></figure></p><h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p>件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数</p><h5 id="react组件有三种状态："><a href="#react组件有三种状态：" class="headerlink" title="react组件有三种状态："></a>react组件有三种状态：</h5><ul><li>Mounted：已经插入真实DOM</li><li>Updating：正在被重新渲染</li><li>Unmounted：已移出真实DOM</li><li><h5 id="每个状态的处理函数"><a href="#每个状态的处理函数" class="headerlink" title="每个状态的处理函数"></a>每个状态的处理函数</h5></li><li>will：函数在进入状态之前调用</li><li>did：函数在进入状态之后调用</li></ul><h5 id="组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中"><a href="#组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中" class="headerlink" title="组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中"></a>组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中</h5><ul><li>componentWillMount 在首次渲染完成之前，此时可修改组件的state</li><li>componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM</li></ul><h5 id="组件属性-我们前面提到的props与state-更新的前后时刻"><a href="#组件属性-我们前面提到的props与state-更新的前后时刻" class="headerlink" title="组件属性(我们前面提到的props与state)更新的前后时刻"></a>组件属性(我们前面提到的props与state)更新的前后时刻</h5><ul><li>componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state</li><li>componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素</li></ul><h6 id="组件取消挂载之前-取消之后就没必要提供钩子函数了"><a href="#组件取消挂载之前-取消之后就没必要提供钩子函数了" class="headerlink" title="组件取消挂载之前(取消之后就没必要提供钩子函数了)"></a>组件取消挂载之前(取消之后就没必要提供钩子函数了)</h6><p><code>componentWillUnmount</code></p><h6 id="两个特殊的处理函数"><a href="#两个特殊的处理函数" class="headerlink" title="两个特殊的处理函数"></a>两个特殊的处理函数</h6><ul><li><code>componentWillReceiveProps(object nextProps)</code>：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变-&gt;然后componentWillReceiveProps去判断是否需要重新渲染(<code>shouldComponentUpdate</code>)-&gt;如果不需要则继续running-&gt;如果需要则执行<code>componentWillUpdate</code>-&gt;渲染DOM树之后执行<code>componentDidUpdate</code>-&gt;进入running</li><li><code>shouldComponentUpdate(nextProps, nextState)</code>(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变-&gt;判断是否需要重新渲染新的props和state(<code>shouldComponentUpdate</code>) -&gt; 根据判断决定执行render过程还是继续·保持running状态</li></ul><h6 id="三个统一调用的方法-用于组件初始化，获取默认属性和状态"><a href="#三个统一调用的方法-用于组件初始化，获取默认属性和状态" class="headerlink" title="三个统一调用的方法,用于组件初始化，获取默认属性和状态"></a>三个统一调用的方法,用于组件初始化，获取默认属性和状态</h6><ul><li>getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享</li><li>getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props</li><li>render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出</li></ul><h6 id="已挂载的方法"><a href="#已挂载的方法" class="headerlink" title="已挂载的方法"></a>已挂载的方法</h6><ul><li>component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候</li></ul><blockquote><p>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。</p></blockquote><p><img src="http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg" alt="image"></p><h2 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import PropTypes from &apos;prop-types&apos;;</span><br><span class="line"></span><br><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">  // You can declare that a prop is a specific JS primitive. By default, these</span><br><span class="line">  // are all optional.</span><br><span class="line">  optionalArray: PropTypes.array,</span><br><span class="line">  optionalBool: PropTypes.bool,</span><br><span class="line">  optionalFunc: PropTypes.func,</span><br><span class="line">  optionalNumber: PropTypes.number,</span><br><span class="line">  optionalObject: PropTypes.object,</span><br><span class="line">  optionalString: PropTypes.string,</span><br><span class="line">  optionalSymbol: PropTypes.symbol,</span><br><span class="line"></span><br><span class="line">  // Anything that can be rendered: numbers, strings, elements or an array</span><br><span class="line">  // (or fragment) containing these types.</span><br><span class="line">  optionalNode: PropTypes.node,</span><br><span class="line"></span><br><span class="line">  // A React element.</span><br><span class="line">  optionalElement: PropTypes.element,</span><br><span class="line"></span><br><span class="line">  // You can also declare that a prop is an instance of a class. This uses</span><br><span class="line">  // JS&apos;s instanceof operator.</span><br><span class="line">  optionalMessage: PropTypes.instanceOf(Message),</span><br><span class="line"></span><br><span class="line">  // You can ensure that your prop is limited to specific values by treating</span><br><span class="line">  // it as an enum.</span><br><span class="line">  optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),</span><br><span class="line"></span><br><span class="line">  // An object that could be one of many types</span><br><span class="line">  optionalUnion: PropTypes.oneOfType([</span><br><span class="line">    PropTypes.string,</span><br><span class="line">    PropTypes.number,</span><br><span class="line">    PropTypes.instanceOf(Message)</span><br><span class="line">  ]),</span><br><span class="line"></span><br><span class="line">  // An array of a certain type</span><br><span class="line">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  // An object with property values of a certain type</span><br><span class="line">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  // An object taking on a particular shape</span><br><span class="line">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    fontSize: PropTypes.number</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  // You can chain any of the above with `isRequired` to make sure a warning</span><br><span class="line">  // is shown if the prop isn&apos;t provided.</span><br><span class="line">  requiredFunc: PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">  // A value of any data type</span><br><span class="line">  requiredAny: PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">  // You can also specify a custom validator. It should return an Error</span><br><span class="line">  // object if the validation fails. Don&apos;t `console.warn` or throw, as this</span><br><span class="line">  // won&apos;t work inside `oneOfType`.</span><br><span class="line">  customProp: function(props, propName, componentName) &#123;</span><br><span class="line">    if (!/matchme/.test(props[propName])) &#123;</span><br><span class="line">      return new Error(</span><br><span class="line">        &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; +</span><br><span class="line">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // You can also supply a custom validator to `arrayOf` and `objectOf`.</span><br><span class="line">  // It should return an Error object if the validation fails. The validator</span><br><span class="line">  // will be called for each key in the array or object. The first two</span><br><span class="line">  // arguments of the validator are the array or object itself, and the</span><br><span class="line">  // current item&apos;s key.</span><br><span class="line">  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;</span><br><span class="line">    if (!/matchme/.test(propValue[key])) &#123;</span><br><span class="line">      return new Error(</span><br><span class="line">        &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; +</span><br><span class="line">        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hello,world</title>
      <link href="/2018/05/09/hello-world-1/"/>
      <url>/2018/05/09/hello-world-1/</url>
      <content type="html"><![CDATA[<h4 id="今天是个好日子"><a href="#今天是个好日子" class="headerlink" title="今天是个好日子"></a>今天是个好日子</h4>]]></content>
      
      
        <tags>
            
            <tag> 哈哈哈1223 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/09/hello-world/"/>
      <url>/2018/05/09/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><hr><h2 id="title-Hello-World"><a href="#title-Hello-World" class="headerlink" title="title: Hello World"></a>title: Hello World</h2><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start-1"><a href="#Quick-Start-1" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post-1"><a href="#Create-a-new-post-1" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server-1"><a href="#Run-server-1" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files-1"><a href="#Generate-static-files-1" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites-1"><a href="#Deploy-to-remote-sites-1" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><hr><h2 id="title-Hello-World-1"><a href="#title-Hello-World-1" class="headerlink" title="title: Hello World"></a>title: Hello World</h2><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start-2"><a href="#Quick-Start-2" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post-2"><a href="#Create-a-new-post-2" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server-2"><a href="#Run-server-2" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files-2"><a href="#Generate-static-files-2" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites-2"><a href="#Deploy-to-remote-sites-2" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
        <tags>
            
            <tag> 哈哈哈1223 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
