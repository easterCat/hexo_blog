{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"themes/tree/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"themes/tree/source/Tree.png","path":"Tree.png","modified":1,"renderable":1},{"_id":"themes/tree/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/tree/source/css/github-markdown-light.css","path":"css/github-markdown-light.css","modified":1,"renderable":1},{"_id":"themes/tree/source/css/main.css","path":"css/main.css","modified":1,"renderable":1},{"_id":"themes/tree/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/tree/source/lib/jquery-3.4.1.min.js","path":"lib/jquery-3.4.1.min.js","modified":1,"renderable":1},{"_id":"themes/tree/source/lib/jquery.pjax.js","path":"lib/jquery.pjax.js","modified":1,"renderable":1},{"_id":"themes/tree/source/lib/font-awesome/font-awesome.min.css","path":"lib/font-awesome/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/tree/source/lib/valine/Valine-1.3.10-min.js","path":"lib/valine/Valine-1.3.10-min.js","modified":1,"renderable":1},{"_id":"themes/tree/source/lib/valine/av-3.0.4-min.js","path":"lib/valine/av-3.0.4-min.js","modified":1,"renderable":1},{"_id":"themes/tree/source/lib/busuanzi/2.3/busuanzi.pure.mini.js","path":"lib/busuanzi/2.3/busuanzi.pure.mini.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"b3f06e21f6f32eba574852d69a046c92c9ee1708","modified":1673409175947},{"_id":"source/_posts/AndroidStudio操作.md","hash":"bbcec3b71b71b3331582c77317b9768e07a7b993","modified":1676972115101},{"_id":"source/_posts/SEO技巧.md","hash":"f6dd3138ba151c3922847383a6da8b0466c97c5a","modified":1676972115106},{"_id":"source/_posts/flask-sqlalchemy使用.md","hash":"7b5ec058ca8044652a0d026f928535fef74c90a4","modified":1676972115107},{"_id":"source/_posts/react基础.md","hash":"2e6cac4cd5199f3472870b96237d0d43fa90499a","modified":1676972115109},{"_id":"source/about/index.md","hash":"9fc6ad091412626c3c8418288b5d87310edd92fb","modified":1676972721507},{"_id":"source/categories/index.md","hash":"ff07229a0a61da6e39c27c03f81b54f627f636a8","modified":1676972115110},{"_id":"source/images/avatar.jpg","hash":"1163c8cdc6377a21641c89bc547515223697466f","modified":1673405771682},{"_id":"source/photos/index.md","hash":"329e5e3c65a8355152a9c9ffaf48be37951ff9b9","modified":1673405771682},{"_id":"source/tags/index.md","hash":"e2c4f5d30569bc6eace09dbdd7d7a83c58d0a8e5","modified":1676972115111},{"_id":"source/_posts/Git/git常用命令的使用.md","hash":"5a315aee3a28756dc347784640464ce4d14140bd","modified":1676972115107},{"_id":"source/_posts/Mysql/mysql的processlist中处理表连接.md","hash":"cca10c42bfb5c10eb7d9a924288b04423c8e9806","modified":1676972115108},{"_id":"source/_posts/Nginx/nginx配置.md","hash":"c1685ead0af9e12aa9a69685bedae00685447be0","modified":1676972115108},{"_id":"source/_posts/Nginx/nginx配置https.md","hash":"5be3b7668b59691df997a32d56f04af6f7fa5afe","modified":1676972115108},{"_id":"source/_posts/Node/Nvm管理工具.md","hash":"b16d48a3c6332cae78c9143b4a54922f94680ccf","modified":1676972115105},{"_id":"source/_posts/Npm/Npm和Package描述文件.md","hash":"4e725a9dbd79bf98fcca2ae5fb81047b0331f963","modified":1676972115102},{"_id":"source/_posts/Npm/Npm描述文件.md","hash":"d027cd90428901a02b5678ad68a3a7f23392878b","modified":1676972115103},{"_id":"source/_posts/Npm/Npm版本控制.md","hash":"99cec2115247d9f5a7ceebd58823db7620284ba4","modified":1676972115103},{"_id":"source/_posts/Npm/Npm脚本命令.md","hash":"8cc66597242b8edb5b253d52ad36d1dbbb089ec8","modified":1676972115104},{"_id":"source/_posts/Npm/Npm配置文件.md","hash":"7557644933e3269d10adec380ff79b574d133434","modified":1676972115105},{"_id":"source/_posts/Personal/2023个人总结.md","hash":"446d7039e16cdaffe9233a6f8bbd230cff2a03bd","modified":1676972115100},{"_id":"source/_posts/Ubuntu/ubuntu18安装nginx.md","hash":"daeb034d4aa58f2906be4abb3c26fff8e6eb95d5","modified":1676972115110},{"_id":"themes/tree/.DS_Store","hash":"ddaddc23d03a190b64f04c260c06a367b659746c","modified":1675828330615},{"_id":"themes/tree/README.md","hash":"b3f890241282cfb722e223f42c0e3c32b013e9c7","modified":1674201109160},{"_id":"themes/tree/_config.yml","hash":"be843edcdac2a71a9af89b7a1d0b26544aa900f2","modified":1676973028746},{"_id":"themes/tree/layout/index.ejs","hash":"89c8aebef7ad7863ead3d92d282252d1d420618c","modified":1674201109162},{"_id":"themes/tree/layout/tags.ejs","hash":"2bc64cf4c24da9ce9a7863799fa37b2dd910ba10","modified":1676971402364},{"_id":"themes/tree/layout/categories.ejs","hash":"cdd97fe1b4a38bc5ca1d3c93d269dd87d1ef338a","modified":1676971413771},{"_id":"themes/tree/layout/layout.ejs","hash":"b1cbe3e0c52a8fa644a5adb97b31b5ecfdec2162","modified":1674201109162},{"_id":"themes/tree/layout/post.ejs","hash":"d88ea98344bc47f4518e6831f3aa05b62dab45a3","modified":1676971408310},{"_id":"themes/tree/source/.DS_Store","hash":"4ec08a9e4e06de45deb885883958ab553cebef02","modified":1675828325496},{"_id":"themes/tree/source/404.html","hash":"cfa1b96d02d143d77c0ba519dab1c23de0cae6ee","modified":1674201109162},{"_id":"themes/tree/source/favicon.ico","hash":"268be0a863caae7c5a732fb8a911a81434f31117","modified":1674201109165},{"_id":"themes/tree/layout/_partial/head.ejs","hash":"2359b6482a3dd6a3088d1234e9b9d4ef51e10e73","modified":1676971456844},{"_id":"themes/tree/layout/_partial/footer.ejs","hash":"1bbd6ce41784b3f7011b928b168bf84755a0d9b9","modified":1674201109161},{"_id":"themes/tree/layout/_partial/header.ejs","hash":"abb98bf2ae182e4988f65b9a8f0f024dbd97185b","modified":1674201109161},{"_id":"themes/tree/layout/_partial/sidebar.ejs","hash":"726499fca6d8d6411bf6d0aa5542fe3070766271","modified":1674201109161},{"_id":"themes/tree/layout/_partial/totop.ejs","hash":"a94c4b350b76d21bb530095981049a2647cc6273","modified":1674201109161},{"_id":"themes/tree/source/css/github-markdown-light.css","hash":"5ec30167ce93df0c75ed1c85dfb373b4df107637","modified":1676971269985},{"_id":"themes/tree/source/css/main.css","hash":"177ae2c25c3d40d4cfb56c1b3fd4e8b86c5fdbb8","modified":1676972964557},{"_id":"themes/tree/source/js/main.js","hash":"fa52f233d46695f3876f90d4cfdfa59d2c568e12","modified":1674202807405},{"_id":"themes/tree/source/lib/jquery.pjax.js","hash":"13485a1e2dc9c8df28267549de1b8af8f39061d9","modified":1674201109168},{"_id":"themes/tree/source/lib/font-awesome/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1674201109166},{"_id":"themes/tree/source/lib/busuanzi/2.3/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1674201109165},{"_id":"themes/tree/source/lib/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1674201109168},{"_id":"themes/tree/source/lib/valine/Valine-1.3.10-min.js","hash":"e3a340d0c39eee2ae651284fda9d351e752fcbd0","modified":1674201109170},{"_id":"themes/tree/source/Tree.png","hash":"e5a30d5edf5aa2dc39fb4db7b4761b516826cf5b","modified":1674201109164},{"_id":"themes/tree/source/lib/valine/av-3.0.4-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1674201109172},{"_id":"public/atom.xml","hash":"5c4f68d1bed71290caf9cbf52e00c361b9029693","modified":1676973163498},{"_id":"public/content.json","hash":"bb1e4904d1ffa842b5c1ed136ec5ae7f164ff362","modified":1676973163498},{"_id":"public/search.xml","hash":"4ced60a7b060073aec50c8886e4dd8d34632f256","modified":1676973163498},{"_id":"public/categories/index.html","hash":"54502f0805535098541f814401a8ce962972622a","modified":1676973163498},{"_id":"public/about/index.html","hash":"f88154a4aec0d18268832ac233846e46321c34f9","modified":1676973163498},{"_id":"public/photos/index.html","hash":"095117c45f5033ba8ac5e8346526e617d23a1f79","modified":1676973163498},{"_id":"public/tags/index.html","hash":"928424b2b0bca885a43d3291da35bddfb8e928d2","modified":1676973163498},{"_id":"public/2023/02/08/Node/Nvm管理工具/index.html","hash":"43395854a325aae3b7e6ddd1268690cbf0129d04","modified":1676973163498},{"_id":"public/2023/02/08/Npm/Npm配置文件/index.html","hash":"84b5632b4c38e4fed23c33e07abd68c36bae5f82","modified":1676973163498},{"_id":"public/2023/01/28/Personal/2023个人总结/index.html","hash":"ab6445d024601f46ca8b4dda469fc0644cd108e7","modified":1676973163498},{"_id":"public/2023/01/16/Mysql/mysql的processlist中处理表连接/index.html","hash":"a5d51f140fd6921db864b59584800a567034d0af","modified":1676973163498},{"_id":"public/2023/01/12/flask-sqlalchemy使用/index.html","hash":"e21972c198a3d39397253a9ae65147a9bfa120c9","modified":1676973163498},{"_id":"public/2023/01/11/Git/git常用命令的使用/index.html","hash":"8648d60c8013bd2d8ba91af32dbcefbff6fb7240","modified":1676973163498},{"_id":"public/2023/01/11/SEO技巧/index.html","hash":"6f2b6577d9410b26262f55a6a2b787b2f6d959cf","modified":1676973163498},{"_id":"public/2023/01/11/AndroidStudio操作/index.html","hash":"fd079cce84b00fd7bdc8ba2c6d0a152041af8f14","modified":1676973163498},{"_id":"public/2023/01/11/Ubuntu/ubuntu18安装nginx/index.html","hash":"6824d83bd4d1af33762e1727e7bc725cc69df27d","modified":1676973163498},{"_id":"public/2023/01/11/Nginx/nginx配置https/index.html","hash":"83785cb18356c8e9842b95e44b147039b68636d6","modified":1676973163498},{"_id":"public/categories/Nginx/index.html","hash":"eeb7243c9bfae93ddeaf76897f89bda0271166eb","modified":1676973163498},{"_id":"public/archives/page/2/index.html","hash":"42a9e2a0a779fb043c5824e12299ed0c05f6bcc6","modified":1676973163498},{"_id":"public/archives/2018/index.html","hash":"ef2e4e8a46a3c4009e47e2904ba02c564c3082e2","modified":1676973163498},{"_id":"public/archives/2018/05/index.html","hash":"ef2e4e8a46a3c4009e47e2904ba02c564c3082e2","modified":1676973163498},{"_id":"public/archives/2023/page/2/index.html","hash":"cd52a1110dc9b6e2e8399b229877a92c79b77fb2","modified":1676973163498},{"_id":"public/archives/2023/02/index.html","hash":"85324031c3033b6275efa6a7c00a02982d18fcad","modified":1676973163498},{"_id":"public/page/2/index.html","hash":"16956afc379ca1bbab3f867f240d9d232299fe7d","modified":1676973163498},{"_id":"public/tags/工具/index.html","hash":"b28495fada9833943e6dddff8b3729beffcbce8c","modified":1676973163498},{"_id":"public/tags/SEO/index.html","hash":"a6c651ee18aa62c610e5dfe75bd11187ef8bfbf7","modified":1676973163498},{"_id":"public/tags/Python/index.html","hash":"85d2f0fef59bb884833f7eac30bdf9601e7069df","modified":1676973163498},{"_id":"public/tags/React/index.html","hash":"ef2e4e8a46a3c4009e47e2904ba02c564c3082e2","modified":1676973163498},{"_id":"public/tags/Mysql/index.html","hash":"46997094b6a2afbfde084d374fe670eb9aa0e27e","modified":1676973163498},{"_id":"public/tags/Git/index.html","hash":"9ffb03c8c197965ceed56536ee36cf6b4191916e","modified":1676973163498},{"_id":"public/tags/Nginx/index.html","hash":"eeb7243c9bfae93ddeaf76897f89bda0271166eb","modified":1676973163498},{"_id":"public/tags/Https/index.html","hash":"7fd8439c69efb43897d2dfbba62cb08f7d2f8cdf","modified":1676973163498},{"_id":"public/tags/Node/index.html","hash":"7049cd9faecca18991c1e991d732e5b8ef61f5f6","modified":1676973163498},{"_id":"public/tags/npm/index.html","hash":"2641554c5528ab7ad259c9f70767e275b66918b7","modified":1676973163498},{"_id":"public/tags/Npm/index.html","hash":"5fc8422b9d30b1792fbbb125814aff21a2ee64f7","modified":1676973163498},{"_id":"public/tags/总结/index.html","hash":"58d6c40d047f16b75be154fc5c713f65326b469c","modified":1676973163498},{"_id":"public/tags/Ubuntu/index.html","hash":"29eed8837f4a3842350e572527bf27f7bbac49f2","modified":1676973163498},{"_id":"public/2023/02/08/Npm/Npm脚本命令/index.html","hash":"6e5010e50a64b258cc6ddd20325611fb5217f310","modified":1676973163498},{"_id":"public/2023/02/08/Npm/Npm版本控制/index.html","hash":"f13cdbec62db92d697bf1797c70721d9686ab14b","modified":1676973163498},{"_id":"public/2023/02/06/Npm/Npm和Package描述文件/index.html","hash":"55baa44648749dc5066a2d70e3200ecc4fd872e5","modified":1676973163498},{"_id":"public/2023/02/08/Npm/Npm描述文件/index.html","hash":"ff69c543c0891ed25e627aed0cb9288dd5b0af0f","modified":1676973163498},{"_id":"public/2023/01/11/Nginx/nginx配置/index.html","hash":"15474de1f38c2a9b4920c40d7547fdade3992bd3","modified":1676973163498},{"_id":"public/archives/index.html","hash":"f65b66721e1ea5efd8ba11e9bec4282c67318bf5","modified":1676973163498},{"_id":"public/2018/05/09/react基础/index.html","hash":"f54cae3e1902cdaf25f906713f221810fe3835a6","modified":1676973163498},{"_id":"public/archives/2023/index.html","hash":"ed8630573c5991da588afa355c18a99e35ec2392","modified":1676973163498},{"_id":"public/archives/2023/01/index.html","hash":"d67205e63d7e040213a1f3937d20080de1aee9de","modified":1676973163498},{"_id":"public/index.html","hash":"ecb9ae8de1133a9c3b9e6c95091750298e923115","modified":1676973163498},{"_id":"public/CNAME","hash":"b3f06e21f6f32eba574852d69a046c92c9ee1708","modified":1676973163498},{"_id":"public/favicon.ico","hash":"268be0a863caae7c5a732fb8a911a81434f31117","modified":1676973163498},{"_id":"public/images/avatar.jpg","hash":"1163c8cdc6377a21641c89bc547515223697466f","modified":1676973163498},{"_id":"public/404.html","hash":"cfa1b96d02d143d77c0ba519dab1c23de0cae6ee","modified":1676973163498},{"_id":"public/css/main.css","hash":"177ae2c25c3d40d4cfb56c1b3fd4e8b86c5fdbb8","modified":1676973163498},{"_id":"public/js/main.js","hash":"fa52f233d46695f3876f90d4cfdfa59d2c568e12","modified":1676973163498},{"_id":"public/lib/busuanzi/2.3/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1676973163498},{"_id":"public/css/github-markdown-light.css","hash":"5ec30167ce93df0c75ed1c85dfb373b4df107637","modified":1676973163498},{"_id":"public/lib/jquery.pjax.js","hash":"13485a1e2dc9c8df28267549de1b8af8f39061d9","modified":1676973163498},{"_id":"public/lib/font-awesome/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1676973163498},{"_id":"public/lib/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1676973163498},{"_id":"public/lib/valine/Valine-1.3.10-min.js","hash":"e3a340d0c39eee2ae651284fda9d351e752fcbd0","modified":1676973163498},{"_id":"public/lib/valine/av-3.0.4-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1676973163498},{"_id":"public/Tree.png","hash":"e5a30d5edf5aa2dc39fb4db7b4761b516826cf5b","modified":1676973163498}],"Category":[{"name":"Nginx","_id":"clee2iuln000hbkh07greea34"}],"Data":[],"Page":[{"title":"about","date":"2018-05-09T09:02:05.000Z","_content":"\n# hello world\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-05-09 17:02:05\n---\n\n# hello world\n","updated":"2023-02-21T09:45:21.507Z","path":"about/index.html","comments":1,"layout":"page","_id":"clee2iul50000bkh0ctydhnat","content":"<h1 id=\"hello-world\"><a href=\"#hello-world\" class=\"headerlink\" title=\"hello world\"></a>hello world</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"hello-world\"><a href=\"#hello-world\" class=\"headerlink\" title=\"hello world\"></a>hello world</h1>"},{"title":"categories","date":"2021-02-26T08:36:55.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-02-26 16:36:55\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2023-02-21T09:35:15.110Z","path":"categories/index.html","comments":1,"_id":"clee2iulb0002bkh0hxpahp0u","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"photos","date":"2018-05-09T09:27:51.000Z","_content":"","source":"photos/index.md","raw":"---\ntitle: photos\ndate: 2018-05-09 17:27:51\n---\n","updated":"2023-01-11T02:56:11.682Z","path":"photos/index.html","comments":1,"layout":"page","_id":"clee2iulf0005bkh06minaxj9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2021-02-26T08:36:55.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-02-26 16:36:55\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2023-02-21T09:35:15.111Z","path":"tags/index.html","comments":1,"_id":"clee2iulh0007bkh01njk1awb","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"AndroidStudio操作","date":"2023-01-11T04:09:05.000Z","_content":"\n# Android studio操作\n\ncommand + shift + R 当前文件替换\n\ncommand + shift + F 全局查找\n\ncommand + shift + R 全局替换\n\ncommand + O 全局搜索类**/**文件**/**关键字**/(**包括系统类**,**自定义类**)**\n\ncommand + option + O 全局搜索方法\n\noption + enter 将**StatelessWidget**转 **StatefulWidget**   快速修复  ****快速生成构造方法\n\ncommand  + option + W 抽取代码为单独的**Widget**\n\ncommand  + option + M 抽取代码为单独的方法**,**或者抽取成**get**方法\n\ncommand + option + L 格式化代码\n\ncommand + D 复制单行\n\noption + shift + up/down上下移动代码\n\ncommand + \\  热重载**(hot reload)**\n\ncontrol+ R 运行项目\n\ncommand+ delete 删除行\n\n**Shift** 双击 ****万能搜索\n\nstless 快速创建一个**StatelessWidget**\n\nstful 快速创建一个**StatefulWidget**\n","source":"_posts/AndroidStudio操作.md","raw":"---\ntitle: AndroidStudio操作\ndate: 2023-01-11 12:09:05\ntags: 工具\n---\n\n# Android studio操作\n\ncommand + shift + R 当前文件替换\n\ncommand + shift + F 全局查找\n\ncommand + shift + R 全局替换\n\ncommand + O 全局搜索类**/**文件**/**关键字**/(**包括系统类**,**自定义类**)**\n\ncommand + option + O 全局搜索方法\n\noption + enter 将**StatelessWidget**转 **StatefulWidget**   快速修复  ****快速生成构造方法\n\ncommand  + option + W 抽取代码为单独的**Widget**\n\ncommand  + option + M 抽取代码为单独的方法**,**或者抽取成**get**方法\n\ncommand + option + L 格式化代码\n\ncommand + D 复制单行\n\noption + shift + up/down上下移动代码\n\ncommand + \\  热重载**(hot reload)**\n\ncontrol+ R 运行项目\n\ncommand+ delete 删除行\n\n**Shift** 双击 ****万能搜索\n\nstless 快速创建一个**StatelessWidget**\n\nstful 快速创建一个**StatefulWidget**\n","slug":"AndroidStudio操作","published":1,"updated":"2023-02-21T09:35:15.101Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iul80001bkh0cpwn0pp0","content":"<h1 id=\"Android-studio操作\"><a href=\"#Android-studio操作\" class=\"headerlink\" title=\"Android studio操作\"></a>Android studio操作</h1><p>command + shift + R 当前文件替换</p>\n<p>command + shift + F 全局查找</p>\n<p>command + shift + R 全局替换</p>\n<p>command + O 全局搜索类**&#x2F;<strong>文件</strong>&#x2F;<strong>关键字</strong>&#x2F;(<strong>包括系统类</strong>,<strong>自定义类</strong>)**</p>\n<p>command + option + O 全局搜索方法</p>\n<p>option + enter 将<strong>StatelessWidget</strong>转 <strong>StatefulWidget</strong>   快速修复  ****快速生成构造方法</p>\n<p>command  + option + W 抽取代码为单独的<strong>Widget</strong></p>\n<p>command  + option + M 抽取代码为单独的方法**,<strong>或者抽取成</strong>get**方法</p>\n<p>command + option + L 格式化代码</p>\n<p>command + D 复制单行</p>\n<p>option + shift + up&#x2F;down上下移动代码</p>\n<p>command + \\  热重载**(hot reload)**</p>\n<p>control+ R 运行项目</p>\n<p>command+ delete 删除行</p>\n<p><strong>Shift</strong> 双击 ****万能搜索</p>\n<p>stless 快速创建一个<strong>StatelessWidget</strong></p>\n<p>stful 快速创建一个<strong>StatefulWidget</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android-studio操作\"><a href=\"#Android-studio操作\" class=\"headerlink\" title=\"Android studio操作\"></a>Android studio操作</h1><p>command + shift + R 当前文件替换</p>\n<p>command + shift + F 全局查找</p>\n<p>command + shift + R 全局替换</p>\n<p>command + O 全局搜索类**&#x2F;<strong>文件</strong>&#x2F;<strong>关键字</strong>&#x2F;(<strong>包括系统类</strong>,<strong>自定义类</strong>)**</p>\n<p>command + option + O 全局搜索方法</p>\n<p>option + enter 将<strong>StatelessWidget</strong>转 <strong>StatefulWidget</strong>   快速修复  ****快速生成构造方法</p>\n<p>command  + option + W 抽取代码为单独的<strong>Widget</strong></p>\n<p>command  + option + M 抽取代码为单独的方法**,<strong>或者抽取成</strong>get**方法</p>\n<p>command + option + L 格式化代码</p>\n<p>command + D 复制单行</p>\n<p>option + shift + up&#x2F;down上下移动代码</p>\n<p>command + \\  热重载**(hot reload)**</p>\n<p>control+ R 运行项目</p>\n<p>command+ delete 删除行</p>\n<p><strong>Shift</strong> 双击 ****万能搜索</p>\n<p>stless 快速创建一个<strong>StatelessWidget</strong></p>\n<p>stful 快速创建一个<strong>StatefulWidget</strong></p>\n"},{"title":"SEO技巧","date":"2023-01-11T04:08:10.000Z","_content":"\n# SEO技巧\n\n这篇文章其实是我本人的总结，因为工作中做完了一个官方网站并成功上线，最后组长检查代码看到我的keyword等一系列信息都是空的，把我骂得狗血淋头。一言不合就作总结，总结一些简单但是我们能做的seo小技巧，送给想把网站做到极致的人。\n\n## **SEO要点：**\n\n1. 语义化html标签，用合适的标签嵌套合适的内容，不可过分依赖div，对浏览器更友善就能更容易被抓取。\n2. 重要的内容html代码放在前面，放在左边。搜索引擎爬虫是从左往右，从上到下进行抓取的，利用布局来实现重要的代码在上面\n3. 重要内容要写在html架构里面，蜘蛛不会抓取js的内容，\n4. 尽量减少使用iframe，因为蜘蛛不会抓取iframe的内容。\n5. 为图片img加上alt属性，加了alt就不必加title了，避免搜索引擎认为我们恶意优化。alt能让图片没加载时都能有文字提示。\n6. 需要强调的地方加上title，本页面内跳转a标签内也要加title。\n7. 重要的地方可以保留文字，有些地方必须用图，但是蜘蛛不会爬img，这时应该设置文本，再用缩进隐藏的方法去掉文字，例如logo的优化就是这样做的。注意隐藏不能用display：none，蜘蛛不会检索display：none的内容，应用这个方法的标签一般是logo，标题等重要信息\n8. 尽量做到js、css、html的分离，不要在html中写样式代码。\n9. 注释的东西能去掉应该去掉，对搜索引擎更加友好\n10. css放在头部，js放在尾部，尽量使用外链或者工具对css和js进行压缩\n11. 减少http的请求，使页面更快加载。\n12. 使用本地缓存更快地访问网站，使用cdn网络，加快用户访问速度。\n13. 使用G-ZIP压缩，浏览速度更快，搜索引擎抓取信息量更大\n\n## **关键一点是头部的title，description，keyword的设置。**\n\n1. title设置不宜过长，要简短，网站的名字与相关的小内容，一般为10-20个字。不能重复\n2. keywords设置10个关键词，没个词不能太长，简短且符合你网站的特点，不能重复\n3. description，50个字内描述你的网站\n\n**description写原创的话，并包含2-3个关键词比较好**\n","source":"_posts/SEO技巧.md","raw":"---\ntitle: SEO技巧\ndate: 2023-01-11 12:08:10\ntags: SEO\n---\n\n# SEO技巧\n\n这篇文章其实是我本人的总结，因为工作中做完了一个官方网站并成功上线，最后组长检查代码看到我的keyword等一系列信息都是空的，把我骂得狗血淋头。一言不合就作总结，总结一些简单但是我们能做的seo小技巧，送给想把网站做到极致的人。\n\n## **SEO要点：**\n\n1. 语义化html标签，用合适的标签嵌套合适的内容，不可过分依赖div，对浏览器更友善就能更容易被抓取。\n2. 重要的内容html代码放在前面，放在左边。搜索引擎爬虫是从左往右，从上到下进行抓取的，利用布局来实现重要的代码在上面\n3. 重要内容要写在html架构里面，蜘蛛不会抓取js的内容，\n4. 尽量减少使用iframe，因为蜘蛛不会抓取iframe的内容。\n5. 为图片img加上alt属性，加了alt就不必加title了，避免搜索引擎认为我们恶意优化。alt能让图片没加载时都能有文字提示。\n6. 需要强调的地方加上title，本页面内跳转a标签内也要加title。\n7. 重要的地方可以保留文字，有些地方必须用图，但是蜘蛛不会爬img，这时应该设置文本，再用缩进隐藏的方法去掉文字，例如logo的优化就是这样做的。注意隐藏不能用display：none，蜘蛛不会检索display：none的内容，应用这个方法的标签一般是logo，标题等重要信息\n8. 尽量做到js、css、html的分离，不要在html中写样式代码。\n9. 注释的东西能去掉应该去掉，对搜索引擎更加友好\n10. css放在头部，js放在尾部，尽量使用外链或者工具对css和js进行压缩\n11. 减少http的请求，使页面更快加载。\n12. 使用本地缓存更快地访问网站，使用cdn网络，加快用户访问速度。\n13. 使用G-ZIP压缩，浏览速度更快，搜索引擎抓取信息量更大\n\n## **关键一点是头部的title，description，keyword的设置。**\n\n1. title设置不宜过长，要简短，网站的名字与相关的小内容，一般为10-20个字。不能重复\n2. keywords设置10个关键词，没个词不能太长，简短且符合你网站的特点，不能重复\n3. description，50个字内描述你的网站\n\n**description写原创的话，并包含2-3个关键词比较好**\n","slug":"SEO技巧","published":1,"updated":"2023-02-21T09:35:15.106Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iulc0003bkh01zo69fu4","content":"<h1 id=\"SEO技巧\"><a href=\"#SEO技巧\" class=\"headerlink\" title=\"SEO技巧\"></a>SEO技巧</h1><p>这篇文章其实是我本人的总结，因为工作中做完了一个官方网站并成功上线，最后组长检查代码看到我的keyword等一系列信息都是空的，把我骂得狗血淋头。一言不合就作总结，总结一些简单但是我们能做的seo小技巧，送给想把网站做到极致的人。</p>\n<h2 id=\"SEO要点：\"><a href=\"#SEO要点：\" class=\"headerlink\" title=\"SEO要点：\"></a><strong>SEO要点：</strong></h2><ol>\n<li>语义化html标签，用合适的标签嵌套合适的内容，不可过分依赖div，对浏览器更友善就能更容易被抓取。</li>\n<li>重要的内容html代码放在前面，放在左边。搜索引擎爬虫是从左往右，从上到下进行抓取的，利用布局来实现重要的代码在上面</li>\n<li>重要内容要写在html架构里面，蜘蛛不会抓取js的内容，</li>\n<li>尽量减少使用iframe，因为蜘蛛不会抓取iframe的内容。</li>\n<li>为图片img加上alt属性，加了alt就不必加title了，避免搜索引擎认为我们恶意优化。alt能让图片没加载时都能有文字提示。</li>\n<li>需要强调的地方加上title，本页面内跳转a标签内也要加title。</li>\n<li>重要的地方可以保留文字，有些地方必须用图，但是蜘蛛不会爬img，这时应该设置文本，再用缩进隐藏的方法去掉文字，例如logo的优化就是这样做的。注意隐藏不能用display：none，蜘蛛不会检索display：none的内容，应用这个方法的标签一般是logo，标题等重要信息</li>\n<li>尽量做到js、css、html的分离，不要在html中写样式代码。</li>\n<li>注释的东西能去掉应该去掉，对搜索引擎更加友好</li>\n<li>css放在头部，js放在尾部，尽量使用外链或者工具对css和js进行压缩</li>\n<li>减少http的请求，使页面更快加载。</li>\n<li>使用本地缓存更快地访问网站，使用cdn网络，加快用户访问速度。</li>\n<li>使用G-ZIP压缩，浏览速度更快，搜索引擎抓取信息量更大</li>\n</ol>\n<h2 id=\"关键一点是头部的title，description，keyword的设置。\"><a href=\"#关键一点是头部的title，description，keyword的设置。\" class=\"headerlink\" title=\"关键一点是头部的title，description，keyword的设置。\"></a><strong>关键一点是头部的title，description，keyword的设置。</strong></h2><ol>\n<li>title设置不宜过长，要简短，网站的名字与相关的小内容，一般为10-20个字。不能重复</li>\n<li>keywords设置10个关键词，没个词不能太长，简短且符合你网站的特点，不能重复</li>\n<li>description，50个字内描述你的网站</li>\n</ol>\n<p><strong>description写原创的话，并包含2-3个关键词比较好</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SEO技巧\"><a href=\"#SEO技巧\" class=\"headerlink\" title=\"SEO技巧\"></a>SEO技巧</h1><p>这篇文章其实是我本人的总结，因为工作中做完了一个官方网站并成功上线，最后组长检查代码看到我的keyword等一系列信息都是空的，把我骂得狗血淋头。一言不合就作总结，总结一些简单但是我们能做的seo小技巧，送给想把网站做到极致的人。</p>\n<h2 id=\"SEO要点：\"><a href=\"#SEO要点：\" class=\"headerlink\" title=\"SEO要点：\"></a><strong>SEO要点：</strong></h2><ol>\n<li>语义化html标签，用合适的标签嵌套合适的内容，不可过分依赖div，对浏览器更友善就能更容易被抓取。</li>\n<li>重要的内容html代码放在前面，放在左边。搜索引擎爬虫是从左往右，从上到下进行抓取的，利用布局来实现重要的代码在上面</li>\n<li>重要内容要写在html架构里面，蜘蛛不会抓取js的内容，</li>\n<li>尽量减少使用iframe，因为蜘蛛不会抓取iframe的内容。</li>\n<li>为图片img加上alt属性，加了alt就不必加title了，避免搜索引擎认为我们恶意优化。alt能让图片没加载时都能有文字提示。</li>\n<li>需要强调的地方加上title，本页面内跳转a标签内也要加title。</li>\n<li>重要的地方可以保留文字，有些地方必须用图，但是蜘蛛不会爬img，这时应该设置文本，再用缩进隐藏的方法去掉文字，例如logo的优化就是这样做的。注意隐藏不能用display：none，蜘蛛不会检索display：none的内容，应用这个方法的标签一般是logo，标题等重要信息</li>\n<li>尽量做到js、css、html的分离，不要在html中写样式代码。</li>\n<li>注释的东西能去掉应该去掉，对搜索引擎更加友好</li>\n<li>css放在头部，js放在尾部，尽量使用外链或者工具对css和js进行压缩</li>\n<li>减少http的请求，使页面更快加载。</li>\n<li>使用本地缓存更快地访问网站，使用cdn网络，加快用户访问速度。</li>\n<li>使用G-ZIP压缩，浏览速度更快，搜索引擎抓取信息量更大</li>\n</ol>\n<h2 id=\"关键一点是头部的title，description，keyword的设置。\"><a href=\"#关键一点是头部的title，description，keyword的设置。\" class=\"headerlink\" title=\"关键一点是头部的title，description，keyword的设置。\"></a><strong>关键一点是头部的title，description，keyword的设置。</strong></h2><ol>\n<li>title设置不宜过长，要简短，网站的名字与相关的小内容，一般为10-20个字。不能重复</li>\n<li>keywords设置10个关键词，没个词不能太长，简短且符合你网站的特点，不能重复</li>\n<li>description，50个字内描述你的网站</li>\n</ol>\n<p><strong>description写原创的话，并包含2-3个关键词比较好</strong></p>\n"},{"title":"Flask-sqlalchemy使用","date":"2023-01-12T07:48:11.000Z","_content":"\n## 查询\n\n```js\n1.  filter()    把过滤器添加到原查询上，返回一个新查询\n\n2.  filter_by()    把等值过滤器添加到原查询上，返回一个新查询\n\n3.  limit    使用指定的值限定原查询返回的结果\n\n4.  offset()    偏移原查询返回的结果，返回一个新查询\n\n5.  order_by()    根据指定条件对原查询结果进行排序，返回一个新查询\n\n6.  group_by()    根据指定条件对原查询结果进行分组，返回一个新查询\n\n7.  all()    以列表形式返回查询的所有结果\n\n8.  first()    返回查询的第一个结果，如果未查到，返回 None\n\n9.  first_or_404()    返回查询的第一个结果，如果未查到，返回 404\n\n10.  get()    返回指定主键对应的行，如不存在，返回 None\n\n11.  get_or_404()    返回指定主键对应的行，如不存在，返回 404\n\n12.  count()    返回查询结果的数量\n\n13.  paginate()    返回一个Paginate对象，它包含指定范围内的结果\n```\n\n```js\n1.  \"\"\"\n\n2.  查询所有用户数据\n\n3.  User.query.all()\n\n5.  查询有多少个用户\n\n6.  User.query.count()\n\n8.  查询第1个用户\n\n9.  User.query.first()\n\n10.  User.query.get(1) # 根据id查询\n\n12.  查询id为4的用户[3种方式]\n\n13.  User.query.get(4)\n\n14.  User.query.filter_by(id=4).all() # 简单查询 使用关键字实参的形式来设置字段名\n\n15.  User.query.filter(User.id == 4).all() # 复杂查询 使用恒等式等其他形式来设置条件\n\n17.  查询名字结尾字符为g的所有用户[开始 / 包含]\n\n18.  User.query.filter(User.name.endswith(\"g\")).all()\n\n19.  User.query.filter(User.name.startswith(\"w\")).all()\n\n20.  User.query.filter(User.name.contains(\"n\")).all()\n\n21.  User.query.filter(User.name.like(\"%n%g\")).all() 模糊查询\n\n23.  查询名字和邮箱都以li开头的所有用户[2种方式]\n\n24.  User.query.filter(User.name.startswith(\"li\"), User.email.startswith(\"li\")).all()\n\n26.  from sqlalchemy import and_\n\n27.  User.query.filter(and_(User.name.startswith(\"li\"), User.email.startswith(\"li\"))).all()\n\n29.  查询age是25 或者 \\`email\\`以\\`itheima.com\\`结尾的所有用户\n\n30.  from sqlalchemy import or_\n\n31.  User.query.filter(or_(User.age == 25, User.email.endswith(\"itheima.com\"))).all()\n\n33.  查询名字不等于wang的所有用户[2种方式]\n\n34.  from sqlalchemy import not_\n\n35.  User.query.filter(not_(User.name == \"wang\")).all()\n\n36.  User.query.filter(User.name != \"wang\").all()\n\n38.  查询id为[1, 3, 5, 7, 9]的用户\n\n39.  User.query.filter(User.id.in_([1, 3, 5, 7, 9])).all()\n\n41.  所有用户先按年龄从小到大, 再按id从大到小排序, 取前5个\n\n42.  User.query.order_by(User.age, User.id.desc()).limit(5).all()\n\n44.  分页查询, 每页3个, 查询第2页的数据\n\n45.  pn = User.query.paginate(2, 3)\n\n46.  pn.items 获取该页的数据 pn.page 获取当前的页码 pn.pages 获取总页数\n```\n","source":"_posts/flask-sqlalchemy使用.md","raw":"---\ntitle: Flask-sqlalchemy使用\ndate: 2023-01-12 15:48:11\ntags: Python\n---\n\n## 查询\n\n```js\n1.  filter()    把过滤器添加到原查询上，返回一个新查询\n\n2.  filter_by()    把等值过滤器添加到原查询上，返回一个新查询\n\n3.  limit    使用指定的值限定原查询返回的结果\n\n4.  offset()    偏移原查询返回的结果，返回一个新查询\n\n5.  order_by()    根据指定条件对原查询结果进行排序，返回一个新查询\n\n6.  group_by()    根据指定条件对原查询结果进行分组，返回一个新查询\n\n7.  all()    以列表形式返回查询的所有结果\n\n8.  first()    返回查询的第一个结果，如果未查到，返回 None\n\n9.  first_or_404()    返回查询的第一个结果，如果未查到，返回 404\n\n10.  get()    返回指定主键对应的行，如不存在，返回 None\n\n11.  get_or_404()    返回指定主键对应的行，如不存在，返回 404\n\n12.  count()    返回查询结果的数量\n\n13.  paginate()    返回一个Paginate对象，它包含指定范围内的结果\n```\n\n```js\n1.  \"\"\"\n\n2.  查询所有用户数据\n\n3.  User.query.all()\n\n5.  查询有多少个用户\n\n6.  User.query.count()\n\n8.  查询第1个用户\n\n9.  User.query.first()\n\n10.  User.query.get(1) # 根据id查询\n\n12.  查询id为4的用户[3种方式]\n\n13.  User.query.get(4)\n\n14.  User.query.filter_by(id=4).all() # 简单查询 使用关键字实参的形式来设置字段名\n\n15.  User.query.filter(User.id == 4).all() # 复杂查询 使用恒等式等其他形式来设置条件\n\n17.  查询名字结尾字符为g的所有用户[开始 / 包含]\n\n18.  User.query.filter(User.name.endswith(\"g\")).all()\n\n19.  User.query.filter(User.name.startswith(\"w\")).all()\n\n20.  User.query.filter(User.name.contains(\"n\")).all()\n\n21.  User.query.filter(User.name.like(\"%n%g\")).all() 模糊查询\n\n23.  查询名字和邮箱都以li开头的所有用户[2种方式]\n\n24.  User.query.filter(User.name.startswith(\"li\"), User.email.startswith(\"li\")).all()\n\n26.  from sqlalchemy import and_\n\n27.  User.query.filter(and_(User.name.startswith(\"li\"), User.email.startswith(\"li\"))).all()\n\n29.  查询age是25 或者 \\`email\\`以\\`itheima.com\\`结尾的所有用户\n\n30.  from sqlalchemy import or_\n\n31.  User.query.filter(or_(User.age == 25, User.email.endswith(\"itheima.com\"))).all()\n\n33.  查询名字不等于wang的所有用户[2种方式]\n\n34.  from sqlalchemy import not_\n\n35.  User.query.filter(not_(User.name == \"wang\")).all()\n\n36.  User.query.filter(User.name != \"wang\").all()\n\n38.  查询id为[1, 3, 5, 7, 9]的用户\n\n39.  User.query.filter(User.id.in_([1, 3, 5, 7, 9])).all()\n\n41.  所有用户先按年龄从小到大, 再按id从大到小排序, 取前5个\n\n42.  User.query.order_by(User.age, User.id.desc()).limit(5).all()\n\n44.  分页查询, 每页3个, 查询第2页的数据\n\n45.  pn = User.query.paginate(2, 3)\n\n46.  pn.items 获取该页的数据 pn.page 获取当前的页码 pn.pages 获取总页数\n```\n","slug":"flask-sqlalchemy使用","published":1,"updated":"2023-02-21T09:35:15.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iulg0006bkh0der4csj4","content":"<h2 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h2><pre><code class=\"js\">1.  filter()    把过滤器添加到原查询上，返回一个新查询\n\n2.  filter_by()    把等值过滤器添加到原查询上，返回一个新查询\n\n3.  limit    使用指定的值限定原查询返回的结果\n\n4.  offset()    偏移原查询返回的结果，返回一个新查询\n\n5.  order_by()    根据指定条件对原查询结果进行排序，返回一个新查询\n\n6.  group_by()    根据指定条件对原查询结果进行分组，返回一个新查询\n\n7.  all()    以列表形式返回查询的所有结果\n\n8.  first()    返回查询的第一个结果，如果未查到，返回 None\n\n9.  first_or_404()    返回查询的第一个结果，如果未查到，返回 404\n\n10.  get()    返回指定主键对应的行，如不存在，返回 None\n\n11.  get_or_404()    返回指定主键对应的行，如不存在，返回 404\n\n12.  count()    返回查询结果的数量\n\n13.  paginate()    返回一个Paginate对象，它包含指定范围内的结果\n</code></pre>\n<pre><code class=\"js\">1.  &quot;&quot;&quot;\n\n2.  查询所有用户数据\n\n3.  User.query.all()\n\n5.  查询有多少个用户\n\n6.  User.query.count()\n\n8.  查询第1个用户\n\n9.  User.query.first()\n\n10.  User.query.get(1) # 根据id查询\n\n12.  查询id为4的用户[3种方式]\n\n13.  User.query.get(4)\n\n14.  User.query.filter_by(id=4).all() # 简单查询 使用关键字实参的形式来设置字段名\n\n15.  User.query.filter(User.id == 4).all() # 复杂查询 使用恒等式等其他形式来设置条件\n\n17.  查询名字结尾字符为g的所有用户[开始 / 包含]\n\n18.  User.query.filter(User.name.endswith(&quot;g&quot;)).all()\n\n19.  User.query.filter(User.name.startswith(&quot;w&quot;)).all()\n\n20.  User.query.filter(User.name.contains(&quot;n&quot;)).all()\n\n21.  User.query.filter(User.name.like(&quot;%n%g&quot;)).all() 模糊查询\n\n23.  查询名字和邮箱都以li开头的所有用户[2种方式]\n\n24.  User.query.filter(User.name.startswith(&quot;li&quot;), User.email.startswith(&quot;li&quot;)).all()\n\n26.  from sqlalchemy import and_\n\n27.  User.query.filter(and_(User.name.startswith(&quot;li&quot;), User.email.startswith(&quot;li&quot;))).all()\n\n29.  查询age是25 或者 \\`email\\`以\\`itheima.com\\`结尾的所有用户\n\n30.  from sqlalchemy import or_\n\n31.  User.query.filter(or_(User.age == 25, User.email.endswith(&quot;itheima.com&quot;))).all()\n\n33.  查询名字不等于wang的所有用户[2种方式]\n\n34.  from sqlalchemy import not_\n\n35.  User.query.filter(not_(User.name == &quot;wang&quot;)).all()\n\n36.  User.query.filter(User.name != &quot;wang&quot;).all()\n\n38.  查询id为[1, 3, 5, 7, 9]的用户\n\n39.  User.query.filter(User.id.in_([1, 3, 5, 7, 9])).all()\n\n41.  所有用户先按年龄从小到大, 再按id从大到小排序, 取前5个\n\n42.  User.query.order_by(User.age, User.id.desc()).limit(5).all()\n\n44.  分页查询, 每页3个, 查询第2页的数据\n\n45.  pn = User.query.paginate(2, 3)\n\n46.  pn.items 获取该页的数据 pn.page 获取当前的页码 pn.pages 获取总页数\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h2><pre><code class=\"js\">1.  filter()    把过滤器添加到原查询上，返回一个新查询\n\n2.  filter_by()    把等值过滤器添加到原查询上，返回一个新查询\n\n3.  limit    使用指定的值限定原查询返回的结果\n\n4.  offset()    偏移原查询返回的结果，返回一个新查询\n\n5.  order_by()    根据指定条件对原查询结果进行排序，返回一个新查询\n\n6.  group_by()    根据指定条件对原查询结果进行分组，返回一个新查询\n\n7.  all()    以列表形式返回查询的所有结果\n\n8.  first()    返回查询的第一个结果，如果未查到，返回 None\n\n9.  first_or_404()    返回查询的第一个结果，如果未查到，返回 404\n\n10.  get()    返回指定主键对应的行，如不存在，返回 None\n\n11.  get_or_404()    返回指定主键对应的行，如不存在，返回 404\n\n12.  count()    返回查询结果的数量\n\n13.  paginate()    返回一个Paginate对象，它包含指定范围内的结果\n</code></pre>\n<pre><code class=\"js\">1.  &quot;&quot;&quot;\n\n2.  查询所有用户数据\n\n3.  User.query.all()\n\n5.  查询有多少个用户\n\n6.  User.query.count()\n\n8.  查询第1个用户\n\n9.  User.query.first()\n\n10.  User.query.get(1) # 根据id查询\n\n12.  查询id为4的用户[3种方式]\n\n13.  User.query.get(4)\n\n14.  User.query.filter_by(id=4).all() # 简单查询 使用关键字实参的形式来设置字段名\n\n15.  User.query.filter(User.id == 4).all() # 复杂查询 使用恒等式等其他形式来设置条件\n\n17.  查询名字结尾字符为g的所有用户[开始 / 包含]\n\n18.  User.query.filter(User.name.endswith(&quot;g&quot;)).all()\n\n19.  User.query.filter(User.name.startswith(&quot;w&quot;)).all()\n\n20.  User.query.filter(User.name.contains(&quot;n&quot;)).all()\n\n21.  User.query.filter(User.name.like(&quot;%n%g&quot;)).all() 模糊查询\n\n23.  查询名字和邮箱都以li开头的所有用户[2种方式]\n\n24.  User.query.filter(User.name.startswith(&quot;li&quot;), User.email.startswith(&quot;li&quot;)).all()\n\n26.  from sqlalchemy import and_\n\n27.  User.query.filter(and_(User.name.startswith(&quot;li&quot;), User.email.startswith(&quot;li&quot;))).all()\n\n29.  查询age是25 或者 \\`email\\`以\\`itheima.com\\`结尾的所有用户\n\n30.  from sqlalchemy import or_\n\n31.  User.query.filter(or_(User.age == 25, User.email.endswith(&quot;itheima.com&quot;))).all()\n\n33.  查询名字不等于wang的所有用户[2种方式]\n\n34.  from sqlalchemy import not_\n\n35.  User.query.filter(not_(User.name == &quot;wang&quot;)).all()\n\n36.  User.query.filter(User.name != &quot;wang&quot;).all()\n\n38.  查询id为[1, 3, 5, 7, 9]的用户\n\n39.  User.query.filter(User.id.in_([1, 3, 5, 7, 9])).all()\n\n41.  所有用户先按年龄从小到大, 再按id从大到小排序, 取前5个\n\n42.  User.query.order_by(User.age, User.id.desc()).limit(5).all()\n\n44.  分页查询, 每页3个, 查询第2页的数据\n\n45.  pn = User.query.paginate(2, 3)\n\n46.  pn.items 获取该页的数据 pn.page 获取当前的页码 pn.pages 获取总页数\n</code></pre>\n"},{"title":"React基础","date":"2018-05-09T09:39:55.000Z","_content":"\n\n<!-- more -->\n\n[react官网](https://reactjs.org/docs/hello-world.html)\n\n## 组件\n\n#### 1. 无状态组件\n\n- 在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。\n- 无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。\n- 无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。\n\n```\nimport React from \"react\";\n\n//创建方式一,相当于es5的函数声明的方式创建\n function NoState (props) {\n     return (\n         <div>this is NoState Component</div>\n     )\n }\n```\n\n```\n//创建方式二,相当于es5的函数表达式的方式创建\nconst NoState = (props) => {\n    return (\n        <div>this is Nostate Component</div>\n    )\n}\n\nexport default NoState\n```\n\n--------------------------------------------------------------------------------\n\n- 无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。\n- 无状态组件没有实例化得过程，因此无法访问组件this中的对象\n- 无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理\n- 无状态组件只能访问传入的props，同样的props会得到同样的渲染结果\n\n当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来\n代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。\n第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同\n\n```\n// helloWorld.jsx\nimport React, {Component} from 'react';\nclass HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.props);\n        console.log(this.props.name);\n    }\n\n    render() {\n        return (\n            <div onClick={this.clickHander}>{ this.props.name } say: Hello World!</div>\n        )\n    }\n}\nexport default HelloWorld;\n```\n\n## 组件之间的交互\n\n#### 父组件与子组件之间的交互\n\n1. 父组件修改子组件，只需要修改传入的props属性\n2. 子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行\n子组件与子组件之间的交互\n3. 通过影响共同的父组件来进行交互\n\n```\nstate = {\n    switch: 0,\n    name: this.props.name1\n}\nclickHander = () => {\n    const {name1, name2} = this.props;\n    if (this.state.switch === 0) {\n        this.setState({\n            switch: 1,\n            name: name2\n        })\n    } else {\n        this.setState({\n            switch: 0,\n            name: name1\n        })\n    }\n};\nrender() {\n    return (\n        <div onClick={this.clickHander}>hello world !{this.state.name}</div>\n    )\n}\n```\n\n先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。\n\nstate = {} // 等同于ES5构造函数中的this.state = {}\n在对象中，我们可以通过this.state的方式来访问state中所存储的属性\nsetState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变\nreact赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了\n而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行\n// 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: 'Jason'})// 然后立即查看它的值console.log(this.state.name) // 仍然为Tom，不会立即改变\n\n### refs\n\nreact组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样\n\n```\n// 当然可能命名会是其他的，大概表达一个意思，不深究哈\n{\n    nodeName: 'div',\n    className: 'hello-world',\n    style: {},\n    parentNodes: 'root',\n    childrenNodes: []\n    ...\n}\n```\n\n而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的\n\n```\nimport React, { Component } from 'react';\nclass HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.refs)\n    } \n    render () {\n        return (\n            <div className=\"container\" onClick={this.clickHander}>\n                <div ref=\"hello\" className=\"hello\">Hello</div>\n                <div ref=\"world\" className=\"world\">World</div>\n            </div>\n        )\n    }\n}\nexport default HelloWorld;\n```\n\n为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替\n我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。\n当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。\n\n```\n// src/helloWorld.jsx\nimport React, { Component } from 'react';class HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.refs)\n    } refCallback = (elem) => {\n        console.log(elem);\n    } render () {\n        return (\n            <div className=\"container\" onClick={this.clickHander}>\n                <div ref=\"hello\" className=\"hello\">Hello</div>\n                <div ref={this.refCallback} className=\"world\">World</div>\n            </div>\n        )\n    }\n}export default HelloWorld;\n```\n\n### 组件生命周期\n\n件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数\n\n##### react组件有三种状态\n\n- Mounted：已经插入真实DOM\n- Updating：正在被重新渲染\n- Unmounted：已移出真实DOM\n-\n\n##### 每个状态的处理函数\n\n- will：函数在进入状态之前调用\n- did：函数在进入状态之后调用\n\n##### 组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\n\n- componentWillMount 在首次渲染完成之前，此时可修改组件的state\n- componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM\n\n##### 组件属性(我们前面提到的props与state)更新的前后时刻\n\n- componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state\n- componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素\n\n###### 组件取消挂载之前(取消之后就没必要提供钩子函数了)\n\n`componentWillUnmount`\n\n###### 两个特殊的处理函数\n\n- `componentWillReceiveProps(object nextProps)`：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变->然后componentWillReceiveProps去判断是否需要重新渲染(`shouldComponentUpdate`)->如果不需要则继续running->如果需要则执行`componentWillUpdate`->渲染DOM树之后执行`componentDidUpdate`->进入running\n- `shouldComponentUpdate(nextProps, nextState)`(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变->判断是否需要重新渲染新的props和state(`shouldComponentUpdate`) -> 根据判断决定执行render过程还是继续·保持running状态\n\n###### 三个统一调用的方法,用于组件初始化，获取默认属性和状态\n\n- getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享\n- getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props\n- render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出\n\n###### 已挂载的方法\n\n- component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候\n\n>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。\n\n![image](http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg)\n\n## PropTypes\n\n```\nimport PropTypes from 'prop-types';\n\nMyComponent.propTypes = {\n  // You can declare that a prop is a specific JS primitive. By default, these\n  // are all optional.\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  // Anything that can be rendered: numbers, strings, elements or an array\n  // (or fragment) containing these types.\n  optionalNode: PropTypes.node,\n\n  // A React element.\n  optionalElement: PropTypes.element,\n\n  // You can also declare that a prop is an instance of a class. This uses\n  // JS's instanceof operator.\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  // You can ensure that your prop is limited to specific values by treating\n  // it as an enum.\n  optionalEnum: PropTypes.oneOf(['News', 'Photos']),\n\n  // An object that could be one of many types\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  // An array of a certain type\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  // An object with property values of a certain type\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  // An object taking on a particular shape\n  optionalObjectWithShape: PropTypes.shape({\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  }),\n\n  // You can chain any of the above with `isRequired` to make sure a warning\n  // is shown if the prop isn't provided.\n  requiredFunc: PropTypes.func.isRequired,\n\n  // A value of any data type\n  requiredAny: PropTypes.any.isRequired,\n\n  // You can also specify a custom validator. It should return an Error\n  // object if the validation fails. Don't `console.warn` or throw, as this\n  // won't work inside `oneOfType`.\n  customProp: function(props, propName, componentName) {\n    if (!/matchme/.test(props[propName])) {\n      return new Error(\n        'Invalid prop `' + propName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  },\n\n  // You can also supply a custom validator to `arrayOf` and `objectOf`.\n  // It should return an Error object if the validation fails. The validator\n  // will be called for each key in the array or object. The first two\n  // arguments of the validator are the array or object itself, and the\n  // current item's key.\n  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {\n    if (!/matchme/.test(propValue[key])) {\n      return new Error(\n        'Invalid prop `' + propFullName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  })\n};\n```\n","source":"_posts/react基础.md","raw":"---\ntitle: React基础\ndate: 2018-05-09 17:39:55\ntags: React\n---\n\n\n<!-- more -->\n\n[react官网](https://reactjs.org/docs/hello-world.html)\n\n## 组件\n\n#### 1. 无状态组件\n\n- 在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。\n- 无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。\n- 无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。\n\n```\nimport React from \"react\";\n\n//创建方式一,相当于es5的函数声明的方式创建\n function NoState (props) {\n     return (\n         <div>this is NoState Component</div>\n     )\n }\n```\n\n```\n//创建方式二,相当于es5的函数表达式的方式创建\nconst NoState = (props) => {\n    return (\n        <div>this is Nostate Component</div>\n    )\n}\n\nexport default NoState\n```\n\n--------------------------------------------------------------------------------\n\n- 无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。\n- 无状态组件没有实例化得过程，因此无法访问组件this中的对象\n- 无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理\n- 无状态组件只能访问传入的props，同样的props会得到同样的渲染结果\n\n当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来\n代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。\n第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同\n\n```\n// helloWorld.jsx\nimport React, {Component} from 'react';\nclass HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.props);\n        console.log(this.props.name);\n    }\n\n    render() {\n        return (\n            <div onClick={this.clickHander}>{ this.props.name } say: Hello World!</div>\n        )\n    }\n}\nexport default HelloWorld;\n```\n\n## 组件之间的交互\n\n#### 父组件与子组件之间的交互\n\n1. 父组件修改子组件，只需要修改传入的props属性\n2. 子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行\n子组件与子组件之间的交互\n3. 通过影响共同的父组件来进行交互\n\n```\nstate = {\n    switch: 0,\n    name: this.props.name1\n}\nclickHander = () => {\n    const {name1, name2} = this.props;\n    if (this.state.switch === 0) {\n        this.setState({\n            switch: 1,\n            name: name2\n        })\n    } else {\n        this.setState({\n            switch: 0,\n            name: name1\n        })\n    }\n};\nrender() {\n    return (\n        <div onClick={this.clickHander}>hello world !{this.state.name}</div>\n    )\n}\n```\n\n先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。\n\nstate = {} // 等同于ES5构造函数中的this.state = {}\n在对象中，我们可以通过this.state的方式来访问state中所存储的属性\nsetState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变\nreact赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了\n而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行\n// 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: 'Jason'})// 然后立即查看它的值console.log(this.state.name) // 仍然为Tom，不会立即改变\n\n### refs\n\nreact组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样\n\n```\n// 当然可能命名会是其他的，大概表达一个意思，不深究哈\n{\n    nodeName: 'div',\n    className: 'hello-world',\n    style: {},\n    parentNodes: 'root',\n    childrenNodes: []\n    ...\n}\n```\n\n而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的\n\n```\nimport React, { Component } from 'react';\nclass HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.refs)\n    } \n    render () {\n        return (\n            <div className=\"container\" onClick={this.clickHander}>\n                <div ref=\"hello\" className=\"hello\">Hello</div>\n                <div ref=\"world\" className=\"world\">World</div>\n            </div>\n        )\n    }\n}\nexport default HelloWorld;\n```\n\n为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替\n我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。\n当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。\n\n```\n// src/helloWorld.jsx\nimport React, { Component } from 'react';class HelloWorld extends Component {\n    clickHander = () => {\n        console.log(this.refs)\n    } refCallback = (elem) => {\n        console.log(elem);\n    } render () {\n        return (\n            <div className=\"container\" onClick={this.clickHander}>\n                <div ref=\"hello\" className=\"hello\">Hello</div>\n                <div ref={this.refCallback} className=\"world\">World</div>\n            </div>\n        )\n    }\n}export default HelloWorld;\n```\n\n### 组件生命周期\n\n件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数\n\n##### react组件有三种状态\n\n- Mounted：已经插入真实DOM\n- Updating：正在被重新渲染\n- Unmounted：已移出真实DOM\n-\n\n##### 每个状态的处理函数\n\n- will：函数在进入状态之前调用\n- did：函数在进入状态之后调用\n\n##### 组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\n\n- componentWillMount 在首次渲染完成之前，此时可修改组件的state\n- componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM\n\n##### 组件属性(我们前面提到的props与state)更新的前后时刻\n\n- componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state\n- componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素\n\n###### 组件取消挂载之前(取消之后就没必要提供钩子函数了)\n\n`componentWillUnmount`\n\n###### 两个特殊的处理函数\n\n- `componentWillReceiveProps(object nextProps)`：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变->然后componentWillReceiveProps去判断是否需要重新渲染(`shouldComponentUpdate`)->如果不需要则继续running->如果需要则执行`componentWillUpdate`->渲染DOM树之后执行`componentDidUpdate`->进入running\n- `shouldComponentUpdate(nextProps, nextState)`(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变->判断是否需要重新渲染新的props和state(`shouldComponentUpdate`) -> 根据判断决定执行render过程还是继续·保持running状态\n\n###### 三个统一调用的方法,用于组件初始化，获取默认属性和状态\n\n- getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享\n- getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props\n- render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出\n\n###### 已挂载的方法\n\n- component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候\n\n>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。\n\n![image](http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg)\n\n## PropTypes\n\n```\nimport PropTypes from 'prop-types';\n\nMyComponent.propTypes = {\n  // You can declare that a prop is a specific JS primitive. By default, these\n  // are all optional.\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  // Anything that can be rendered: numbers, strings, elements or an array\n  // (or fragment) containing these types.\n  optionalNode: PropTypes.node,\n\n  // A React element.\n  optionalElement: PropTypes.element,\n\n  // You can also declare that a prop is an instance of a class. This uses\n  // JS's instanceof operator.\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  // You can ensure that your prop is limited to specific values by treating\n  // it as an enum.\n  optionalEnum: PropTypes.oneOf(['News', 'Photos']),\n\n  // An object that could be one of many types\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  // An array of a certain type\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  // An object with property values of a certain type\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  // An object taking on a particular shape\n  optionalObjectWithShape: PropTypes.shape({\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  }),\n\n  // You can chain any of the above with `isRequired` to make sure a warning\n  // is shown if the prop isn't provided.\n  requiredFunc: PropTypes.func.isRequired,\n\n  // A value of any data type\n  requiredAny: PropTypes.any.isRequired,\n\n  // You can also specify a custom validator. It should return an Error\n  // object if the validation fails. Don't `console.warn` or throw, as this\n  // won't work inside `oneOfType`.\n  customProp: function(props, propName, componentName) {\n    if (!/matchme/.test(props[propName])) {\n      return new Error(\n        'Invalid prop `' + propName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  },\n\n  // You can also supply a custom validator to `arrayOf` and `objectOf`.\n  // It should return an Error object if the validation fails. The validator\n  // will be called for each key in the array or object. The first two\n  // arguments of the validator are the array or object itself, and the\n  // current item's key.\n  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {\n    if (!/matchme/.test(propValue[key])) {\n      return new Error(\n        'Invalid prop `' + propFullName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  })\n};\n```\n","slug":"react基础","published":1,"updated":"2023-02-21T09:35:15.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iulh0008bkh0b3ur3dmd","content":"<span id=\"more\"></span>\n\n<p><a href=\"https://reactjs.org/docs/hello-world.html\">react官网</a></p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><h4 id=\"1-无状态组件\"><a href=\"#1-无状态组件\" class=\"headerlink\" title=\"1. 无状态组件\"></a>1. 无状态组件</h4><ul>\n<li>在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。</li>\n<li>无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。</li>\n<li>无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。</li>\n</ul>\n<pre><code>import React from &quot;react&quot;;\n\n//创建方式一,相当于es5的函数声明的方式创建\n function NoState (props) &#123;\n     return (\n         &lt;div&gt;this is NoState Component&lt;/div&gt;\n     )\n &#125;\n</code></pre>\n<pre><code>//创建方式二,相当于es5的函数表达式的方式创建\nconst NoState = (props) =&gt; &#123;\n    return (\n        &lt;div&gt;this is Nostate Component&lt;/div&gt;\n    )\n&#125;\n\nexport default NoState\n</code></pre>\n<hr>\n<ul>\n<li>无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。</li>\n<li>无状态组件没有实例化得过程，因此无法访问组件this中的对象</li>\n<li>无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理</li>\n<li>无状态组件只能访问传入的props，同样的props会得到同样的渲染结果</li>\n</ul>\n<p>当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来<br>代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。<br>第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同</p>\n<pre><code>// helloWorld.jsx\nimport React, &#123;Component&#125; from &#39;react&#39;;\nclass HelloWorld extends Component &#123;\n    clickHander = () =&gt; &#123;\n        console.log(this.props);\n        console.log(this.props.name);\n    &#125;\n\n    render() &#123;\n        return (\n            &lt;div onClick=&#123;this.clickHander&#125;&gt;&#123; this.props.name &#125; say: Hello World!&lt;/div&gt;\n        )\n    &#125;\n&#125;\nexport default HelloWorld;\n</code></pre>\n<h2 id=\"组件之间的交互\"><a href=\"#组件之间的交互\" class=\"headerlink\" title=\"组件之间的交互\"></a>组件之间的交互</h2><h4 id=\"父组件与子组件之间的交互\"><a href=\"#父组件与子组件之间的交互\" class=\"headerlink\" title=\"父组件与子组件之间的交互\"></a>父组件与子组件之间的交互</h4><ol>\n<li>父组件修改子组件，只需要修改传入的props属性</li>\n<li>子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行<br>子组件与子组件之间的交互</li>\n<li>通过影响共同的父组件来进行交互</li>\n</ol>\n<pre><code>state = &#123;\n    switch: 0,\n    name: this.props.name1\n&#125;\nclickHander = () =&gt; &#123;\n    const &#123;name1, name2&#125; = this.props;\n    if (this.state.switch === 0) &#123;\n        this.setState(&#123;\n            switch: 1,\n            name: name2\n        &#125;)\n    &#125; else &#123;\n        this.setState(&#123;\n            switch: 0,\n            name: name1\n        &#125;)\n    &#125;\n&#125;;\nrender() &#123;\n    return (\n        &lt;div onClick=&#123;this.clickHander&#125;&gt;hello world !&#123;this.state.name&#125;&lt;/div&gt;\n    )\n&#125;\n</code></pre>\n<p>先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。</p>\n<p>state &#x3D; {} &#x2F;&#x2F; 等同于ES5构造函数中的this.state &#x3D; {}<br>在对象中，我们可以通过this.state的方式来访问state中所存储的属性<br>setState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变<br>react赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了<br>而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行<br>&#x2F;&#x2F; 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: ‘Jason’})&#x2F;&#x2F; 然后立即查看它的值console.log(this.state.name) &#x2F;&#x2F; 仍然为Tom，不会立即改变</p>\n<h3 id=\"refs\"><a href=\"#refs\" class=\"headerlink\" title=\"refs\"></a>refs</h3><p>react组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样</p>\n<pre><code>// 当然可能命名会是其他的，大概表达一个意思，不深究哈\n&#123;\n    nodeName: &#39;div&#39;,\n    className: &#39;hello-world&#39;,\n    style: &#123;&#125;,\n    parentNodes: &#39;root&#39;,\n    childrenNodes: []\n    ...\n&#125;\n</code></pre>\n<p>而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的</p>\n<pre><code>import React, &#123; Component &#125; from &#39;react&#39;;\nclass HelloWorld extends Component &#123;\n    clickHander = () =&gt; &#123;\n        console.log(this.refs)\n    &#125; \n    render () &#123;\n        return (\n            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;\n                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;\n                &lt;div ref=&quot;world&quot; className=&quot;world&quot;&gt;World&lt;/div&gt;\n            &lt;/div&gt;\n        )\n    &#125;\n&#125;\nexport default HelloWorld;\n</code></pre>\n<p>为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替<br>我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。<br>当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。</p>\n<pre><code>// src/helloWorld.jsx\nimport React, &#123; Component &#125; from &#39;react&#39;;class HelloWorld extends Component &#123;\n    clickHander = () =&gt; &#123;\n        console.log(this.refs)\n    &#125; refCallback = (elem) =&gt; &#123;\n        console.log(elem);\n    &#125; render () &#123;\n        return (\n            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;\n                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;\n                &lt;div ref=&#123;this.refCallback&#125; className=&quot;world&quot;&gt;World&lt;/div&gt;\n            &lt;/div&gt;\n        )\n    &#125;\n&#125;export default HelloWorld;\n</code></pre>\n<h3 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h3><p>件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数</p>\n<h5 id=\"react组件有三种状态\"><a href=\"#react组件有三种状态\" class=\"headerlink\" title=\"react组件有三种状态\"></a>react组件有三种状态</h5><ul>\n<li>Mounted：已经插入真实DOM</li>\n<li>Updating：正在被重新渲染</li>\n<li>Unmounted：已移出真实DOM</li>\n<li></li>\n</ul>\n<h5 id=\"每个状态的处理函数\"><a href=\"#每个状态的处理函数\" class=\"headerlink\" title=\"每个状态的处理函数\"></a>每个状态的处理函数</h5><ul>\n<li>will：函数在进入状态之前调用</li>\n<li>did：函数在进入状态之后调用</li>\n</ul>\n<h5 id=\"组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\"><a href=\"#组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\" class=\"headerlink\" title=\"组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\"></a>组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中</h5><ul>\n<li>componentWillMount 在首次渲染完成之前，此时可修改组件的state</li>\n<li>componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM</li>\n</ul>\n<h5 id=\"组件属性-我们前面提到的props与state-更新的前后时刻\"><a href=\"#组件属性-我们前面提到的props与state-更新的前后时刻\" class=\"headerlink\" title=\"组件属性(我们前面提到的props与state)更新的前后时刻\"></a>组件属性(我们前面提到的props与state)更新的前后时刻</h5><ul>\n<li>componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state</li>\n<li>componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素</li>\n</ul>\n<h6 id=\"组件取消挂载之前-取消之后就没必要提供钩子函数了\"><a href=\"#组件取消挂载之前-取消之后就没必要提供钩子函数了\" class=\"headerlink\" title=\"组件取消挂载之前(取消之后就没必要提供钩子函数了)\"></a>组件取消挂载之前(取消之后就没必要提供钩子函数了)</h6><p><code>componentWillUnmount</code></p>\n<h6 id=\"两个特殊的处理函数\"><a href=\"#两个特殊的处理函数\" class=\"headerlink\" title=\"两个特殊的处理函数\"></a>两个特殊的处理函数</h6><ul>\n<li><code>componentWillReceiveProps(object nextProps)</code>：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变-&gt;然后componentWillReceiveProps去判断是否需要重新渲染(<code>shouldComponentUpdate</code>)-&gt;如果不需要则继续running-&gt;如果需要则执行<code>componentWillUpdate</code>-&gt;渲染DOM树之后执行<code>componentDidUpdate</code>-&gt;进入running</li>\n<li><code>shouldComponentUpdate(nextProps, nextState)</code>(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变-&gt;判断是否需要重新渲染新的props和state(<code>shouldComponentUpdate</code>) -&gt; 根据判断决定执行render过程还是继续·保持running状态</li>\n</ul>\n<h6 id=\"三个统一调用的方法-用于组件初始化，获取默认属性和状态\"><a href=\"#三个统一调用的方法-用于组件初始化，获取默认属性和状态\" class=\"headerlink\" title=\"三个统一调用的方法,用于组件初始化，获取默认属性和状态\"></a>三个统一调用的方法,用于组件初始化，获取默认属性和状态</h6><ul>\n<li>getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享</li>\n<li>getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props</li>\n<li>render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出</li>\n</ul>\n<h6 id=\"已挂载的方法\"><a href=\"#已挂载的方法\" class=\"headerlink\" title=\"已挂载的方法\"></a>已挂载的方法</h6><ul>\n<li>component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候</li>\n</ul>\n<blockquote>\n<p>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。</p>\n</blockquote>\n<p><img src=\"http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg\" alt=\"image\"></p>\n<h2 id=\"PropTypes\"><a href=\"#PropTypes\" class=\"headerlink\" title=\"PropTypes\"></a>PropTypes</h2><pre><code>import PropTypes from &#39;prop-types&#39;;\n\nMyComponent.propTypes = &#123;\n  // You can declare that a prop is a specific JS primitive. By default, these\n  // are all optional.\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  // Anything that can be rendered: numbers, strings, elements or an array\n  // (or fragment) containing these types.\n  optionalNode: PropTypes.node,\n\n  // A React element.\n  optionalElement: PropTypes.element,\n\n  // You can also declare that a prop is an instance of a class. This uses\n  // JS&#39;s instanceof operator.\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  // You can ensure that your prop is limited to specific values by treating\n  // it as an enum.\n  optionalEnum: PropTypes.oneOf([&#39;News&#39;, &#39;Photos&#39;]),\n\n  // An object that could be one of many types\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  // An array of a certain type\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  // An object with property values of a certain type\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  // An object taking on a particular shape\n  optionalObjectWithShape: PropTypes.shape(&#123;\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  &#125;),\n\n  // You can chain any of the above with `isRequired` to make sure a warning\n  // is shown if the prop isn&#39;t provided.\n  requiredFunc: PropTypes.func.isRequired,\n\n  // A value of any data type\n  requiredAny: PropTypes.any.isRequired,\n\n  // You can also specify a custom validator. It should return an Error\n  // object if the validation fails. Don&#39;t `console.warn` or throw, as this\n  // won&#39;t work inside `oneOfType`.\n  customProp: function(props, propName, componentName) &#123;\n    if (!/matchme/.test(props[propName])) &#123;\n      return new Error(\n        &#39;Invalid prop `&#39; + propName + &#39;` supplied to&#39; +\n        &#39; `&#39; + componentName + &#39;`. Validation failed.&#39;\n      );\n    &#125;\n  &#125;,\n\n  // You can also supply a custom validator to `arrayOf` and `objectOf`.\n  // It should return an Error object if the validation fails. The validator\n  // will be called for each key in the array or object. The first two\n  // arguments of the validator are the array or object itself, and the\n  // current item&#39;s key.\n  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;\n    if (!/matchme/.test(propValue[key])) &#123;\n      return new Error(\n        &#39;Invalid prop `&#39; + propFullName + &#39;` supplied to&#39; +\n        &#39; `&#39; + componentName + &#39;`. Validation failed.&#39;\n      );\n    &#125;\n  &#125;)\n&#125;;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://reactjs.org/docs/hello-world.html\">react官网</a></p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><h4 id=\"1-无状态组件\"><a href=\"#1-无状态组件\" class=\"headerlink\" title=\"1. 无状态组件\"></a>1. 无状态组件</h4><ul>\n<li>在React中，组件的名字必须用大写字母开头，而包含该组件定义的文件名也应该是大写字母(便于区分，也可以不是)。</li>\n<li>无状态组件是纯展示组件，仅仅只是用于数据的展示，只根据传入的props来进行展示，不涉及到state状态处理，通过函数式的方式来创建一个无状态函数式组件(大多数组件都是无状态组件，通过简单的组合可以构建成其他的组件，最后合并成一个大的应用)。</li>\n<li>无状态函数式组件是一个只带有render方法的组件，通过函数形式或者箭头函数形式创建，该组件无state状态。</li>\n</ul>\n<pre><code>import React from &quot;react&quot;;\n\n//创建方式一,相当于es5的函数声明的方式创建\n function NoState (props) &#123;\n     return (\n         &lt;div&gt;this is NoState Component&lt;/div&gt;\n     )\n &#125;\n</code></pre>\n<pre><code>//创建方式二,相当于es5的函数表达式的方式创建\nconst NoState = (props) =&gt; &#123;\n    return (\n        &lt;div&gt;this is Nostate Component&lt;/div&gt;\n    )\n&#125;\n\nexport default NoState\n</code></pre>\n<hr>\n<ul>\n<li>无状态函数式组件没有组件实例化的过程，成为一个render方法的函数来执行，减少分配的内存，使整体渲染性能得到提高，因此展示数据的组件优先选择这种方式。</li>\n<li>无状态组件没有实例化得过程，因此无法访问组件this中的对象</li>\n<li>无状态组件不需要组件生命周期管理和状态管理，底层在实现这种形式的组件的时候不会实现组件的生命周期方法，所以无状态组件不能参与组件生命周期管理</li>\n<li>无状态组件只能访问传入的props，同样的props会得到同样的渲染结果</li>\n</ul>\n<p>当我们的组件开始有逻辑处理，之前的那种方式胜任不了时索要采取的一种形式，通过继承react的Component对象而来<br>代码的render方法，则是Component中，专门提供的用来处理jsx模板的方法。<br>第一种方式不同的是，我们接收传入进来的参数，使用的是this.props，第一种方式将props放置于函数参数中，而这种方式则是将props挂载与实例对象上，因此会有所不同</p>\n<pre><code>// helloWorld.jsx\nimport React, &#123;Component&#125; from &#39;react&#39;;\nclass HelloWorld extends Component &#123;\n    clickHander = () =&gt; &#123;\n        console.log(this.props);\n        console.log(this.props.name);\n    &#125;\n\n    render() &#123;\n        return (\n            &lt;div onClick=&#123;this.clickHander&#125;&gt;&#123; this.props.name &#125; say: Hello World!&lt;/div&gt;\n        )\n    &#125;\n&#125;\nexport default HelloWorld;\n</code></pre>\n<h2 id=\"组件之间的交互\"><a href=\"#组件之间的交互\" class=\"headerlink\" title=\"组件之间的交互\"></a>组件之间的交互</h2><h4 id=\"父组件与子组件之间的交互\"><a href=\"#父组件与子组件之间的交互\" class=\"headerlink\" title=\"父组件与子组件之间的交互\"></a>父组件与子组件之间的交互</h4><ol>\n<li>父组件修改子组件，只需要修改传入的props属性</li>\n<li>子组件修改父组件，需要父组件向子组件传递一个函数，该函数在父组件中定义，在子组件中触发执行<br>子组件与子组件之间的交互</li>\n<li>通过影响共同的父组件来进行交互</li>\n</ol>\n<pre><code>state = &#123;\n    switch: 0,\n    name: this.props.name1\n&#125;\nclickHander = () =&gt; &#123;\n    const &#123;name1, name2&#125; = this.props;\n    if (this.state.switch === 0) &#123;\n        this.setState(&#123;\n            switch: 1,\n            name: name2\n        &#125;)\n    &#125; else &#123;\n        this.setState(&#123;\n            switch: 0,\n            name: name1\n        &#125;)\n    &#125;\n&#125;;\nrender() &#123;\n    return (\n        &lt;div onClick=&#123;this.clickHander&#125;&gt;hello world !&#123;this.state.name&#125;&lt;/div&gt;\n    )\n&#125;\n</code></pre>\n<p>先来说说state相关的基础知识。首先了解ES6 class语法的同学都应该知道，当我们通过这种方式来写的时候，其实是将state写入了构造函数之中。</p>\n<p>state &#x3D; {} &#x2F;&#x2F; 等同于ES5构造函数中的this.state &#x3D; {}<br>在对象中，我们可以通过this.state的方式来访问state中所存储的属性<br>setState接收一个对象，它的运行结果类似于执行一次assign方法。会修改传入的属性，而其他的属性则保持不变<br>react赋予state的特性，则是当state被修改时，会引起组件的一次重新渲染。即render方法会重新执行一次。也正是由于这个特性，因此当我们想要改变界面上的元素内容时，常常只需要改变state中的值就行了<br>而setState也有一个非常重要的特性，那就是，该方法是异步的。它并不会立即执行，而会在下一轮事件循环中执行<br>&#x2F;&#x2F; 假设state.name的初始值为Tom，我们改变它的值this.setState({    name: ‘Jason’})&#x2F;&#x2F; 然后立即查看它的值console.log(this.state.name) &#x2F;&#x2F; 仍然为Tom，不会立即改变</p>\n<h3 id=\"refs\"><a href=\"#refs\" class=\"headerlink\" title=\"refs\"></a>refs</h3><p>react组件其实是虚拟DOM，因此通常我们需要通过特殊的方式才能拿到真正的DOM元素。大概说一说虚拟DOM是个什么形式存在的，它其实就是通过js对象的方式将DOM元素相关的都存储其实，比如一个div元素可能会是这样</p>\n<pre><code>// 当然可能命名会是其他的，大概表达一个意思，不深究哈\n&#123;\n    nodeName: &#39;div&#39;,\n    className: &#39;hello-world&#39;,\n    style: &#123;&#125;,\n    parentNodes: &#39;root&#39;,\n    childrenNodes: []\n    ...\n&#125;\n</code></pre>\n<p>而我们想要拿到真实的DOM元素，react中提供了一种叫做ref的属性来实现这个目的</p>\n<pre><code>import React, &#123; Component &#125; from &#39;react&#39;;\nclass HelloWorld extends Component &#123;\n    clickHander = () =&gt; &#123;\n        console.log(this.refs)\n    &#125; \n    render () &#123;\n        return (\n            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;\n                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;\n                &lt;div ref=&quot;world&quot; className=&quot;world&quot;&gt;World&lt;/div&gt;\n            &lt;/div&gt;\n        )\n    &#125;\n&#125;\nexport default HelloWorld;\n</code></pre>\n<p>为了区分ES6语法中的class关键字，当我们在jsx中给元素添加class时，需要使用className来代替<br>我们在jsx中，可以给元素添加ref属性，而这些拥有ref属性的元素，会统一放在组件对象的refs中，因此，当我们想要访问对应的真实DOM时，则通过this.refs来访问即可。<br>当然，ref的值不仅仅可以为一个名字，同时还可以为一个回调函数，这个函数会在render渲染时执行，也就是说，每当render函数执行一次，ref的回调函数也会执行一次。</p>\n<pre><code>// src/helloWorld.jsx\nimport React, &#123; Component &#125; from &#39;react&#39;;class HelloWorld extends Component &#123;\n    clickHander = () =&gt; &#123;\n        console.log(this.refs)\n    &#125; refCallback = (elem) =&gt; &#123;\n        console.log(elem);\n    &#125; render () &#123;\n        return (\n            &lt;div className=&quot;container&quot; onClick=&#123;this.clickHander&#125;&gt;\n                &lt;div ref=&quot;hello&quot; className=&quot;hello&quot;&gt;Hello&lt;/div&gt;\n                &lt;div ref=&#123;this.refCallback&#125; className=&quot;world&quot;&gt;World&lt;/div&gt;\n            &lt;/div&gt;\n        )\n    &#125;\n&#125;export default HelloWorld;\n</code></pre>\n<h3 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h3><p>件的生命周期，指的就是一个组件，从创建到销毁的这样一个过程，react为组件的生命周期提供了很多的钩子函数</p>\n<h5 id=\"react组件有三种状态\"><a href=\"#react组件有三种状态\" class=\"headerlink\" title=\"react组件有三种状态\"></a>react组件有三种状态</h5><ul>\n<li>Mounted：已经插入真实DOM</li>\n<li>Updating：正在被重新渲染</li>\n<li>Unmounted：已移出真实DOM</li>\n<li></li>\n</ul>\n<h5 id=\"每个状态的处理函数\"><a href=\"#每个状态的处理函数\" class=\"headerlink\" title=\"每个状态的处理函数\"></a>每个状态的处理函数</h5><ul>\n<li>will：函数在进入状态之前调用</li>\n<li>did：函数在进入状态之后调用</li>\n</ul>\n<h5 id=\"组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\"><a href=\"#组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\" class=\"headerlink\" title=\"组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中\"></a>组件第一次渲染完成的前后时刻，所谓的渲染完成，即组件已经被渲染成为真实DOM并插入到了html之中</h5><ul>\n<li>componentWillMount 在首次渲染完成之前，此时可修改组件的state</li>\n<li>componentDidMount 真实DOM渲染完成之后，该方法可通过this.getDOMNode()访问到真实的DOM元素，可以使用其他的类库来操作这个DOM</li>\n</ul>\n<h5 id=\"组件属性-我们前面提到的props与state-更新的前后时刻\"><a href=\"#组件属性-我们前面提到的props与state-更新的前后时刻\" class=\"headerlink\" title=\"组件属性(我们前面提到的props与state)更新的前后时刻\"></a>组件属性(我们前面提到的props与state)更新的前后时刻</h5><ul>\n<li>componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用，此时不允许更新props和state</li>\n<li>componentDidUpdate 组件完成更新之后调用，此时可访问新的DOM元素</li>\n</ul>\n<h6 id=\"组件取消挂载之前-取消之后就没必要提供钩子函数了\"><a href=\"#组件取消挂载之前-取消之后就没必要提供钩子函数了\" class=\"headerlink\" title=\"组件取消挂载之前(取消之后就没必要提供钩子函数了)\"></a>组件取消挂载之前(取消之后就没必要提供钩子函数了)</h6><p><code>componentWillUnmount</code></p>\n<h6 id=\"两个特殊的处理函数\"><a href=\"#两个特殊的处理函数\" class=\"headerlink\" title=\"两个特殊的处理函数\"></a>两个特殊的处理函数</h6><ul>\n<li><code>componentWillReceiveProps(object nextProps)</code>：组件接收到新的props时，在重新render之前调用,此时可以更改props和state。首先props发生改变-&gt;然后componentWillReceiveProps去判断是否需要重新渲染(<code>shouldComponentUpdate</code>)-&gt;如果不需要则继续running-&gt;如果需要则执行<code>componentWillUpdate</code>-&gt;渲染DOM树之后执行<code>componentDidUpdate</code>-&gt;进入running</li>\n<li><code>shouldComponentUpdate(nextProps, nextState)</code>(更新发生前立即被调用) 接收到一个新的state或者props时，在重新render之前调用，组件判断是否重新render前调用。首先state发生改变-&gt;判断是否需要重新渲染新的props和state(<code>shouldComponentUpdate</code>) -&gt; 根据判断决定执行render过程还是继续·保持running状态</li>\n</ul>\n<h6 id=\"三个统一调用的方法-用于组件初始化，获取默认属性和状态\"><a href=\"#三个统一调用的方法-用于组件初始化，获取默认属性和状态\" class=\"headerlink\" title=\"三个统一调用的方法,用于组件初始化，获取默认属性和状态\"></a>三个统一调用的方法,用于组件初始化，获取默认属性和状态</h6><ul>\n<li>getDefaultProps：作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享</li>\n<li>getInitialState：作用于组件的实例，在实例创建时只调用一次，，用于初始化没个实例的state，可访问this.props</li>\n<li>render：必选的方法，创建vistual DOM （1. 只能通过this.props和this.state访问数据 2. 可以返回null、false或任何React组件 3. 只能出现一个顶级组件（不能返回数组）4.不能改变组件的状态 5. 不能修改DOM的输出</li>\n</ul>\n<h6 id=\"已挂载的方法\"><a href=\"#已挂载的方法\" class=\"headerlink\" title=\"已挂载的方法\"></a>已挂载的方法</h6><ul>\n<li>component.forceUpdate() 可以在任何已经挂载的组件上使用，当你知道某些深处的组件状态未通过this.setState而改变了的时候</li>\n</ul>\n<blockquote>\n<p>componentDidMount，组件第一次渲染完成之后调用的componentDidMount，既然是组件第一次渲染完成之后才会调用，也就是说，该函数在react组件的生命周期中，只会调用一次。而渲染完成，则表示组件已经被渲染成为真实DOM插入了html中。所以这时候就可以通过ref获取真实元素。在实际开发中，常常需要通过ajax获取数据，而数据请求的这个行为，则最适合放在componentDidMount中来执行。通常会在首次渲染改变组件状态(state)的行为，或者称之为有副作用的行为，都建议放在componentDidMount中来执行。主要是因为state的改动会引发组件的重新渲染。</p>\n</blockquote>\n<p><img src=\"http://images2017.cnblogs.com/blog/1106982/201708/1106982-20170811224737742-1564011484.jpg\" alt=\"image\"></p>\n<h2 id=\"PropTypes\"><a href=\"#PropTypes\" class=\"headerlink\" title=\"PropTypes\"></a>PropTypes</h2><pre><code>import PropTypes from &#39;prop-types&#39;;\n\nMyComponent.propTypes = &#123;\n  // You can declare that a prop is a specific JS primitive. By default, these\n  // are all optional.\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  // Anything that can be rendered: numbers, strings, elements or an array\n  // (or fragment) containing these types.\n  optionalNode: PropTypes.node,\n\n  // A React element.\n  optionalElement: PropTypes.element,\n\n  // You can also declare that a prop is an instance of a class. This uses\n  // JS&#39;s instanceof operator.\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  // You can ensure that your prop is limited to specific values by treating\n  // it as an enum.\n  optionalEnum: PropTypes.oneOf([&#39;News&#39;, &#39;Photos&#39;]),\n\n  // An object that could be one of many types\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  // An array of a certain type\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  // An object with property values of a certain type\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  // An object taking on a particular shape\n  optionalObjectWithShape: PropTypes.shape(&#123;\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  &#125;),\n\n  // You can chain any of the above with `isRequired` to make sure a warning\n  // is shown if the prop isn&#39;t provided.\n  requiredFunc: PropTypes.func.isRequired,\n\n  // A value of any data type\n  requiredAny: PropTypes.any.isRequired,\n\n  // You can also specify a custom validator. It should return an Error\n  // object if the validation fails. Don&#39;t `console.warn` or throw, as this\n  // won&#39;t work inside `oneOfType`.\n  customProp: function(props, propName, componentName) &#123;\n    if (!/matchme/.test(props[propName])) &#123;\n      return new Error(\n        &#39;Invalid prop `&#39; + propName + &#39;` supplied to&#39; +\n        &#39; `&#39; + componentName + &#39;`. Validation failed.&#39;\n      );\n    &#125;\n  &#125;,\n\n  // You can also supply a custom validator to `arrayOf` and `objectOf`.\n  // It should return an Error object if the validation fails. The validator\n  // will be called for each key in the array or object. The first two\n  // arguments of the validator are the array or object itself, and the\n  // current item&#39;s key.\n  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;\n    if (!/matchme/.test(propValue[key])) &#123;\n      return new Error(\n        &#39;Invalid prop `&#39; + propFullName + &#39;` supplied to&#39; +\n        &#39; `&#39; + componentName + &#39;`. Validation failed.&#39;\n      );\n    &#125;\n  &#125;)\n&#125;;\n</code></pre>"},{"title":"Git常用命令的使用","date":"2023-01-11T04:09:38.000Z","_content":"\n### git名词\n\n- workspace :工作区\n- Index/Stage : 暂存区\n- Repository : 仓库区(或本地仓库)\n- Remote :远程仓库区\n\n### 常用操作分部解析\n\n- 在任何目录创建新的git仓库,执行 git init**,** .git文件就是本地的一个仓库\n- git status 查看修改状态\n- git add ,是将文件放入了暂存区,可以使用git checkout \"文件名\" 将文件从暂存区重新拿到工作区\n- git commit ,是将文件从暂存区放入到本地.git仓库\n- git status, 查看文件的状态,在暂存区还是在本地仓库,还是已经在本地仓库,或者已经提交(通常这些vscode工具一目了然)\n- git pull ,拉取的默认是你自己的分支,详细:git pull origin dev, git pull origin master 拉去远程master分支\n\n### git 配置\n\n```\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n### 常用流程\n\n- git add .\n- git commit -m ' '\n- git pull\n- git push\n\n### 常用git命令行快捷方式\n\n- gaa ...... git add .\n- gcam '' ...... git commit -m ''\n- gl ....... git pull\n- gp ....... git push\n\n执行cat ~/.oh-my-zsh/plugins/git/git.plugin.zsh 查看更多简写\n\n### 常用命令\n\n- git log\n- git reflog(涉及到的所有操作步骤)\n- git reset --hard HEAD\n- git checkout file 恢复暂存区的文件到工作区\n- git checkout branch 切换分支\n- git stash\n- git stash pop\n- git branch -r 查看远程分支\n- git branch -a 查看所有分支\n- git remote 列出所有的远程主机\n- git pull --all 拉取远程所有的分支\n- git commit --amend -message=\"”(修改最近的一次提交注释)\n- `git checkout (branchname)` 切换分支命令\n- `git branch (branchname)` 创建分支命令\n- `git branch -d (branchname)` 删除分支命令\n- git push origin --delete Chapater6 删除远程分支命令\n","source":"_posts/Git/git常用命令的使用.md","raw":"---\ntitle: Git常用命令的使用\ndate: 2023-01-11 12:09:38\ntags: Git\n---\n\n### git名词\n\n- workspace :工作区\n- Index/Stage : 暂存区\n- Repository : 仓库区(或本地仓库)\n- Remote :远程仓库区\n\n### 常用操作分部解析\n\n- 在任何目录创建新的git仓库,执行 git init**,** .git文件就是本地的一个仓库\n- git status 查看修改状态\n- git add ,是将文件放入了暂存区,可以使用git checkout \"文件名\" 将文件从暂存区重新拿到工作区\n- git commit ,是将文件从暂存区放入到本地.git仓库\n- git status, 查看文件的状态,在暂存区还是在本地仓库,还是已经在本地仓库,或者已经提交(通常这些vscode工具一目了然)\n- git pull ,拉取的默认是你自己的分支,详细:git pull origin dev, git pull origin master 拉去远程master分支\n\n### git 配置\n\n```\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n### 常用流程\n\n- git add .\n- git commit -m ' '\n- git pull\n- git push\n\n### 常用git命令行快捷方式\n\n- gaa ...... git add .\n- gcam '' ...... git commit -m ''\n- gl ....... git pull\n- gp ....... git push\n\n执行cat ~/.oh-my-zsh/plugins/git/git.plugin.zsh 查看更多简写\n\n### 常用命令\n\n- git log\n- git reflog(涉及到的所有操作步骤)\n- git reset --hard HEAD\n- git checkout file 恢复暂存区的文件到工作区\n- git checkout branch 切换分支\n- git stash\n- git stash pop\n- git branch -r 查看远程分支\n- git branch -a 查看所有分支\n- git remote 列出所有的远程主机\n- git pull --all 拉取远程所有的分支\n- git commit --amend -message=\"”(修改最近的一次提交注释)\n- `git checkout (branchname)` 切换分支命令\n- `git branch (branchname)` 创建分支命令\n- `git branch -d (branchname)` 删除分支命令\n- git push origin --delete Chapater6 删除远程分支命令\n","slug":"Git/git常用命令的使用","published":1,"updated":"2023-02-21T09:35:15.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iuli0009bkh0d2obgfzc","content":"<h3 id=\"git名词\"><a href=\"#git名词\" class=\"headerlink\" title=\"git名词\"></a>git名词</h3><ul>\n<li>workspace :工作区</li>\n<li>Index&#x2F;Stage : 暂存区</li>\n<li>Repository : 仓库区(或本地仓库)</li>\n<li>Remote :远程仓库区</li>\n</ul>\n<h3 id=\"常用操作分部解析\"><a href=\"#常用操作分部解析\" class=\"headerlink\" title=\"常用操作分部解析\"></a>常用操作分部解析</h3><ul>\n<li>在任何目录创建新的git仓库,执行 git init**,** .git文件就是本地的一个仓库</li>\n<li>git status 查看修改状态</li>\n<li>git add ,是将文件放入了暂存区,可以使用git checkout “文件名” 将文件从暂存区重新拿到工作区</li>\n<li>git commit ,是将文件从暂存区放入到本地.git仓库</li>\n<li>git status, 查看文件的状态,在暂存区还是在本地仓库,还是已经在本地仓库,或者已经提交(通常这些vscode工具一目了然)</li>\n<li>git pull ,拉取的默认是你自己的分支,详细:git pull origin dev, git pull origin master 拉去远程master分支</li>\n</ul>\n<h3 id=\"git-配置\"><a href=\"#git-配置\" class=\"headerlink\" title=\"git 配置\"></a>git 配置</h3><pre><code># 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name &quot;[name]&quot;\n$ git config [--global] user.email &quot;[email address]&quot;\n</code></pre>\n<h3 id=\"常用流程\"><a href=\"#常用流程\" class=\"headerlink\" title=\"常用流程\"></a>常用流程</h3><ul>\n<li>git add .</li>\n<li>git commit -m ‘ ‘</li>\n<li>git pull</li>\n<li>git push</li>\n</ul>\n<h3 id=\"常用git命令行快捷方式\"><a href=\"#常用git命令行快捷方式\" class=\"headerlink\" title=\"常用git命令行快捷方式\"></a>常用git命令行快捷方式</h3><ul>\n<li>gaa …… git add .</li>\n<li>gcam ‘’ …… git commit -m ‘’</li>\n<li>gl ……. git pull</li>\n<li>gp ……. git push</li>\n</ul>\n<p>执行cat ~&#x2F;.oh-my-zsh&#x2F;plugins&#x2F;git&#x2F;git.plugin.zsh 查看更多简写</p>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ul>\n<li>git log</li>\n<li>git reflog(涉及到的所有操作步骤)</li>\n<li>git reset –hard HEAD</li>\n<li>git checkout file 恢复暂存区的文件到工作区</li>\n<li>git checkout branch 切换分支</li>\n<li>git stash</li>\n<li>git stash pop</li>\n<li>git branch -r 查看远程分支</li>\n<li>git branch -a 查看所有分支</li>\n<li>git remote 列出所有的远程主机</li>\n<li>git pull –all 拉取远程所有的分支</li>\n<li>git commit –amend -message&#x3D;””(修改最近的一次提交注释)</li>\n<li><code>git checkout (branchname)</code> 切换分支命令</li>\n<li><code>git branch (branchname)</code> 创建分支命令</li>\n<li><code>git branch -d (branchname)</code> 删除分支命令</li>\n<li>git push origin –delete Chapater6 删除远程分支命令</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"git名词\"><a href=\"#git名词\" class=\"headerlink\" title=\"git名词\"></a>git名词</h3><ul>\n<li>workspace :工作区</li>\n<li>Index&#x2F;Stage : 暂存区</li>\n<li>Repository : 仓库区(或本地仓库)</li>\n<li>Remote :远程仓库区</li>\n</ul>\n<h3 id=\"常用操作分部解析\"><a href=\"#常用操作分部解析\" class=\"headerlink\" title=\"常用操作分部解析\"></a>常用操作分部解析</h3><ul>\n<li>在任何目录创建新的git仓库,执行 git init**,** .git文件就是本地的一个仓库</li>\n<li>git status 查看修改状态</li>\n<li>git add ,是将文件放入了暂存区,可以使用git checkout “文件名” 将文件从暂存区重新拿到工作区</li>\n<li>git commit ,是将文件从暂存区放入到本地.git仓库</li>\n<li>git status, 查看文件的状态,在暂存区还是在本地仓库,还是已经在本地仓库,或者已经提交(通常这些vscode工具一目了然)</li>\n<li>git pull ,拉取的默认是你自己的分支,详细:git pull origin dev, git pull origin master 拉去远程master分支</li>\n</ul>\n<h3 id=\"git-配置\"><a href=\"#git-配置\" class=\"headerlink\" title=\"git 配置\"></a>git 配置</h3><pre><code># 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name &quot;[name]&quot;\n$ git config [--global] user.email &quot;[email address]&quot;\n</code></pre>\n<h3 id=\"常用流程\"><a href=\"#常用流程\" class=\"headerlink\" title=\"常用流程\"></a>常用流程</h3><ul>\n<li>git add .</li>\n<li>git commit -m ‘ ‘</li>\n<li>git pull</li>\n<li>git push</li>\n</ul>\n<h3 id=\"常用git命令行快捷方式\"><a href=\"#常用git命令行快捷方式\" class=\"headerlink\" title=\"常用git命令行快捷方式\"></a>常用git命令行快捷方式</h3><ul>\n<li>gaa …… git add .</li>\n<li>gcam ‘’ …… git commit -m ‘’</li>\n<li>gl ……. git pull</li>\n<li>gp ……. git push</li>\n</ul>\n<p>执行cat ~&#x2F;.oh-my-zsh&#x2F;plugins&#x2F;git&#x2F;git.plugin.zsh 查看更多简写</p>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ul>\n<li>git log</li>\n<li>git reflog(涉及到的所有操作步骤)</li>\n<li>git reset –hard HEAD</li>\n<li>git checkout file 恢复暂存区的文件到工作区</li>\n<li>git checkout branch 切换分支</li>\n<li>git stash</li>\n<li>git stash pop</li>\n<li>git branch -r 查看远程分支</li>\n<li>git branch -a 查看所有分支</li>\n<li>git remote 列出所有的远程主机</li>\n<li>git pull –all 拉取远程所有的分支</li>\n<li>git commit –amend -message&#x3D;””(修改最近的一次提交注释)</li>\n<li><code>git checkout (branchname)</code> 切换分支命令</li>\n<li><code>git branch (branchname)</code> 创建分支命令</li>\n<li><code>git branch -d (branchname)</code> 删除分支命令</li>\n<li>git push origin –delete Chapater6 删除远程分支命令</li>\n</ul>\n"},{"title":"Mysql的processlist中处理表连接","date":"2023-01-16T08:22:53.000Z","_content":"\n\n## processlist中大量sleep\n\n在生产环境切换mysql数据库，切换后数据库连接池爆满，抛出异常“too many connections”；\n\n出现这种现象，比较常见的原因是连接数真不够了，需要设置连接数：\n\n### 连接数不够解决\n\n```js\nmysql -u root -p;\nshow full processlist;\nkill id;\n```\n\n### 查看最大连接数\n\n```js\nshow variables like \"max_connections\";\n```\n\n查看最大连接数，应该是与上面查询到的连接数相同，才会出现too many connections的情况\n\n```js\nset GLOBAL max_connections=1000;\n```\n\n修改最大连接数，但是这不是一劳永逸的方法，应该要让它自动杀死那些sleep的进程。\n\n### 自动杀死那些sleep的进程\n\n```js\nshow global variables like 'wait_timeout';\n```\n\n这个数值指的是mysql在关闭一个非交互的连接之前要等待的秒数，默认是28800s\n\n```js\nset global wait_timeout=300; \n```\n\n修改这个数值，这里可以随意，最好控制在几分钟内\n\n```js\nset global interactive_timeout=500; \n```\n\n修改这个数值，表示mysql在关闭一个连接之前要等待的秒数，至此可以让mysql自动关闭那些没用的连接，但要注意的是，正在使用的连接到了时间也会被关闭，因此这个时间值要合适\n\n### 笨方法\n\n```js\nselect concat('KILL ',id,';') from information_schema.processlist where user='root';\n```\n\n先把要kill的连接id都查询出来,然后一个个kill\n","source":"_posts/Mysql/mysql的processlist中处理表连接.md","raw":"---\ntitle: Mysql的processlist中处理表连接\ndate: 2023-01-16 16:22:53\ntags: Mysql\n---\n\n\n## processlist中大量sleep\n\n在生产环境切换mysql数据库，切换后数据库连接池爆满，抛出异常“too many connections”；\n\n出现这种现象，比较常见的原因是连接数真不够了，需要设置连接数：\n\n### 连接数不够解决\n\n```js\nmysql -u root -p;\nshow full processlist;\nkill id;\n```\n\n### 查看最大连接数\n\n```js\nshow variables like \"max_connections\";\n```\n\n查看最大连接数，应该是与上面查询到的连接数相同，才会出现too many connections的情况\n\n```js\nset GLOBAL max_connections=1000;\n```\n\n修改最大连接数，但是这不是一劳永逸的方法，应该要让它自动杀死那些sleep的进程。\n\n### 自动杀死那些sleep的进程\n\n```js\nshow global variables like 'wait_timeout';\n```\n\n这个数值指的是mysql在关闭一个非交互的连接之前要等待的秒数，默认是28800s\n\n```js\nset global wait_timeout=300; \n```\n\n修改这个数值，这里可以随意，最好控制在几分钟内\n\n```js\nset global interactive_timeout=500; \n```\n\n修改这个数值，表示mysql在关闭一个连接之前要等待的秒数，至此可以让mysql自动关闭那些没用的连接，但要注意的是，正在使用的连接到了时间也会被关闭，因此这个时间值要合适\n\n### 笨方法\n\n```js\nselect concat('KILL ',id,';') from information_schema.processlist where user='root';\n```\n\n先把要kill的连接id都查询出来,然后一个个kill\n","slug":"Mysql/mysql的processlist中处理表连接","published":1,"updated":"2023-02-21T09:35:15.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iulj000cbkh0d8zmeukp","content":"<h2 id=\"processlist中大量sleep\"><a href=\"#processlist中大量sleep\" class=\"headerlink\" title=\"processlist中大量sleep\"></a>processlist中大量sleep</h2><p>在生产环境切换mysql数据库，切换后数据库连接池爆满，抛出异常“too many connections”；</p>\n<p>出现这种现象，比较常见的原因是连接数真不够了，需要设置连接数：</p>\n<h3 id=\"连接数不够解决\"><a href=\"#连接数不够解决\" class=\"headerlink\" title=\"连接数不够解决\"></a>连接数不够解决</h3><pre><code class=\"js\">mysql -u root -p;\nshow full processlist;\nkill id;\n</code></pre>\n<h3 id=\"查看最大连接数\"><a href=\"#查看最大连接数\" class=\"headerlink\" title=\"查看最大连接数\"></a>查看最大连接数</h3><pre><code class=\"js\">show variables like &quot;max_connections&quot;;\n</code></pre>\n<p>查看最大连接数，应该是与上面查询到的连接数相同，才会出现too many connections的情况</p>\n<pre><code class=\"js\">set GLOBAL max_connections=1000;\n</code></pre>\n<p>修改最大连接数，但是这不是一劳永逸的方法，应该要让它自动杀死那些sleep的进程。</p>\n<h3 id=\"自动杀死那些sleep的进程\"><a href=\"#自动杀死那些sleep的进程\" class=\"headerlink\" title=\"自动杀死那些sleep的进程\"></a>自动杀死那些sleep的进程</h3><pre><code class=\"js\">show global variables like &#39;wait_timeout&#39;;\n</code></pre>\n<p>这个数值指的是mysql在关闭一个非交互的连接之前要等待的秒数，默认是28800s</p>\n<pre><code class=\"js\">set global wait_timeout=300; \n</code></pre>\n<p>修改这个数值，这里可以随意，最好控制在几分钟内</p>\n<pre><code class=\"js\">set global interactive_timeout=500; \n</code></pre>\n<p>修改这个数值，表示mysql在关闭一个连接之前要等待的秒数，至此可以让mysql自动关闭那些没用的连接，但要注意的是，正在使用的连接到了时间也会被关闭，因此这个时间值要合适</p>\n<h3 id=\"笨方法\"><a href=\"#笨方法\" class=\"headerlink\" title=\"笨方法\"></a>笨方法</h3><pre><code class=\"js\">select concat(&#39;KILL &#39;,id,&#39;;&#39;) from information_schema.processlist where user=&#39;root&#39;;\n</code></pre>\n<p>先把要kill的连接id都查询出来,然后一个个kill</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"processlist中大量sleep\"><a href=\"#processlist中大量sleep\" class=\"headerlink\" title=\"processlist中大量sleep\"></a>processlist中大量sleep</h2><p>在生产环境切换mysql数据库，切换后数据库连接池爆满，抛出异常“too many connections”；</p>\n<p>出现这种现象，比较常见的原因是连接数真不够了，需要设置连接数：</p>\n<h3 id=\"连接数不够解决\"><a href=\"#连接数不够解决\" class=\"headerlink\" title=\"连接数不够解决\"></a>连接数不够解决</h3><pre><code class=\"js\">mysql -u root -p;\nshow full processlist;\nkill id;\n</code></pre>\n<h3 id=\"查看最大连接数\"><a href=\"#查看最大连接数\" class=\"headerlink\" title=\"查看最大连接数\"></a>查看最大连接数</h3><pre><code class=\"js\">show variables like &quot;max_connections&quot;;\n</code></pre>\n<p>查看最大连接数，应该是与上面查询到的连接数相同，才会出现too many connections的情况</p>\n<pre><code class=\"js\">set GLOBAL max_connections=1000;\n</code></pre>\n<p>修改最大连接数，但是这不是一劳永逸的方法，应该要让它自动杀死那些sleep的进程。</p>\n<h3 id=\"自动杀死那些sleep的进程\"><a href=\"#自动杀死那些sleep的进程\" class=\"headerlink\" title=\"自动杀死那些sleep的进程\"></a>自动杀死那些sleep的进程</h3><pre><code class=\"js\">show global variables like &#39;wait_timeout&#39;;\n</code></pre>\n<p>这个数值指的是mysql在关闭一个非交互的连接之前要等待的秒数，默认是28800s</p>\n<pre><code class=\"js\">set global wait_timeout=300; \n</code></pre>\n<p>修改这个数值，这里可以随意，最好控制在几分钟内</p>\n<pre><code class=\"js\">set global interactive_timeout=500; \n</code></pre>\n<p>修改这个数值，表示mysql在关闭一个连接之前要等待的秒数，至此可以让mysql自动关闭那些没用的连接，但要注意的是，正在使用的连接到了时间也会被关闭，因此这个时间值要合适</p>\n<h3 id=\"笨方法\"><a href=\"#笨方法\" class=\"headerlink\" title=\"笨方法\"></a>笨方法</h3><pre><code class=\"js\">select concat(&#39;KILL &#39;,id,&#39;;&#39;) from information_schema.processlist where user=&#39;root&#39;;\n</code></pre>\n<p>先把要kill的连接id都查询出来,然后一个个kill</p>\n"},{"title":"Nginx配置","date":"2023-01-11T04:05:22.000Z","_content":"\n\n## nginx配置\n\n```js\nuser www-data;\n#启动进程,通常设置成和cpu的数量相等\nworker_processes 2;\npid /run/nginx.pid;\ninclude /etc/nginx/modules-enabled/*.conf;\n\nevents {\n    worker_connections 768;\n    # multi_accept on;\n}\n\nhttp {\n    ##\n    # Basic Settings\n    ##\n\n    sendfile on;\n    tcp_nopush on;\n    types_hash_max_size 2048;\n    # server_tokens off;\n\n    # server_names_hash_bucket_size 64;\n    # server_name_in_redirect off;\n\n    include /etc/nginx/mime.types;\n    default_type application/octet-stream;\n\n    ##\n    # SSL Settings\n    ##\n\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE\n    ssl_prefer_server_ciphers on;\n\n    ##\n    # Logging Settings\n    ##\n\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log;\n\n    # Gzip Settings\n    gzip on;\n    gzip_min_length 1000;\n    gzip_vary on;\n    gzip_proxied any;\n    gzip_comp_level 6;\n    gzip_buffers 16 8k;\n    gzip_http_version 1.1;\n    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\n\n    ##\n    # Virtual Host Configs\n    ##\n    include /etc/nginx/conf.d/*.conf;\n    include /etc/nginx/sites-enabled/*;\n\n\n    map $sent_http_content_type $expires {\n        \"text/html\" epoch;\n        \"text/html; charset=utf-8\" epoch;\n        default off;\n    }\n\n    server {\n        listen 80;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life;\n        return 301 https://$host$request_uri;\n        # gzip on;\n        # gzip_types text/plain application/xml text/css application/javascript;\n        # gzip_min_length 1000;\n\n        # location / {\n        #     expires $expires;\n        #     proxy_redirect off;\n        #     proxy_set_header Host $host;\n        #     proxy_set_header X-Real-IP $remote_addr;\n        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        #     proxy_set_header X-Forwarded-Proto $scheme;\n        #     proxy_read_timeout 1m;\n        #     proxy_connect_timeout 1m;\n        #     proxy_pass http://127.0.0.1:3000/;\n        # }\n        # location ~ /.well-known {\n        #     allow all;\n        # }\n        # location ^~ /.well-known/pki-validation/ {\n        #     add_header Cache-Control no-cache;\n        #     default_type \"text/plain\";\n        #     rewrite /.well-known/pki-validation/(.*) /$1 break;\n        #     root /var/www/whatever;\n        # }\n        # location /nuxt3-tag {\n        #     expires $expires;\n        #     proxy_redirect off;\n        #     proxy_set_header Host $host;\n        #     proxy_set_header X-Real-IP $remote_addr;\n        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        #     proxy_set_header X-Forwarded-Proto $scheme;\n        #     proxy_read_timeout 1m;\n        #     proxy_connect_timeout 1m;\n        #     proxy_pass http://127.0.0.1:3000/nuxt3-tag;\n        # }\n        # location /stable {\n        #     rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent;\n        # }\n        # location /nuxt3 {\n        #     rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent;\n        # }\n        # location /tag {\n        #     rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent;\n        # }\n        # location /stable/api {\n        #     proxy_pass http://www.ptg.life:5000/api;\n        #     proxy_set_header Access-Control-Max-Age 86400;\n        #     proxy_set_header Host $host;\n        #     proxy_redirect off;\n        #     proxy_set_header X-Real-IP $remote_addr;\n        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        #     proxy_connect_timeout 60;\n        #     proxy_read_timeout 60;\n        #     proxy_send_timeout 60;\n        # }\n        # location /static/ {\n        #     valid_referers none blocked *.ptg.life;\n        #     if ($invalid_referer) {\n        #         return 403;\n        #         break;\n        #     }\n        #     expires 30d;\n        #     autoindex on;\n        #     root /data;\n        # }\n    }\n\n    server {\n        listen 443 ssl;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life;\n\n        # 新版的nginx只用listen 443 ssl就行,需要注释\n        # ssl on;\n        keepalive_timeout 10m;\n        server_tokens off;\n        # 缓存SSL握手产生的参数和加密密钥的时长\n        ssl_session_timeout 10m;\n        # 证书\n        ssl_certificate /etc/nginx/certificate.crt;\n        ssl_certificate_key /etc/nginx/private.key;\n        # 日志\n        access_log /var/log/nginx/nginx.vhost.access.log;\n        error_log /var/log/nginx/nginx.vhost.error.log;\n\n        # 根用iframe嵌入做个隐式url\n        location / {\n            index index.html index.htm index.html inde.php;\n            root /usr/share/nginx/html;\n        }\n\n        location ~ /.well-known {\n            allow all;\n        }\n\n        location ^~ /.well-known/pki-validation/ {\n            add_header Cache-Control no-cache;\n            default_type \"text/plain\";\n            rewrite /.well-known/pki-validation/(.*) /$1 break;\n            root /var/www/whatever;\n        }\n\n        location /nuxt3-tag/ {\n            expires $expires;\n            proxy_redirect off;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_read_timeout 1m;\n            proxy_connect_timeout 1m;\n            proxy_pass http://127.0.0.1:3000/nuxt3-tag/;\n        }\n\n        location /naifu/ {\n            expires $expires;\n            proxy_redirect off;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_read_timeout 1m;\n            proxy_connect_timeout 1m;\n            proxy_pass http://127.0.0.1:3000/naifu/;\n        }\n\n        location /nuxt3 {\n            rewrite ^/(.*) $host://$http_host/nuxt3-tag permanent;\n        }\n\n        location /tag {\n            rewrite ^/(.*) $host://$http_host/nuxt3-tag permanent;\n        }\n\n        # flask的接口代理\n        location /stable/api {\n            proxy_pass http://127.0.0.1:5000/api;\n            proxy_set_header Access-Control-Max-Age 86400;\n            proxy_set_header Host $host;\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_connect_timeout 60;\n            proxy_read_timeout 60;\n            proxy_send_timeout 60;\n        }\n\n        location /static/ {\n            valid_referers none blocked *.ptg.life;\n            if ($invalid_referer) {\n                return 403;\n                break;\n            }\n            expires 30d;\n            autoindex on;\n            root /data;\n        }\n    }\n}\n```\n","source":"_posts/Nginx/nginx配置.md","raw":"---\ntitle: Nginx配置\ndate: 2023-01-11 12:05:22\ntags: Nginx\ncategories: Nginx\n---\n\n\n## nginx配置\n\n```js\nuser www-data;\n#启动进程,通常设置成和cpu的数量相等\nworker_processes 2;\npid /run/nginx.pid;\ninclude /etc/nginx/modules-enabled/*.conf;\n\nevents {\n    worker_connections 768;\n    # multi_accept on;\n}\n\nhttp {\n    ##\n    # Basic Settings\n    ##\n\n    sendfile on;\n    tcp_nopush on;\n    types_hash_max_size 2048;\n    # server_tokens off;\n\n    # server_names_hash_bucket_size 64;\n    # server_name_in_redirect off;\n\n    include /etc/nginx/mime.types;\n    default_type application/octet-stream;\n\n    ##\n    # SSL Settings\n    ##\n\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE\n    ssl_prefer_server_ciphers on;\n\n    ##\n    # Logging Settings\n    ##\n\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log;\n\n    # Gzip Settings\n    gzip on;\n    gzip_min_length 1000;\n    gzip_vary on;\n    gzip_proxied any;\n    gzip_comp_level 6;\n    gzip_buffers 16 8k;\n    gzip_http_version 1.1;\n    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\n\n    ##\n    # Virtual Host Configs\n    ##\n    include /etc/nginx/conf.d/*.conf;\n    include /etc/nginx/sites-enabled/*;\n\n\n    map $sent_http_content_type $expires {\n        \"text/html\" epoch;\n        \"text/html; charset=utf-8\" epoch;\n        default off;\n    }\n\n    server {\n        listen 80;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life;\n        return 301 https://$host$request_uri;\n        # gzip on;\n        # gzip_types text/plain application/xml text/css application/javascript;\n        # gzip_min_length 1000;\n\n        # location / {\n        #     expires $expires;\n        #     proxy_redirect off;\n        #     proxy_set_header Host $host;\n        #     proxy_set_header X-Real-IP $remote_addr;\n        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        #     proxy_set_header X-Forwarded-Proto $scheme;\n        #     proxy_read_timeout 1m;\n        #     proxy_connect_timeout 1m;\n        #     proxy_pass http://127.0.0.1:3000/;\n        # }\n        # location ~ /.well-known {\n        #     allow all;\n        # }\n        # location ^~ /.well-known/pki-validation/ {\n        #     add_header Cache-Control no-cache;\n        #     default_type \"text/plain\";\n        #     rewrite /.well-known/pki-validation/(.*) /$1 break;\n        #     root /var/www/whatever;\n        # }\n        # location /nuxt3-tag {\n        #     expires $expires;\n        #     proxy_redirect off;\n        #     proxy_set_header Host $host;\n        #     proxy_set_header X-Real-IP $remote_addr;\n        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        #     proxy_set_header X-Forwarded-Proto $scheme;\n        #     proxy_read_timeout 1m;\n        #     proxy_connect_timeout 1m;\n        #     proxy_pass http://127.0.0.1:3000/nuxt3-tag;\n        # }\n        # location /stable {\n        #     rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent;\n        # }\n        # location /nuxt3 {\n        #     rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent;\n        # }\n        # location /tag {\n        #     rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent;\n        # }\n        # location /stable/api {\n        #     proxy_pass http://www.ptg.life:5000/api;\n        #     proxy_set_header Access-Control-Max-Age 86400;\n        #     proxy_set_header Host $host;\n        #     proxy_redirect off;\n        #     proxy_set_header X-Real-IP $remote_addr;\n        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        #     proxy_connect_timeout 60;\n        #     proxy_read_timeout 60;\n        #     proxy_send_timeout 60;\n        # }\n        # location /static/ {\n        #     valid_referers none blocked *.ptg.life;\n        #     if ($invalid_referer) {\n        #         return 403;\n        #         break;\n        #     }\n        #     expires 30d;\n        #     autoindex on;\n        #     root /data;\n        # }\n    }\n\n    server {\n        listen 443 ssl;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life;\n\n        # 新版的nginx只用listen 443 ssl就行,需要注释\n        # ssl on;\n        keepalive_timeout 10m;\n        server_tokens off;\n        # 缓存SSL握手产生的参数和加密密钥的时长\n        ssl_session_timeout 10m;\n        # 证书\n        ssl_certificate /etc/nginx/certificate.crt;\n        ssl_certificate_key /etc/nginx/private.key;\n        # 日志\n        access_log /var/log/nginx/nginx.vhost.access.log;\n        error_log /var/log/nginx/nginx.vhost.error.log;\n\n        # 根用iframe嵌入做个隐式url\n        location / {\n            index index.html index.htm index.html inde.php;\n            root /usr/share/nginx/html;\n        }\n\n        location ~ /.well-known {\n            allow all;\n        }\n\n        location ^~ /.well-known/pki-validation/ {\n            add_header Cache-Control no-cache;\n            default_type \"text/plain\";\n            rewrite /.well-known/pki-validation/(.*) /$1 break;\n            root /var/www/whatever;\n        }\n\n        location /nuxt3-tag/ {\n            expires $expires;\n            proxy_redirect off;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_read_timeout 1m;\n            proxy_connect_timeout 1m;\n            proxy_pass http://127.0.0.1:3000/nuxt3-tag/;\n        }\n\n        location /naifu/ {\n            expires $expires;\n            proxy_redirect off;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_read_timeout 1m;\n            proxy_connect_timeout 1m;\n            proxy_pass http://127.0.0.1:3000/naifu/;\n        }\n\n        location /nuxt3 {\n            rewrite ^/(.*) $host://$http_host/nuxt3-tag permanent;\n        }\n\n        location /tag {\n            rewrite ^/(.*) $host://$http_host/nuxt3-tag permanent;\n        }\n\n        # flask的接口代理\n        location /stable/api {\n            proxy_pass http://127.0.0.1:5000/api;\n            proxy_set_header Access-Control-Max-Age 86400;\n            proxy_set_header Host $host;\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_connect_timeout 60;\n            proxy_read_timeout 60;\n            proxy_send_timeout 60;\n        }\n\n        location /static/ {\n            valid_referers none blocked *.ptg.life;\n            if ($invalid_referer) {\n                return 403;\n                break;\n            }\n            expires 30d;\n            autoindex on;\n            root /data;\n        }\n    }\n}\n```\n","slug":"Nginx/nginx配置","published":1,"updated":"2023-02-21T09:35:15.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iulk000dbkh0f2c58ka6","content":"<h2 id=\"nginx配置\"><a href=\"#nginx配置\" class=\"headerlink\" title=\"nginx配置\"></a>nginx配置</h2><pre><code class=\"js\">user www-data;\n#启动进程,通常设置成和cpu的数量相等\nworker_processes 2;\npid /run/nginx.pid;\ninclude /etc/nginx/modules-enabled/*.conf;\n\nevents &#123;\n    worker_connections 768;\n    # multi_accept on;\n&#125;\n\nhttp &#123;\n    ##\n    # Basic Settings\n    ##\n\n    sendfile on;\n    tcp_nopush on;\n    types_hash_max_size 2048;\n    # server_tokens off;\n\n    # server_names_hash_bucket_size 64;\n    # server_name_in_redirect off;\n\n    include /etc/nginx/mime.types;\n    default_type application/octet-stream;\n\n    ##\n    # SSL Settings\n    ##\n\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE\n    ssl_prefer_server_ciphers on;\n\n    ##\n    # Logging Settings\n    ##\n\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log;\n\n    # Gzip Settings\n    gzip on;\n    gzip_min_length 1000;\n    gzip_vary on;\n    gzip_proxied any;\n    gzip_comp_level 6;\n    gzip_buffers 16 8k;\n    gzip_http_version 1.1;\n    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\n\n    ##\n    # Virtual Host Configs\n    ##\n    include /etc/nginx/conf.d/*.conf;\n    include /etc/nginx/sites-enabled/*;\n\n\n    map $sent_http_content_type $expires &#123;\n        &quot;text/html&quot; epoch;\n        &quot;text/html; charset=utf-8&quot; epoch;\n        default off;\n    &#125;\n\n    server &#123;\n        listen 80;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life;\n        return 301 https://$host$request_uri;\n        # gzip on;\n        # gzip_types text/plain application/xml text/css application/javascript;\n        # gzip_min_length 1000;\n\n        # location / &#123;\n        #     expires $expires;\n        #     proxy_redirect off;\n        #     proxy_set_header Host $host;\n        #     proxy_set_header X-Real-IP $remote_addr;\n        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        #     proxy_set_header X-Forwarded-Proto $scheme;\n        #     proxy_read_timeout 1m;\n        #     proxy_connect_timeout 1m;\n        #     proxy_pass http://127.0.0.1:3000/;\n        # &#125;\n        # location ~ /.well-known &#123;\n        #     allow all;\n        # &#125;\n        # location ^~ /.well-known/pki-validation/ &#123;\n        #     add_header Cache-Control no-cache;\n        #     default_type &quot;text/plain&quot;;\n        #     rewrite /.well-known/pki-validation/(.*) /$1 break;\n        #     root /var/www/whatever;\n        # &#125;\n        # location /nuxt3-tag &#123;\n        #     expires $expires;\n        #     proxy_redirect off;\n        #     proxy_set_header Host $host;\n        #     proxy_set_header X-Real-IP $remote_addr;\n        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        #     proxy_set_header X-Forwarded-Proto $scheme;\n        #     proxy_read_timeout 1m;\n        #     proxy_connect_timeout 1m;\n        #     proxy_pass http://127.0.0.1:3000/nuxt3-tag;\n        # &#125;\n        # location /stable &#123;\n        #     rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent;\n        # &#125;\n        # location /nuxt3 &#123;\n        #     rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent;\n        # &#125;\n        # location /tag &#123;\n        #     rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent;\n        # &#125;\n        # location /stable/api &#123;\n        #     proxy_pass http://www.ptg.life:5000/api;\n        #     proxy_set_header Access-Control-Max-Age 86400;\n        #     proxy_set_header Host $host;\n        #     proxy_redirect off;\n        #     proxy_set_header X-Real-IP $remote_addr;\n        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        #     proxy_connect_timeout 60;\n        #     proxy_read_timeout 60;\n        #     proxy_send_timeout 60;\n        # &#125;\n        # location /static/ &#123;\n        #     valid_referers none blocked *.ptg.life;\n        #     if ($invalid_referer) &#123;\n        #         return 403;\n        #         break;\n        #     &#125;\n        #     expires 30d;\n        #     autoindex on;\n        #     root /data;\n        # &#125;\n    &#125;\n\n    server &#123;\n        listen 443 ssl;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life;\n\n        # 新版的nginx只用listen 443 ssl就行,需要注释\n        # ssl on;\n        keepalive_timeout 10m;\n        server_tokens off;\n        # 缓存SSL握手产生的参数和加密密钥的时长\n        ssl_session_timeout 10m;\n        # 证书\n        ssl_certificate /etc/nginx/certificate.crt;\n        ssl_certificate_key /etc/nginx/private.key;\n        # 日志\n        access_log /var/log/nginx/nginx.vhost.access.log;\n        error_log /var/log/nginx/nginx.vhost.error.log;\n\n        # 根用iframe嵌入做个隐式url\n        location / &#123;\n            index index.html index.htm index.html inde.php;\n            root /usr/share/nginx/html;\n        &#125;\n\n        location ~ /.well-known &#123;\n            allow all;\n        &#125;\n\n        location ^~ /.well-known/pki-validation/ &#123;\n            add_header Cache-Control no-cache;\n            default_type &quot;text/plain&quot;;\n            rewrite /.well-known/pki-validation/(.*) /$1 break;\n            root /var/www/whatever;\n        &#125;\n\n        location /nuxt3-tag/ &#123;\n            expires $expires;\n            proxy_redirect off;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_read_timeout 1m;\n            proxy_connect_timeout 1m;\n            proxy_pass http://127.0.0.1:3000/nuxt3-tag/;\n        &#125;\n\n        location /naifu/ &#123;\n            expires $expires;\n            proxy_redirect off;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_read_timeout 1m;\n            proxy_connect_timeout 1m;\n            proxy_pass http://127.0.0.1:3000/naifu/;\n        &#125;\n\n        location /nuxt3 &#123;\n            rewrite ^/(.*) $host://$http_host/nuxt3-tag permanent;\n        &#125;\n\n        location /tag &#123;\n            rewrite ^/(.*) $host://$http_host/nuxt3-tag permanent;\n        &#125;\n\n        # flask的接口代理\n        location /stable/api &#123;\n            proxy_pass http://127.0.0.1:5000/api;\n            proxy_set_header Access-Control-Max-Age 86400;\n            proxy_set_header Host $host;\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_connect_timeout 60;\n            proxy_read_timeout 60;\n            proxy_send_timeout 60;\n        &#125;\n\n        location /static/ &#123;\n            valid_referers none blocked *.ptg.life;\n            if ($invalid_referer) &#123;\n                return 403;\n                break;\n            &#125;\n            expires 30d;\n            autoindex on;\n            root /data;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"nginx配置\"><a href=\"#nginx配置\" class=\"headerlink\" title=\"nginx配置\"></a>nginx配置</h2><pre><code class=\"js\">user www-data;\n#启动进程,通常设置成和cpu的数量相等\nworker_processes 2;\npid /run/nginx.pid;\ninclude /etc/nginx/modules-enabled/*.conf;\n\nevents &#123;\n    worker_connections 768;\n    # multi_accept on;\n&#125;\n\nhttp &#123;\n    ##\n    # Basic Settings\n    ##\n\n    sendfile on;\n    tcp_nopush on;\n    types_hash_max_size 2048;\n    # server_tokens off;\n\n    # server_names_hash_bucket_size 64;\n    # server_name_in_redirect off;\n\n    include /etc/nginx/mime.types;\n    default_type application/octet-stream;\n\n    ##\n    # SSL Settings\n    ##\n\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE\n    ssl_prefer_server_ciphers on;\n\n    ##\n    # Logging Settings\n    ##\n\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log;\n\n    # Gzip Settings\n    gzip on;\n    gzip_min_length 1000;\n    gzip_vary on;\n    gzip_proxied any;\n    gzip_comp_level 6;\n    gzip_buffers 16 8k;\n    gzip_http_version 1.1;\n    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\n\n    ##\n    # Virtual Host Configs\n    ##\n    include /etc/nginx/conf.d/*.conf;\n    include /etc/nginx/sites-enabled/*;\n\n\n    map $sent_http_content_type $expires &#123;\n        &quot;text/html&quot; epoch;\n        &quot;text/html; charset=utf-8&quot; epoch;\n        default off;\n    &#125;\n\n    server &#123;\n        listen 80;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life;\n        return 301 https://$host$request_uri;\n        # gzip on;\n        # gzip_types text/plain application/xml text/css application/javascript;\n        # gzip_min_length 1000;\n\n        # location / &#123;\n        #     expires $expires;\n        #     proxy_redirect off;\n        #     proxy_set_header Host $host;\n        #     proxy_set_header X-Real-IP $remote_addr;\n        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        #     proxy_set_header X-Forwarded-Proto $scheme;\n        #     proxy_read_timeout 1m;\n        #     proxy_connect_timeout 1m;\n        #     proxy_pass http://127.0.0.1:3000/;\n        # &#125;\n        # location ~ /.well-known &#123;\n        #     allow all;\n        # &#125;\n        # location ^~ /.well-known/pki-validation/ &#123;\n        #     add_header Cache-Control no-cache;\n        #     default_type &quot;text/plain&quot;;\n        #     rewrite /.well-known/pki-validation/(.*) /$1 break;\n        #     root /var/www/whatever;\n        # &#125;\n        # location /nuxt3-tag &#123;\n        #     expires $expires;\n        #     proxy_redirect off;\n        #     proxy_set_header Host $host;\n        #     proxy_set_header X-Real-IP $remote_addr;\n        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        #     proxy_set_header X-Forwarded-Proto $scheme;\n        #     proxy_read_timeout 1m;\n        #     proxy_connect_timeout 1m;\n        #     proxy_pass http://127.0.0.1:3000/nuxt3-tag;\n        # &#125;\n        # location /stable &#123;\n        #     rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent;\n        # &#125;\n        # location /nuxt3 &#123;\n        #     rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent;\n        # &#125;\n        # location /tag &#123;\n        #     rewrite ^/(.*) http://www.ptg.life:3000/nuxt3-tag permanent;\n        # &#125;\n        # location /stable/api &#123;\n        #     proxy_pass http://www.ptg.life:5000/api;\n        #     proxy_set_header Access-Control-Max-Age 86400;\n        #     proxy_set_header Host $host;\n        #     proxy_redirect off;\n        #     proxy_set_header X-Real-IP $remote_addr;\n        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        #     proxy_connect_timeout 60;\n        #     proxy_read_timeout 60;\n        #     proxy_send_timeout 60;\n        # &#125;\n        # location /static/ &#123;\n        #     valid_referers none blocked *.ptg.life;\n        #     if ($invalid_referer) &#123;\n        #         return 403;\n        #         break;\n        #     &#125;\n        #     expires 30d;\n        #     autoindex on;\n        #     root /data;\n        # &#125;\n    &#125;\n\n    server &#123;\n        listen 443 ssl;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life;\n\n        # 新版的nginx只用listen 443 ssl就行,需要注释\n        # ssl on;\n        keepalive_timeout 10m;\n        server_tokens off;\n        # 缓存SSL握手产生的参数和加密密钥的时长\n        ssl_session_timeout 10m;\n        # 证书\n        ssl_certificate /etc/nginx/certificate.crt;\n        ssl_certificate_key /etc/nginx/private.key;\n        # 日志\n        access_log /var/log/nginx/nginx.vhost.access.log;\n        error_log /var/log/nginx/nginx.vhost.error.log;\n\n        # 根用iframe嵌入做个隐式url\n        location / &#123;\n            index index.html index.htm index.html inde.php;\n            root /usr/share/nginx/html;\n        &#125;\n\n        location ~ /.well-known &#123;\n            allow all;\n        &#125;\n\n        location ^~ /.well-known/pki-validation/ &#123;\n            add_header Cache-Control no-cache;\n            default_type &quot;text/plain&quot;;\n            rewrite /.well-known/pki-validation/(.*) /$1 break;\n            root /var/www/whatever;\n        &#125;\n\n        location /nuxt3-tag/ &#123;\n            expires $expires;\n            proxy_redirect off;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_read_timeout 1m;\n            proxy_connect_timeout 1m;\n            proxy_pass http://127.0.0.1:3000/nuxt3-tag/;\n        &#125;\n\n        location /naifu/ &#123;\n            expires $expires;\n            proxy_redirect off;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_read_timeout 1m;\n            proxy_connect_timeout 1m;\n            proxy_pass http://127.0.0.1:3000/naifu/;\n        &#125;\n\n        location /nuxt3 &#123;\n            rewrite ^/(.*) $host://$http_host/nuxt3-tag permanent;\n        &#125;\n\n        location /tag &#123;\n            rewrite ^/(.*) $host://$http_host/nuxt3-tag permanent;\n        &#125;\n\n        # flask的接口代理\n        location /stable/api &#123;\n            proxy_pass http://127.0.0.1:5000/api;\n            proxy_set_header Access-Control-Max-Age 86400;\n            proxy_set_header Host $host;\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_connect_timeout 60;\n            proxy_read_timeout 60;\n            proxy_send_timeout 60;\n        &#125;\n\n        location /static/ &#123;\n            valid_referers none blocked *.ptg.life;\n            if ($invalid_referer) &#123;\n                return 403;\n                break;\n            &#125;\n            expires 30d;\n            autoindex on;\n            root /data;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"Nginx配置Https","date":"2023-01-11T04:04:52.000Z","_content":"\n\n\n## ****SSL 证书部署****\n\n首先申请免费证书,推荐阿里或者七牛云[https://cn.aliyun.com/product/cas?from_alibabacloud=&source=5176.11533457&userCode=ywqc0ubl&type=copy](https://cn.aliyun.com/product/cas?from_alibabacloud=&source=5176.11533457&userCode=ywqc0ubl&type=copy)\n\n下载申请好的 ssl 证书文件压缩包到本地并解压到/etc/nginx/\n\n```jsx\n/etc/nginx/certificate.crt;\n/etc/nginx/private.key;\n```\n\n将这两个文件上传至服务器的/etc/nginx/目录里\n\n```jsx\nscp /Users/lilin/Downloads/certificate.crt root@xxx.xx.xxx.xx:/etc/nginx/\nscp /Users/lilin/Downloads/private.crt root@xxx.xx.xxx.xx:/etc/nginx/\n```\n\n## nginx.conf配置\n\n配置 https [server](https://link.segmentfault.com/?enc=j1N%2B5oPWtgTmj4YYsFd5ww%3D%3D.x32KBqxEXmGOwmMZfGjqRXhbghKgM1LsJhVbG%2B8iji5BQ1P9tGkbxC2u%2FdahY%2BV6).注释掉之前的 http server 配置,新增 https server\n\n```jsx\n将http重定向https\nserver {\n        listen 80;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life;\n        return 301 https://$host$request_uri;\n }\n\nserver {\n        listen 443 ssl;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life;\n\n        # 新版的nginx只用listen 443 ssl就行,需要注释\n        # ssl on;\n        keepalive_timeout 10m;\n        server_tokens off;\n        # 缓存SSL握手产生的参数和加密密钥的时长\n        ssl_session_timeout 10m;\n        # 证书\n        ssl_certificate /etc/nginx/certificate.crt;\n        ssl_certificate_key /etc/nginx/private.key;\n        # 日志\n        access_log /var/log/nginx/nginx.vhost.access.log;\n        error_log /var/log/nginx/nginx.vhost.error.log;\n\n        # 根用iframe嵌入做个隐式url\n        location / {\n            index index.html index.htm index.html inde.php;\n            root /usr/share/nginx/html;\n        }\n    }\n```\n","source":"_posts/Nginx/nginx配置https.md","raw":"---\ntitle: Nginx配置Https\ndate: 2023-01-11 12:04:52\ntags: \n - Nginx \n - Https\ncategories: Nginx\n---\n\n\n\n## ****SSL 证书部署****\n\n首先申请免费证书,推荐阿里或者七牛云[https://cn.aliyun.com/product/cas?from_alibabacloud=&source=5176.11533457&userCode=ywqc0ubl&type=copy](https://cn.aliyun.com/product/cas?from_alibabacloud=&source=5176.11533457&userCode=ywqc0ubl&type=copy)\n\n下载申请好的 ssl 证书文件压缩包到本地并解压到/etc/nginx/\n\n```jsx\n/etc/nginx/certificate.crt;\n/etc/nginx/private.key;\n```\n\n将这两个文件上传至服务器的/etc/nginx/目录里\n\n```jsx\nscp /Users/lilin/Downloads/certificate.crt root@xxx.xx.xxx.xx:/etc/nginx/\nscp /Users/lilin/Downloads/private.crt root@xxx.xx.xxx.xx:/etc/nginx/\n```\n\n## nginx.conf配置\n\n配置 https [server](https://link.segmentfault.com/?enc=j1N%2B5oPWtgTmj4YYsFd5ww%3D%3D.x32KBqxEXmGOwmMZfGjqRXhbghKgM1LsJhVbG%2B8iji5BQ1P9tGkbxC2u%2FdahY%2BV6).注释掉之前的 http server 配置,新增 https server\n\n```jsx\n将http重定向https\nserver {\n        listen 80;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life;\n        return 301 https://$host$request_uri;\n }\n\nserver {\n        listen 443 ssl;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life;\n\n        # 新版的nginx只用listen 443 ssl就行,需要注释\n        # ssl on;\n        keepalive_timeout 10m;\n        server_tokens off;\n        # 缓存SSL握手产生的参数和加密密钥的时长\n        ssl_session_timeout 10m;\n        # 证书\n        ssl_certificate /etc/nginx/certificate.crt;\n        ssl_certificate_key /etc/nginx/private.key;\n        # 日志\n        access_log /var/log/nginx/nginx.vhost.access.log;\n        error_log /var/log/nginx/nginx.vhost.error.log;\n\n        # 根用iframe嵌入做个隐式url\n        location / {\n            index index.html index.htm index.html inde.php;\n            root /usr/share/nginx/html;\n        }\n    }\n```\n","slug":"Nginx/nginx配置https","published":1,"updated":"2023-02-21T09:35:15.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iulm000fbkh07j3i55yt","content":"<h2 id=\"SSL-证书部署\"><a href=\"#SSL-证书部署\" class=\"headerlink\" title=\"SSL 证书部署\"></a><strong><strong>SSL 证书部署</strong></strong></h2><p>首先申请免费证书,推荐阿里或者七牛云<a href=\"https://cn.aliyun.com/product/cas?from_alibabacloud=&source=5176.11533457&userCode=ywqc0ubl&type=copy\">https://cn.aliyun.com/product/cas?from_alibabacloud&#x3D;&amp;source&#x3D;5176.11533457&amp;userCode&#x3D;ywqc0ubl&amp;type&#x3D;copy</a></p>\n<p>下载申请好的 ssl 证书文件压缩包到本地并解压到&#x2F;etc&#x2F;nginx&#x2F;</p>\n<pre><code class=\"jsx\">/etc/nginx/certificate.crt;\n/etc/nginx/private.key;\n</code></pre>\n<p>将这两个文件上传至服务器的&#x2F;etc&#x2F;nginx&#x2F;目录里</p>\n<pre><code class=\"jsx\">scp /Users/lilin/Downloads/certificate.crt root@xxx.xx.xxx.xx:/etc/nginx/\nscp /Users/lilin/Downloads/private.crt root@xxx.xx.xxx.xx:/etc/nginx/\n</code></pre>\n<h2 id=\"nginx-conf配置\"><a href=\"#nginx-conf配置\" class=\"headerlink\" title=\"nginx.conf配置\"></a>nginx.conf配置</h2><p>配置 https <a href=\"https://link.segmentfault.com/?enc=j1N+5oPWtgTmj4YYsFd5ww==.x32KBqxEXmGOwmMZfGjqRXhbghKgM1LsJhVbG+8iji5BQ1P9tGkbxC2u/dahY+V6\">server</a>.注释掉之前的 http server 配置,新增 https server</p>\n<pre><code class=\"jsx\">将http重定向https\nserver &#123;\n        listen 80;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life;\n        return 301 https://$host$request_uri;\n &#125;\n\nserver &#123;\n        listen 443 ssl;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life;\n\n        # 新版的nginx只用listen 443 ssl就行,需要注释\n        # ssl on;\n        keepalive_timeout 10m;\n        server_tokens off;\n        # 缓存SSL握手产生的参数和加密密钥的时长\n        ssl_session_timeout 10m;\n        # 证书\n        ssl_certificate /etc/nginx/certificate.crt;\n        ssl_certificate_key /etc/nginx/private.key;\n        # 日志\n        access_log /var/log/nginx/nginx.vhost.access.log;\n        error_log /var/log/nginx/nginx.vhost.error.log;\n\n        # 根用iframe嵌入做个隐式url\n        location / &#123;\n            index index.html index.htm index.html inde.php;\n            root /usr/share/nginx/html;\n        &#125;\n    &#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SSL-证书部署\"><a href=\"#SSL-证书部署\" class=\"headerlink\" title=\"SSL 证书部署\"></a><strong><strong>SSL 证书部署</strong></strong></h2><p>首先申请免费证书,推荐阿里或者七牛云<a href=\"https://cn.aliyun.com/product/cas?from_alibabacloud=&source=5176.11533457&userCode=ywqc0ubl&type=copy\">https://cn.aliyun.com/product/cas?from_alibabacloud&#x3D;&amp;source&#x3D;5176.11533457&amp;userCode&#x3D;ywqc0ubl&amp;type&#x3D;copy</a></p>\n<p>下载申请好的 ssl 证书文件压缩包到本地并解压到&#x2F;etc&#x2F;nginx&#x2F;</p>\n<pre><code class=\"jsx\">/etc/nginx/certificate.crt;\n/etc/nginx/private.key;\n</code></pre>\n<p>将这两个文件上传至服务器的&#x2F;etc&#x2F;nginx&#x2F;目录里</p>\n<pre><code class=\"jsx\">scp /Users/lilin/Downloads/certificate.crt root@xxx.xx.xxx.xx:/etc/nginx/\nscp /Users/lilin/Downloads/private.crt root@xxx.xx.xxx.xx:/etc/nginx/\n</code></pre>\n<h2 id=\"nginx-conf配置\"><a href=\"#nginx-conf配置\" class=\"headerlink\" title=\"nginx.conf配置\"></a>nginx.conf配置</h2><p>配置 https <a href=\"https://link.segmentfault.com/?enc=j1N+5oPWtgTmj4YYsFd5ww==.x32KBqxEXmGOwmMZfGjqRXhbghKgM1LsJhVbG+8iji5BQ1P9tGkbxC2u/dahY+V6\">server</a>.注释掉之前的 http server 配置,新增 https server</p>\n<pre><code class=\"jsx\">将http重定向https\nserver &#123;\n        listen 80;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life;\n        return 301 https://$host$request_uri;\n &#125;\n\nserver &#123;\n        listen 443 ssl;\n        server_name ptg.life www.ptg.life noval.ptg.life prompt.ptg.life naifu.ptg.life;\n\n        # 新版的nginx只用listen 443 ssl就行,需要注释\n        # ssl on;\n        keepalive_timeout 10m;\n        server_tokens off;\n        # 缓存SSL握手产生的参数和加密密钥的时长\n        ssl_session_timeout 10m;\n        # 证书\n        ssl_certificate /etc/nginx/certificate.crt;\n        ssl_certificate_key /etc/nginx/private.key;\n        # 日志\n        access_log /var/log/nginx/nginx.vhost.access.log;\n        error_log /var/log/nginx/nginx.vhost.error.log;\n\n        # 根用iframe嵌入做个隐式url\n        location / &#123;\n            index index.html index.htm index.html inde.php;\n            root /usr/share/nginx/html;\n        &#125;\n    &#125;\n</code></pre>\n"},{"title":"Nvm管理工具","date":"2023-02-08T03:33:38.000Z","_content":"\n## NVM\n\n### 安装\n\n> Linux 安装\n\n```\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v1/install.sh | bash\n\nsource ~/.bashrc\n```\n\n> MacOS 安装\n\n```\ncurl -0- https://raw.githubusercontent.com/creationix/nvm/v8/install.sh | bash\n```\n\n### 常用命令\n\n```\n# 显示所有信息\n\nnvm --help\n\n# 显示当前安装的nvm版本\n\nnvm --version\n\n# 安装指定的版本，如果不存在.nvmrc,就从指定的资源下载安装\n\nnvm install [-s] <version>\n\n# 安装指定的版本，平且下载最新的npm\n\nnvm install [-s] <version>  -latest-npm\n\n# 卸载指定的版本\n\nnvm uninstall <version>\n\n# 使用已经安装的版本  切换版本\n\nnvm use [--silent] <version>\n\n# 查看当前使用的node版本\n\nnvm current\n\n# 查看已经安装的版本\n\nnvm ls\n\n# 查看指定版本\n\nnvm ls  <version>\n\n# 显示远程所有可以安装的nodejs版本\n\nnvm ls-remote\n\n# 查看长期支持的版本\n\nnvm ls-remote --lts\n\n# 安装罪行的npm\n\nnvm install-latest-npm\n\n# 重新安装指定的版本\n\nnvm reinstall-packages <version>\n\n# 显示nvm的cache\n\nnvm cache dir\n\n# 清空nvm的cache\n\nnvm cache clear\n```\n","source":"_posts/Node/Nvm管理工具.md","raw":"---\ntitle: Nvm管理工具\ndate: 2023-02-08 11:33:38\ntags: Node\n---\n\n## NVM\n\n### 安装\n\n> Linux 安装\n\n```\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v1/install.sh | bash\n\nsource ~/.bashrc\n```\n\n> MacOS 安装\n\n```\ncurl -0- https://raw.githubusercontent.com/creationix/nvm/v8/install.sh | bash\n```\n\n### 常用命令\n\n```\n# 显示所有信息\n\nnvm --help\n\n# 显示当前安装的nvm版本\n\nnvm --version\n\n# 安装指定的版本，如果不存在.nvmrc,就从指定的资源下载安装\n\nnvm install [-s] <version>\n\n# 安装指定的版本，平且下载最新的npm\n\nnvm install [-s] <version>  -latest-npm\n\n# 卸载指定的版本\n\nnvm uninstall <version>\n\n# 使用已经安装的版本  切换版本\n\nnvm use [--silent] <version>\n\n# 查看当前使用的node版本\n\nnvm current\n\n# 查看已经安装的版本\n\nnvm ls\n\n# 查看指定版本\n\nnvm ls  <version>\n\n# 显示远程所有可以安装的nodejs版本\n\nnvm ls-remote\n\n# 查看长期支持的版本\n\nnvm ls-remote --lts\n\n# 安装罪行的npm\n\nnvm install-latest-npm\n\n# 重新安装指定的版本\n\nnvm reinstall-packages <version>\n\n# 显示nvm的cache\n\nnvm cache dir\n\n# 清空nvm的cache\n\nnvm cache clear\n```\n","slug":"Node/Nvm管理工具","published":1,"updated":"2023-02-21T09:35:15.105Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iuln000ibkh0h76m9crn","content":"<h2 id=\"NVM\"><a href=\"#NVM\" class=\"headerlink\" title=\"NVM\"></a>NVM</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><blockquote>\n<p>Linux 安装</p>\n</blockquote>\n<pre><code>wget -qO- https://raw.githubusercontent.com/creationix/nvm/v1/install.sh | bash\n\nsource ~/.bashrc\n</code></pre>\n<blockquote>\n<p>MacOS 安装</p>\n</blockquote>\n<pre><code>curl -0- https://raw.githubusercontent.com/creationix/nvm/v8/install.sh | bash\n</code></pre>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><pre><code># 显示所有信息\n\nnvm --help\n\n# 显示当前安装的nvm版本\n\nnvm --version\n\n# 安装指定的版本，如果不存在.nvmrc,就从指定的资源下载安装\n\nnvm install [-s] &lt;version&gt;\n\n# 安装指定的版本，平且下载最新的npm\n\nnvm install [-s] &lt;version&gt;  -latest-npm\n\n# 卸载指定的版本\n\nnvm uninstall &lt;version&gt;\n\n# 使用已经安装的版本  切换版本\n\nnvm use [--silent] &lt;version&gt;\n\n# 查看当前使用的node版本\n\nnvm current\n\n# 查看已经安装的版本\n\nnvm ls\n\n# 查看指定版本\n\nnvm ls  &lt;version&gt;\n\n# 显示远程所有可以安装的nodejs版本\n\nnvm ls-remote\n\n# 查看长期支持的版本\n\nnvm ls-remote --lts\n\n# 安装罪行的npm\n\nnvm install-latest-npm\n\n# 重新安装指定的版本\n\nnvm reinstall-packages &lt;version&gt;\n\n# 显示nvm的cache\n\nnvm cache dir\n\n# 清空nvm的cache\n\nnvm cache clear\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"NVM\"><a href=\"#NVM\" class=\"headerlink\" title=\"NVM\"></a>NVM</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><blockquote>\n<p>Linux 安装</p>\n</blockquote>\n<pre><code>wget -qO- https://raw.githubusercontent.com/creationix/nvm/v1/install.sh | bash\n\nsource ~/.bashrc\n</code></pre>\n<blockquote>\n<p>MacOS 安装</p>\n</blockquote>\n<pre><code>curl -0- https://raw.githubusercontent.com/creationix/nvm/v8/install.sh | bash\n</code></pre>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><pre><code># 显示所有信息\n\nnvm --help\n\n# 显示当前安装的nvm版本\n\nnvm --version\n\n# 安装指定的版本，如果不存在.nvmrc,就从指定的资源下载安装\n\nnvm install [-s] &lt;version&gt;\n\n# 安装指定的版本，平且下载最新的npm\n\nnvm install [-s] &lt;version&gt;  -latest-npm\n\n# 卸载指定的版本\n\nnvm uninstall &lt;version&gt;\n\n# 使用已经安装的版本  切换版本\n\nnvm use [--silent] &lt;version&gt;\n\n# 查看当前使用的node版本\n\nnvm current\n\n# 查看已经安装的版本\n\nnvm ls\n\n# 查看指定版本\n\nnvm ls  &lt;version&gt;\n\n# 显示远程所有可以安装的nodejs版本\n\nnvm ls-remote\n\n# 查看长期支持的版本\n\nnvm ls-remote --lts\n\n# 安装罪行的npm\n\nnvm install-latest-npm\n\n# 重新安装指定的版本\n\nnvm reinstall-packages &lt;version&gt;\n\n# 显示nvm的cache\n\nnvm cache dir\n\n# 清空nvm的cache\n\nnvm cache clear\n</code></pre>\n"},{"title":"Npm和Package描述文件","date":"2023-02-06T09:21:24.000Z","_content":"\n# npm 和 package.json\n\nnpm 是一个包管理器，它让 JavaScript 开发者分享、复用代码更方便。一个网站里通常有几十甚至上百个 package，分散在各处，通常会将这些包按照各自的功能进行划分（类似我们安卓开发中的划分子模块），但是如果重复造一些轮子，不如上传到一个公共平台，让更多的人一起使用、参与这个特定功能的模块。\n\n管理本地安装 npm 包的最好方式就是创建 package.json 文件。\n\n一个 package.json 文件可以有以下几点作用：\n\n-   作为一个描述文件，描述了你的项目依赖哪些包\n-   允许我们使用 “语义化版本规则”（后面介绍）指明你项目依赖包的版本\n-   让你的构建更好地与其他开发者分享，便于重复使用\n\n## npm 安装\n\nnpm 是依附于 node.js 的，我们可以去它的官网 <https://nodejs.org/en/download/> 下载安装 node.js。\n\n```js\nnode - v;\nnpm - v;\n```\n\n## npm 更新\n\n```js\nnpm install npm@latest -g\n```\n\n## npm 创建 package.json 文件\n\n```js\nnpm init --yes // 跳过问题\n```\n\npackage.json\n\n-   name 全部小写，没有空格，可以使用下划线或者横线\n-   version x.x.x 的格式符合“语义化版本规则”\n-   description：描述信息，有助于搜索\n-   main: 入口文件，一般都是 index.js\n-   scripts：支持的脚本，默认是一个空的 test\n-   keywords：关键字，有助于在人们使用 npm search 搜索时发现你的项目\n-   author：作者信息\n-   license：默认是 MIT\n-   bugs：当前项目的一些错误信息，如果有的话\n-   dependencies：在生产环境中需要用到的依赖\n-   devDependencies：在开发、测试环境中用到的依赖\n\n## npm 安装本地包\n\ndependencies\n\n```js\nnpm install <package_name>\nor\nnpm install <package_name> --save\n```\n\ndevDependencies：在开发、测试环境中用到的依赖\n\n```js\nnpm install <package_name> --save-dev\n```\n\n### 安装指定版本包\n\n```js\nnpm install nuxt@latest\nnpm install nuxt@3.0.0\nnpm install nuxt@\">=3.0.0 <3.2.0\"\n```\n\n### 更新本地包\n\n```js\nnpm outdated // 查看是否有新版本\nnpm update // 更新所有包版本\nnpm update <package_name> // 更新某个包版本\n```\n\nnpm update 的工作过程\n\n1. 先到远程仓库查询最新版本\n2. 然后对比本地版本，如果本地版本不存在，或者远程版本较新\n3. 查看 package.json 中对应的语义版本规则\n4. 如果当前新版本符合语义规则，就更新，否则不更新\n\n### 拆卸本地包\n\n```js\nnpm uninstall <package_name>\n```\n\n## npm 全局包管理\n\n```js\nnpm install <package_name> -g // 全局安装一个包\nnpm outdated -g --depth=0 // 全局检测包版本\nnpm update <package_name> -g // 全局更新一个包\nnpm uninstall <package_name> -g // 全局删除一个包\n```\n","source":"_posts/Npm/Npm和Package描述文件.md","raw":"---\ntitle: Npm和Package描述文件\ndate: 2023-02-06 17:21:24\ntags: npm\n---\n\n# npm 和 package.json\n\nnpm 是一个包管理器，它让 JavaScript 开发者分享、复用代码更方便。一个网站里通常有几十甚至上百个 package，分散在各处，通常会将这些包按照各自的功能进行划分（类似我们安卓开发中的划分子模块），但是如果重复造一些轮子，不如上传到一个公共平台，让更多的人一起使用、参与这个特定功能的模块。\n\n管理本地安装 npm 包的最好方式就是创建 package.json 文件。\n\n一个 package.json 文件可以有以下几点作用：\n\n-   作为一个描述文件，描述了你的项目依赖哪些包\n-   允许我们使用 “语义化版本规则”（后面介绍）指明你项目依赖包的版本\n-   让你的构建更好地与其他开发者分享，便于重复使用\n\n## npm 安装\n\nnpm 是依附于 node.js 的，我们可以去它的官网 <https://nodejs.org/en/download/> 下载安装 node.js。\n\n```js\nnode - v;\nnpm - v;\n```\n\n## npm 更新\n\n```js\nnpm install npm@latest -g\n```\n\n## npm 创建 package.json 文件\n\n```js\nnpm init --yes // 跳过问题\n```\n\npackage.json\n\n-   name 全部小写，没有空格，可以使用下划线或者横线\n-   version x.x.x 的格式符合“语义化版本规则”\n-   description：描述信息，有助于搜索\n-   main: 入口文件，一般都是 index.js\n-   scripts：支持的脚本，默认是一个空的 test\n-   keywords：关键字，有助于在人们使用 npm search 搜索时发现你的项目\n-   author：作者信息\n-   license：默认是 MIT\n-   bugs：当前项目的一些错误信息，如果有的话\n-   dependencies：在生产环境中需要用到的依赖\n-   devDependencies：在开发、测试环境中用到的依赖\n\n## npm 安装本地包\n\ndependencies\n\n```js\nnpm install <package_name>\nor\nnpm install <package_name> --save\n```\n\ndevDependencies：在开发、测试环境中用到的依赖\n\n```js\nnpm install <package_name> --save-dev\n```\n\n### 安装指定版本包\n\n```js\nnpm install nuxt@latest\nnpm install nuxt@3.0.0\nnpm install nuxt@\">=3.0.0 <3.2.0\"\n```\n\n### 更新本地包\n\n```js\nnpm outdated // 查看是否有新版本\nnpm update // 更新所有包版本\nnpm update <package_name> // 更新某个包版本\n```\n\nnpm update 的工作过程\n\n1. 先到远程仓库查询最新版本\n2. 然后对比本地版本，如果本地版本不存在，或者远程版本较新\n3. 查看 package.json 中对应的语义版本规则\n4. 如果当前新版本符合语义规则，就更新，否则不更新\n\n### 拆卸本地包\n\n```js\nnpm uninstall <package_name>\n```\n\n## npm 全局包管理\n\n```js\nnpm install <package_name> -g // 全局安装一个包\nnpm outdated -g --depth=0 // 全局检测包版本\nnpm update <package_name> -g // 全局更新一个包\nnpm uninstall <package_name> -g // 全局删除一个包\n```\n","slug":"Npm/Npm和Package描述文件","published":1,"updated":"2023-02-21T09:35:15.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iulq000kbkh0fh7d0jkj","content":"<h1 id=\"npm-和-package-json\"><a href=\"#npm-和-package-json\" class=\"headerlink\" title=\"npm 和 package.json\"></a>npm 和 package.json</h1><p>npm 是一个包管理器，它让 JavaScript 开发者分享、复用代码更方便。一个网站里通常有几十甚至上百个 package，分散在各处，通常会将这些包按照各自的功能进行划分（类似我们安卓开发中的划分子模块），但是如果重复造一些轮子，不如上传到一个公共平台，让更多的人一起使用、参与这个特定功能的模块。</p>\n<p>管理本地安装 npm 包的最好方式就是创建 package.json 文件。</p>\n<p>一个 package.json 文件可以有以下几点作用：</p>\n<ul>\n<li>作为一个描述文件，描述了你的项目依赖哪些包</li>\n<li>允许我们使用 “语义化版本规则”（后面介绍）指明你项目依赖包的版本</li>\n<li>让你的构建更好地与其他开发者分享，便于重复使用</li>\n</ul>\n<h2 id=\"npm-安装\"><a href=\"#npm-安装\" class=\"headerlink\" title=\"npm 安装\"></a>npm 安装</h2><p>npm 是依附于 node.js 的，我们可以去它的官网 <a href=\"https://nodejs.org/en/download/\">https://nodejs.org/en/download/</a> 下载安装 node.js。</p>\n<pre><code class=\"js\">node - v;\nnpm - v;\n</code></pre>\n<h2 id=\"npm-更新\"><a href=\"#npm-更新\" class=\"headerlink\" title=\"npm 更新\"></a>npm 更新</h2><pre><code class=\"js\">npm install npm@latest -g\n</code></pre>\n<h2 id=\"npm-创建-package-json-文件\"><a href=\"#npm-创建-package-json-文件\" class=\"headerlink\" title=\"npm 创建 package.json 文件\"></a>npm 创建 package.json 文件</h2><pre><code class=\"js\">npm init --yes // 跳过问题\n</code></pre>\n<p>package.json</p>\n<ul>\n<li>name 全部小写，没有空格，可以使用下划线或者横线</li>\n<li>version x.x.x 的格式符合“语义化版本规则”</li>\n<li>description：描述信息，有助于搜索</li>\n<li>main: 入口文件，一般都是 index.js</li>\n<li>scripts：支持的脚本，默认是一个空的 test</li>\n<li>keywords：关键字，有助于在人们使用 npm search 搜索时发现你的项目</li>\n<li>author：作者信息</li>\n<li>license：默认是 MIT</li>\n<li>bugs：当前项目的一些错误信息，如果有的话</li>\n<li>dependencies：在生产环境中需要用到的依赖</li>\n<li>devDependencies：在开发、测试环境中用到的依赖</li>\n</ul>\n<h2 id=\"npm-安装本地包\"><a href=\"#npm-安装本地包\" class=\"headerlink\" title=\"npm 安装本地包\"></a>npm 安装本地包</h2><p>dependencies</p>\n<pre><code class=\"js\">npm install &lt;package_name&gt;\nor\nnpm install &lt;package_name&gt; --save\n</code></pre>\n<p>devDependencies：在开发、测试环境中用到的依赖</p>\n<pre><code class=\"js\">npm install &lt;package_name&gt; --save-dev\n</code></pre>\n<h3 id=\"安装指定版本包\"><a href=\"#安装指定版本包\" class=\"headerlink\" title=\"安装指定版本包\"></a>安装指定版本包</h3><pre><code class=\"js\">npm install nuxt@latest\nnpm install nuxt@3.0.0\nnpm install nuxt@&quot;&gt;=3.0.0 &lt;3.2.0&quot;\n</code></pre>\n<h3 id=\"更新本地包\"><a href=\"#更新本地包\" class=\"headerlink\" title=\"更新本地包\"></a>更新本地包</h3><pre><code class=\"js\">npm outdated // 查看是否有新版本\nnpm update // 更新所有包版本\nnpm update &lt;package_name&gt; // 更新某个包版本\n</code></pre>\n<p>npm update 的工作过程</p>\n<ol>\n<li>先到远程仓库查询最新版本</li>\n<li>然后对比本地版本，如果本地版本不存在，或者远程版本较新</li>\n<li>查看 package.json 中对应的语义版本规则</li>\n<li>如果当前新版本符合语义规则，就更新，否则不更新</li>\n</ol>\n<h3 id=\"拆卸本地包\"><a href=\"#拆卸本地包\" class=\"headerlink\" title=\"拆卸本地包\"></a>拆卸本地包</h3><pre><code class=\"js\">npm uninstall &lt;package_name&gt;\n</code></pre>\n<h2 id=\"npm-全局包管理\"><a href=\"#npm-全局包管理\" class=\"headerlink\" title=\"npm 全局包管理\"></a>npm 全局包管理</h2><pre><code class=\"js\">npm install &lt;package_name&gt; -g // 全局安装一个包\nnpm outdated -g --depth=0 // 全局检测包版本\nnpm update &lt;package_name&gt; -g // 全局更新一个包\nnpm uninstall &lt;package_name&gt; -g // 全局删除一个包\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"npm-和-package-json\"><a href=\"#npm-和-package-json\" class=\"headerlink\" title=\"npm 和 package.json\"></a>npm 和 package.json</h1><p>npm 是一个包管理器，它让 JavaScript 开发者分享、复用代码更方便。一个网站里通常有几十甚至上百个 package，分散在各处，通常会将这些包按照各自的功能进行划分（类似我们安卓开发中的划分子模块），但是如果重复造一些轮子，不如上传到一个公共平台，让更多的人一起使用、参与这个特定功能的模块。</p>\n<p>管理本地安装 npm 包的最好方式就是创建 package.json 文件。</p>\n<p>一个 package.json 文件可以有以下几点作用：</p>\n<ul>\n<li>作为一个描述文件，描述了你的项目依赖哪些包</li>\n<li>允许我们使用 “语义化版本规则”（后面介绍）指明你项目依赖包的版本</li>\n<li>让你的构建更好地与其他开发者分享，便于重复使用</li>\n</ul>\n<h2 id=\"npm-安装\"><a href=\"#npm-安装\" class=\"headerlink\" title=\"npm 安装\"></a>npm 安装</h2><p>npm 是依附于 node.js 的，我们可以去它的官网 <a href=\"https://nodejs.org/en/download/\">https://nodejs.org/en/download/</a> 下载安装 node.js。</p>\n<pre><code class=\"js\">node - v;\nnpm - v;\n</code></pre>\n<h2 id=\"npm-更新\"><a href=\"#npm-更新\" class=\"headerlink\" title=\"npm 更新\"></a>npm 更新</h2><pre><code class=\"js\">npm install npm@latest -g\n</code></pre>\n<h2 id=\"npm-创建-package-json-文件\"><a href=\"#npm-创建-package-json-文件\" class=\"headerlink\" title=\"npm 创建 package.json 文件\"></a>npm 创建 package.json 文件</h2><pre><code class=\"js\">npm init --yes // 跳过问题\n</code></pre>\n<p>package.json</p>\n<ul>\n<li>name 全部小写，没有空格，可以使用下划线或者横线</li>\n<li>version x.x.x 的格式符合“语义化版本规则”</li>\n<li>description：描述信息，有助于搜索</li>\n<li>main: 入口文件，一般都是 index.js</li>\n<li>scripts：支持的脚本，默认是一个空的 test</li>\n<li>keywords：关键字，有助于在人们使用 npm search 搜索时发现你的项目</li>\n<li>author：作者信息</li>\n<li>license：默认是 MIT</li>\n<li>bugs：当前项目的一些错误信息，如果有的话</li>\n<li>dependencies：在生产环境中需要用到的依赖</li>\n<li>devDependencies：在开发、测试环境中用到的依赖</li>\n</ul>\n<h2 id=\"npm-安装本地包\"><a href=\"#npm-安装本地包\" class=\"headerlink\" title=\"npm 安装本地包\"></a>npm 安装本地包</h2><p>dependencies</p>\n<pre><code class=\"js\">npm install &lt;package_name&gt;\nor\nnpm install &lt;package_name&gt; --save\n</code></pre>\n<p>devDependencies：在开发、测试环境中用到的依赖</p>\n<pre><code class=\"js\">npm install &lt;package_name&gt; --save-dev\n</code></pre>\n<h3 id=\"安装指定版本包\"><a href=\"#安装指定版本包\" class=\"headerlink\" title=\"安装指定版本包\"></a>安装指定版本包</h3><pre><code class=\"js\">npm install nuxt@latest\nnpm install nuxt@3.0.0\nnpm install nuxt@&quot;&gt;=3.0.0 &lt;3.2.0&quot;\n</code></pre>\n<h3 id=\"更新本地包\"><a href=\"#更新本地包\" class=\"headerlink\" title=\"更新本地包\"></a>更新本地包</h3><pre><code class=\"js\">npm outdated // 查看是否有新版本\nnpm update // 更新所有包版本\nnpm update &lt;package_name&gt; // 更新某个包版本\n</code></pre>\n<p>npm update 的工作过程</p>\n<ol>\n<li>先到远程仓库查询最新版本</li>\n<li>然后对比本地版本，如果本地版本不存在，或者远程版本较新</li>\n<li>查看 package.json 中对应的语义版本规则</li>\n<li>如果当前新版本符合语义规则，就更新，否则不更新</li>\n</ol>\n<h3 id=\"拆卸本地包\"><a href=\"#拆卸本地包\" class=\"headerlink\" title=\"拆卸本地包\"></a>拆卸本地包</h3><pre><code class=\"js\">npm uninstall &lt;package_name&gt;\n</code></pre>\n<h2 id=\"npm-全局包管理\"><a href=\"#npm-全局包管理\" class=\"headerlink\" title=\"npm 全局包管理\"></a>npm 全局包管理</h2><pre><code class=\"js\">npm install &lt;package_name&gt; -g // 全局安装一个包\nnpm outdated -g --depth=0 // 全局检测包版本\nnpm update &lt;package_name&gt; -g // 全局更新一个包\nnpm uninstall &lt;package_name&gt; -g // 全局删除一个包\n</code></pre>\n"},{"title":"Npm描述文件","date":"2023-02-08T03:30:18.000Z","_content":"\n## NPM 包描述文件\n\n> `npm` 即 npde package module\n\n> CommonJS 的包规范的定义由 `包结构` 和 `包描述文件` 两个部分组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。\n\n### 包结构\n\n> 包实际上是一个存档文件，即一个目录直接打包为 `.zip` 或 `.tar.gz` 格式的文件，安装后解压还原为目录。完全符合 CommonJS 规范的包目录应该包含如下这些文件。\n\n-   `package.json`：包描述文件\n-   `bin`：用于存放二进制文件的目录\n-   `lib`：用于存放 JavaScript 代码的目录\n-   `doc`：用于存放文档的目录\n-   `test`：用于存放单元测试用例的代码\n\n### 包描述文件\n\n> 包描述文件用于表达非代码相关的信息，它是一个 JSON 格式的文件，位于包的根目录下。NPM 的所有行为都与包描述文件的字段息息相关。\n\n> CommonJS 的包规范：\n\n-   `name`：包名。由小写的字母和数字组成，可以包含 `.`、`_` 被 `-`，但不允许出现空格。\n-   `descript`：包简介。\n-   `version`：版本号。语义化的版本号，详细定义参看 http://semver.org\n-   `keywords`：关键词数组，用于分类搜索。\n-   `maintainers`：包维护者列表。每个维护者由 name、email 和 web 这三个属性组成。\n-   `contributors`：贡献者列表。\n-   `bugs`：用于反馈 BUG 的网页地址或邮件地址\n-   `licenses`：许可证列表。\n-   `repositories`：托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码\n-   `dependencies`：包所需要的依赖的包列表\n-   `devDependencies`：开发时所需要的依赖列表。\n-   `peerDependencies`：\n\n> `其他可选字段`\n\n-   `homepage`：当前包的网站地址\n-   `os`：操作系统支持列表。\n-   `cpu`：CPU 架构的支持列表\n-   `engine`：支持的 JavaScript 引擎列表\n-   `builtin`：标识当前包是否是内建在底层系统的标准组件\n-   `directories`：包目录说明\n-   `implements`：实现规范的列表\n-   `scripts`：脚本说明对象。主要被包管理器用于安装、编译、测试和卸载包。\n\n> NPM 包规范额外的字段：\n\n-   `author`：包作者\n-   `bin`：一些包作者希望包可以作为命令行工具使用。配置好 bin 字段后，通过\n\n    ```\n    npm install package_name -g\n    ```\n\n    命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行\n\n-   `main`：模块引入方法 `require()` 在引入包的时，会优先检查这个字段，并将其作为保重其余模块的入口\n\n### 必备属性\n\n### name\n\n> `name` 字段定义了模块的名称，其命名时需要遵循官方的一些规范和建议：\n\n-   模块名会成为模块 URL、命令行中的一个参数或者一个文件夹名称，任何非 URL 安全的字符在模块名中都不能使用（我们可以使用 validate-npm-package-name 包来检测模块名是否合法）；\n-   语义化模块名，可以帮助开发者更快的找到需要的模块，并且避免意外获取错误的模块；\n-   若模块名称中存在一些符号，将符号去除后不得与现有的模块名重复，例如：由于 `react-router-dom` 已经存在，`react.router.dom`、`reactrouterdom` 都不可以再创建。\n\n> `name` 字段不能与其他模块名重复，我们可以执行以下命令查看模块名是否已经被使用：\n\n```\nnpm view <package-name>\n```\n\n-   如果模块存在，可以查看该模块的基本信息\n-   如果该模块名称未被使用过，则会抛出 404 错误\n\n### version\n\n> `npm` 包中的模块版本都需要遵循 SemVer 规范，相关介绍可查阅 npm 版本控制\n\n### 描述信息\n\n### description & keywords\n\n> `description` 字段用于添加模块的描述信息，便于用户了解该模块。\n\n> `keywords` 字段用于给模块添加关键字。\n\n> 当我们使用 npm 检索模块时，会对模块中的 `description` 字段和 `keywords` 字段进行匹配，写好 `package.json` 中的 `description` 和 `keywords` 将有利于增加我们模块的曝光率。\n\n### author\n\n> `author` 字段用于描述主要作者。\n\n### contributors\n\n> `contributors` 字段用于描述贡献者。\n\n### homepage\n\n> `homepage` 字段用于描述项目的主页。\n\n### repository\n\n> `repository` 字段用于描述模块的代码仓库。\n\n### bugs\n\n> `repository` 字段用于描述提交 BUG 的地址。\n\n### 依赖配置\n\n### dependencies\n\n> `dependencies` 字段指定了项目生产环境运行所依赖的模块（生产环境使用），如 `antd`、`react`、`moment` 等依赖库：\n\n-   它们是我们生产环境所需要的依赖项，在把项目作为一个 `npm` 包的时候，用户安装 `npm` 包时只会安装 `dependencies` 里面的依赖。\n\n### devDepenedencies\n\n> `devDependencies` 字段指定了项目开发所需要的模块（开发环境使用），如 `webpack`、`typescript`、`babel` 等：\n\n-   在代码打包提交线上时，我们并不需要这些依赖包，所以我们将它放入 `devDependencies` 中。\n\n### peerDepenencies\n\n> `peerDependencies` 字段的目的是提示宿主环境去安装满足插件 `peerDependencies` 所指定依赖的包，然后在插件 `import` 或者 `require` 所依赖的包的时候，永远都是引用宿主环境统一安装的 `npm` 包，最终解决插件与所依赖包不一致的问题。\n\n> 举个例子，就拿目前基于 React 的 UI 组件库 `ant-design@4.x` 来说，因该 UI 组件库只是提供一套 React 组件库，它要求宿主环境需要安装指定的 React 版本。具体可以看它 `package.json` 中的配置：\n\n```\n{\n\n  \"peerDependencies\": {\n\n    \"react\": \">=0\",\n\n    \"react-dom\": \">=0\"\n\n  }\n\n}\n```\n\n> 它要求宿主环境安装 `react@>=16.9.0` 和 `react-dom@>=16.9.0` 的版本，而在每个 `antd` 组件的定义文件顶部：\n\n```\nimport * as React from 'react';\n\nimport * as ReactDOM from 'react-dom';\n```\n\n> 组件中引入的 `react` 和 `react-dom` 包其实都是宿主环境提供的依赖包。\n\n> 有了 `package.json` 文件，开发直接使用 `npm install` / `yarn install` 命令，就会在当前目录中自动安装所需要的模块，安装完成项目所需的运行和开发环境就配置好了。\n\n### optionalDependencies\n\n> 不阻断安装依赖\n\n### bundledDependencies\n\n> 打包依赖\n\n### 目录文件\n\n### main\n\n> `main` 字段是 `package.json` 中的另一种元数据功能，它可以用来指定加载的入口文件。假如你的项目是一个 `npm` 包，当用户安装你的包后，`require(my-module)` 返回的是 `main` 字段中所列出文件的 `module.exports` 属性。\n\n> 当不指定 `main` 字段时，默认值是模块根目录下面的 `index.js` 文件。\n\n### bin\n\n> 用过 `vue-cli` 或 `create-react-app` 等脚手架的朋友们，不知道你们有没有好奇过，为什么安装这些脚手架后，就可以使用类似 `vue create`/`create-react-app` 之类的命令，其实这和 `package.json` 中的 `bin` 字段有关。\n\n> `bin` 字段用来指定各个内部命令对应的可执行文件的位置。当 `package.json` 提供了 `bin` 字段后，即相当于做了一个命令名和本地文件名的映射。\n\n> 当用户安装带有 `bin` 字段的包时，\n\n-   如果是全局安装，`npm` 将会使用符号链接把这些文件链接到\n\n    ```\n    /usr/local/node_modules/.bin/\n    ```\n\n-   如果是本地安装，会链接到 `./node_modules/.bin/`\n\n> 举个例子，如果要使用 `my-app-cli` 作为命令时，可以配置以下 `bin` 字段：\n\n```\n{\n\n  \"bin\": {\n\n    \"my-app-cli\": \"./bin/cli.js\"\n\n  }\n\n}\n```\n\n> 上面代码指定，`my-app-cli` 命令对应的可执行文件为 `bin` 子目录下的 `cli.js`，因此在安装了 `my-app-cli` 包的项目中，就可以很方便地利用 `npm` 执行脚本：\n\n```\n{\n\n  \"scripts\": {\n\n    \"start\": \"node node_modules/.bin/my-app-cli\"\n\n  }\n\n}\n```\n\n> 咦，怎么看起来和 `vue create`/c`reate-react-app` 之类的命令不太像？原因：\n\n-   当需要 `node` 环境时就需要加上 `node` 前缀\n-   如果加上 `node` 前缀，就需要指定 `my-app-cli` 的路径 -> `node_modules/.bin`，否则 `node my-app-cli` 会去查找当前路径下的 `my-app-cli.js`，这样肯定是不对。\n\n> 若要实现像 `vue create`/`create-react-app` 之类的命令一样简便的方式，则可以在上文提到的 `bin` 子目录下可执行文件 `cli.js` 中的第一行写入以下命令：\n\n```\n#!/usr/bin/env node\n```\n\n> 这行命令的作用是告诉系统用 `node` 解析，这样命令就可以简写成 `my-app-cli` 了。\n\n### files\n\n> `files` 字段用于描述我们使用 `npm publish` 命令后推送到 `npm` 服务器的文件列表，如果指定文件夹，则文件夹内的所有内容都会包含进来。\n\n> 我们可以查看下载的 `antd` 的 `package.json` 的 `files` 字段，内容如下：\n\n```\n{\n\n  \"files\": [\"dist\", \"lib\", \"es\"]\n\n}\n```\n\n> 另外，我们还可以通过配置一个 `.npmignore` 文件来排除一些文件， 防止大量的垃圾文件推送到 npm 上。\n\n### man\n\n### directories\n\n### 脚本配置\n\n### script\n\n> `scripts` 字段是 `package.json` 中的一种元数据功能，它接受一个对象，对象的属性为可以通过 `npm run` 运行的脚本，值为实际运行的命令（通常是终端命令），如：\n\n```\n{\n\n  \"scripts\": {\n\n    \"start\": \"node index.js\"\n\n  }\n\n}\n```\n\n> 将终端命令放入 `scripts` 字段，既可以记录它们又可以实现轻松重用。\n\n### config\n\n### 发布配置\n\n### private\n\n> 一般公司的非开源项目，都会设置 `private` 属性的值为 `true`，这是因为 `npm` 拒绝发布私有模块，通过设置该字段可以防止私有模块被无意间发布出去。\n\n### preferGlobal\n\n### publishConfig\n\n### os\n\n> 假如我们开发了一个模块，只能跑在 `darwin` 系统下，我们需要保证 `windows` 用户不会安装到该模块，从而避免发生不必要的错误。\n\n> 这时候，使用 `os` 属性则可以帮助我们实现以上的需求，该属性可以指定模块适用系统的系统，或者指定不能安装的系统黑名单（当在系统黑名单中的系统中安装模块则会报错）：\n\n```\n{\n\n  // 适用系统\n\n  \"os\": [\"darwin\", \"linux\"],\n\n  // 黑名单\n\n  \"os\": [\"!win32\"]\n\n}\n```\n\n> > Tips：在 node 环境下可以使用 `process.platform` 来判断操作系统。\n\n### cpu\n\n> 和上面的 `os` 字段类似，我们可以用 `cpu` 字段更精准的限制用户安装环境：\n\n```\n{\n\n  // 适用 CPU\n\n  \"cpu\": [\"x64\", \"ia32\"],\n\n  // 黑名单\n\n  \"cpu\": [\"!arm\", \"!mips\"]\n\n}\n```\n\n> > Tips：在 node 环境下可以使用 `process.arch` 来判断 cpu 架构。\n\n### engines\n\n> 有时候，新拉一个项目的时候，由于和其他开发使用的 `node` 版本不同，导致会出现很多奇奇怪怪的问题（如某些依赖安装报错、依赖安装完项目跑步起来等）。\n\n> 为了实现项目开箱即用的伟大理想，这时候可以使用 `package.json` 的 `engines` 字段来指定项目 `node` 版本：\n\n```\n{\n\n  \"engines\": {\n\n    \"node\": \">=0\"\n\n  }\n\n}\n```\n\n> 该字段也可以指定适用的 `npm` 版本：\n\n```\n{\n\n  \"engines\": {\n\n    \"npm\": \">= 0\"\n\n  }\n\n}\n```\n\n> 需要注意的是，`engines` 属性仅起到一个说明的作用，当用户版本不符合指定值时也不影响依赖的安装。\n\n### 自定义字段\n\n> 一些第三方 npm 包，会在 package.json 中定义字段。\n\n> 例如 husky 等 pre-commit\n\n### 参考资料\n\n-   重新认识 package.json\n-   一文搞懂 peerDependencies\n","source":"_posts/Npm/Npm描述文件.md","raw":"---\ntitle: Npm描述文件\ndate: 2023-02-08 11:30:18\ntags: Npm\n---\n\n## NPM 包描述文件\n\n> `npm` 即 npde package module\n\n> CommonJS 的包规范的定义由 `包结构` 和 `包描述文件` 两个部分组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。\n\n### 包结构\n\n> 包实际上是一个存档文件，即一个目录直接打包为 `.zip` 或 `.tar.gz` 格式的文件，安装后解压还原为目录。完全符合 CommonJS 规范的包目录应该包含如下这些文件。\n\n-   `package.json`：包描述文件\n-   `bin`：用于存放二进制文件的目录\n-   `lib`：用于存放 JavaScript 代码的目录\n-   `doc`：用于存放文档的目录\n-   `test`：用于存放单元测试用例的代码\n\n### 包描述文件\n\n> 包描述文件用于表达非代码相关的信息，它是一个 JSON 格式的文件，位于包的根目录下。NPM 的所有行为都与包描述文件的字段息息相关。\n\n> CommonJS 的包规范：\n\n-   `name`：包名。由小写的字母和数字组成，可以包含 `.`、`_` 被 `-`，但不允许出现空格。\n-   `descript`：包简介。\n-   `version`：版本号。语义化的版本号，详细定义参看 http://semver.org\n-   `keywords`：关键词数组，用于分类搜索。\n-   `maintainers`：包维护者列表。每个维护者由 name、email 和 web 这三个属性组成。\n-   `contributors`：贡献者列表。\n-   `bugs`：用于反馈 BUG 的网页地址或邮件地址\n-   `licenses`：许可证列表。\n-   `repositories`：托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码\n-   `dependencies`：包所需要的依赖的包列表\n-   `devDependencies`：开发时所需要的依赖列表。\n-   `peerDependencies`：\n\n> `其他可选字段`\n\n-   `homepage`：当前包的网站地址\n-   `os`：操作系统支持列表。\n-   `cpu`：CPU 架构的支持列表\n-   `engine`：支持的 JavaScript 引擎列表\n-   `builtin`：标识当前包是否是内建在底层系统的标准组件\n-   `directories`：包目录说明\n-   `implements`：实现规范的列表\n-   `scripts`：脚本说明对象。主要被包管理器用于安装、编译、测试和卸载包。\n\n> NPM 包规范额外的字段：\n\n-   `author`：包作者\n-   `bin`：一些包作者希望包可以作为命令行工具使用。配置好 bin 字段后，通过\n\n    ```\n    npm install package_name -g\n    ```\n\n    命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行\n\n-   `main`：模块引入方法 `require()` 在引入包的时，会优先检查这个字段，并将其作为保重其余模块的入口\n\n### 必备属性\n\n### name\n\n> `name` 字段定义了模块的名称，其命名时需要遵循官方的一些规范和建议：\n\n-   模块名会成为模块 URL、命令行中的一个参数或者一个文件夹名称，任何非 URL 安全的字符在模块名中都不能使用（我们可以使用 validate-npm-package-name 包来检测模块名是否合法）；\n-   语义化模块名，可以帮助开发者更快的找到需要的模块，并且避免意外获取错误的模块；\n-   若模块名称中存在一些符号，将符号去除后不得与现有的模块名重复，例如：由于 `react-router-dom` 已经存在，`react.router.dom`、`reactrouterdom` 都不可以再创建。\n\n> `name` 字段不能与其他模块名重复，我们可以执行以下命令查看模块名是否已经被使用：\n\n```\nnpm view <package-name>\n```\n\n-   如果模块存在，可以查看该模块的基本信息\n-   如果该模块名称未被使用过，则会抛出 404 错误\n\n### version\n\n> `npm` 包中的模块版本都需要遵循 SemVer 规范，相关介绍可查阅 npm 版本控制\n\n### 描述信息\n\n### description & keywords\n\n> `description` 字段用于添加模块的描述信息，便于用户了解该模块。\n\n> `keywords` 字段用于给模块添加关键字。\n\n> 当我们使用 npm 检索模块时，会对模块中的 `description` 字段和 `keywords` 字段进行匹配，写好 `package.json` 中的 `description` 和 `keywords` 将有利于增加我们模块的曝光率。\n\n### author\n\n> `author` 字段用于描述主要作者。\n\n### contributors\n\n> `contributors` 字段用于描述贡献者。\n\n### homepage\n\n> `homepage` 字段用于描述项目的主页。\n\n### repository\n\n> `repository` 字段用于描述模块的代码仓库。\n\n### bugs\n\n> `repository` 字段用于描述提交 BUG 的地址。\n\n### 依赖配置\n\n### dependencies\n\n> `dependencies` 字段指定了项目生产环境运行所依赖的模块（生产环境使用），如 `antd`、`react`、`moment` 等依赖库：\n\n-   它们是我们生产环境所需要的依赖项，在把项目作为一个 `npm` 包的时候，用户安装 `npm` 包时只会安装 `dependencies` 里面的依赖。\n\n### devDepenedencies\n\n> `devDependencies` 字段指定了项目开发所需要的模块（开发环境使用），如 `webpack`、`typescript`、`babel` 等：\n\n-   在代码打包提交线上时，我们并不需要这些依赖包，所以我们将它放入 `devDependencies` 中。\n\n### peerDepenencies\n\n> `peerDependencies` 字段的目的是提示宿主环境去安装满足插件 `peerDependencies` 所指定依赖的包，然后在插件 `import` 或者 `require` 所依赖的包的时候，永远都是引用宿主环境统一安装的 `npm` 包，最终解决插件与所依赖包不一致的问题。\n\n> 举个例子，就拿目前基于 React 的 UI 组件库 `ant-design@4.x` 来说，因该 UI 组件库只是提供一套 React 组件库，它要求宿主环境需要安装指定的 React 版本。具体可以看它 `package.json` 中的配置：\n\n```\n{\n\n  \"peerDependencies\": {\n\n    \"react\": \">=0\",\n\n    \"react-dom\": \">=0\"\n\n  }\n\n}\n```\n\n> 它要求宿主环境安装 `react@>=16.9.0` 和 `react-dom@>=16.9.0` 的版本，而在每个 `antd` 组件的定义文件顶部：\n\n```\nimport * as React from 'react';\n\nimport * as ReactDOM from 'react-dom';\n```\n\n> 组件中引入的 `react` 和 `react-dom` 包其实都是宿主环境提供的依赖包。\n\n> 有了 `package.json` 文件，开发直接使用 `npm install` / `yarn install` 命令，就会在当前目录中自动安装所需要的模块，安装完成项目所需的运行和开发环境就配置好了。\n\n### optionalDependencies\n\n> 不阻断安装依赖\n\n### bundledDependencies\n\n> 打包依赖\n\n### 目录文件\n\n### main\n\n> `main` 字段是 `package.json` 中的另一种元数据功能，它可以用来指定加载的入口文件。假如你的项目是一个 `npm` 包，当用户安装你的包后，`require(my-module)` 返回的是 `main` 字段中所列出文件的 `module.exports` 属性。\n\n> 当不指定 `main` 字段时，默认值是模块根目录下面的 `index.js` 文件。\n\n### bin\n\n> 用过 `vue-cli` 或 `create-react-app` 等脚手架的朋友们，不知道你们有没有好奇过，为什么安装这些脚手架后，就可以使用类似 `vue create`/`create-react-app` 之类的命令，其实这和 `package.json` 中的 `bin` 字段有关。\n\n> `bin` 字段用来指定各个内部命令对应的可执行文件的位置。当 `package.json` 提供了 `bin` 字段后，即相当于做了一个命令名和本地文件名的映射。\n\n> 当用户安装带有 `bin` 字段的包时，\n\n-   如果是全局安装，`npm` 将会使用符号链接把这些文件链接到\n\n    ```\n    /usr/local/node_modules/.bin/\n    ```\n\n-   如果是本地安装，会链接到 `./node_modules/.bin/`\n\n> 举个例子，如果要使用 `my-app-cli` 作为命令时，可以配置以下 `bin` 字段：\n\n```\n{\n\n  \"bin\": {\n\n    \"my-app-cli\": \"./bin/cli.js\"\n\n  }\n\n}\n```\n\n> 上面代码指定，`my-app-cli` 命令对应的可执行文件为 `bin` 子目录下的 `cli.js`，因此在安装了 `my-app-cli` 包的项目中，就可以很方便地利用 `npm` 执行脚本：\n\n```\n{\n\n  \"scripts\": {\n\n    \"start\": \"node node_modules/.bin/my-app-cli\"\n\n  }\n\n}\n```\n\n> 咦，怎么看起来和 `vue create`/c`reate-react-app` 之类的命令不太像？原因：\n\n-   当需要 `node` 环境时就需要加上 `node` 前缀\n-   如果加上 `node` 前缀，就需要指定 `my-app-cli` 的路径 -> `node_modules/.bin`，否则 `node my-app-cli` 会去查找当前路径下的 `my-app-cli.js`，这样肯定是不对。\n\n> 若要实现像 `vue create`/`create-react-app` 之类的命令一样简便的方式，则可以在上文提到的 `bin` 子目录下可执行文件 `cli.js` 中的第一行写入以下命令：\n\n```\n#!/usr/bin/env node\n```\n\n> 这行命令的作用是告诉系统用 `node` 解析，这样命令就可以简写成 `my-app-cli` 了。\n\n### files\n\n> `files` 字段用于描述我们使用 `npm publish` 命令后推送到 `npm` 服务器的文件列表，如果指定文件夹，则文件夹内的所有内容都会包含进来。\n\n> 我们可以查看下载的 `antd` 的 `package.json` 的 `files` 字段，内容如下：\n\n```\n{\n\n  \"files\": [\"dist\", \"lib\", \"es\"]\n\n}\n```\n\n> 另外，我们还可以通过配置一个 `.npmignore` 文件来排除一些文件， 防止大量的垃圾文件推送到 npm 上。\n\n### man\n\n### directories\n\n### 脚本配置\n\n### script\n\n> `scripts` 字段是 `package.json` 中的一种元数据功能，它接受一个对象，对象的属性为可以通过 `npm run` 运行的脚本，值为实际运行的命令（通常是终端命令），如：\n\n```\n{\n\n  \"scripts\": {\n\n    \"start\": \"node index.js\"\n\n  }\n\n}\n```\n\n> 将终端命令放入 `scripts` 字段，既可以记录它们又可以实现轻松重用。\n\n### config\n\n### 发布配置\n\n### private\n\n> 一般公司的非开源项目，都会设置 `private` 属性的值为 `true`，这是因为 `npm` 拒绝发布私有模块，通过设置该字段可以防止私有模块被无意间发布出去。\n\n### preferGlobal\n\n### publishConfig\n\n### os\n\n> 假如我们开发了一个模块，只能跑在 `darwin` 系统下，我们需要保证 `windows` 用户不会安装到该模块，从而避免发生不必要的错误。\n\n> 这时候，使用 `os` 属性则可以帮助我们实现以上的需求，该属性可以指定模块适用系统的系统，或者指定不能安装的系统黑名单（当在系统黑名单中的系统中安装模块则会报错）：\n\n```\n{\n\n  // 适用系统\n\n  \"os\": [\"darwin\", \"linux\"],\n\n  // 黑名单\n\n  \"os\": [\"!win32\"]\n\n}\n```\n\n> > Tips：在 node 环境下可以使用 `process.platform` 来判断操作系统。\n\n### cpu\n\n> 和上面的 `os` 字段类似，我们可以用 `cpu` 字段更精准的限制用户安装环境：\n\n```\n{\n\n  // 适用 CPU\n\n  \"cpu\": [\"x64\", \"ia32\"],\n\n  // 黑名单\n\n  \"cpu\": [\"!arm\", \"!mips\"]\n\n}\n```\n\n> > Tips：在 node 环境下可以使用 `process.arch` 来判断 cpu 架构。\n\n### engines\n\n> 有时候，新拉一个项目的时候，由于和其他开发使用的 `node` 版本不同，导致会出现很多奇奇怪怪的问题（如某些依赖安装报错、依赖安装完项目跑步起来等）。\n\n> 为了实现项目开箱即用的伟大理想，这时候可以使用 `package.json` 的 `engines` 字段来指定项目 `node` 版本：\n\n```\n{\n\n  \"engines\": {\n\n    \"node\": \">=0\"\n\n  }\n\n}\n```\n\n> 该字段也可以指定适用的 `npm` 版本：\n\n```\n{\n\n  \"engines\": {\n\n    \"npm\": \">= 0\"\n\n  }\n\n}\n```\n\n> 需要注意的是，`engines` 属性仅起到一个说明的作用，当用户版本不符合指定值时也不影响依赖的安装。\n\n### 自定义字段\n\n> 一些第三方 npm 包，会在 package.json 中定义字段。\n\n> 例如 husky 等 pre-commit\n\n### 参考资料\n\n-   重新认识 package.json\n-   一文搞懂 peerDependencies\n","slug":"Npm/Npm描述文件","published":1,"updated":"2023-02-21T09:35:15.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iulr000mbkh07df3f5w8","content":"<h2 id=\"NPM-包描述文件\"><a href=\"#NPM-包描述文件\" class=\"headerlink\" title=\"NPM 包描述文件\"></a>NPM 包描述文件</h2><blockquote>\n<p><code>npm</code> 即 npde package module</p>\n</blockquote>\n<blockquote>\n<p>CommonJS 的包规范的定义由 <code>包结构</code> 和 <code>包描述文件</code> 两个部分组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。</p>\n</blockquote>\n<h3 id=\"包结构\"><a href=\"#包结构\" class=\"headerlink\" title=\"包结构\"></a>包结构</h3><blockquote>\n<p>包实际上是一个存档文件，即一个目录直接打包为 <code>.zip</code> 或 <code>.tar.gz</code> 格式的文件，安装后解压还原为目录。完全符合 CommonJS 规范的包目录应该包含如下这些文件。</p>\n</blockquote>\n<ul>\n<li><code>package.json</code>：包描述文件</li>\n<li><code>bin</code>：用于存放二进制文件的目录</li>\n<li><code>lib</code>：用于存放 JavaScript 代码的目录</li>\n<li><code>doc</code>：用于存放文档的目录</li>\n<li><code>test</code>：用于存放单元测试用例的代码</li>\n</ul>\n<h3 id=\"包描述文件\"><a href=\"#包描述文件\" class=\"headerlink\" title=\"包描述文件\"></a>包描述文件</h3><blockquote>\n<p>包描述文件用于表达非代码相关的信息，它是一个 JSON 格式的文件，位于包的根目录下。NPM 的所有行为都与包描述文件的字段息息相关。</p>\n</blockquote>\n<blockquote>\n<p>CommonJS 的包规范：</p>\n</blockquote>\n<ul>\n<li><code>name</code>：包名。由小写的字母和数字组成，可以包含 <code>.</code>、<code>_</code> 被 <code>-</code>，但不允许出现空格。</li>\n<li><code>descript</code>：包简介。</li>\n<li><code>version</code>：版本号。语义化的版本号，详细定义参看 <a href=\"http://semver.org/\">http://semver.org</a></li>\n<li><code>keywords</code>：关键词数组，用于分类搜索。</li>\n<li><code>maintainers</code>：包维护者列表。每个维护者由 name、email 和 web 这三个属性组成。</li>\n<li><code>contributors</code>：贡献者列表。</li>\n<li><code>bugs</code>：用于反馈 BUG 的网页地址或邮件地址</li>\n<li><code>licenses</code>：许可证列表。</li>\n<li><code>repositories</code>：托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码</li>\n<li><code>dependencies</code>：包所需要的依赖的包列表</li>\n<li><code>devDependencies</code>：开发时所需要的依赖列表。</li>\n<li><code>peerDependencies</code>：</li>\n</ul>\n<blockquote>\n<p><code>其他可选字段</code></p>\n</blockquote>\n<ul>\n<li><code>homepage</code>：当前包的网站地址</li>\n<li><code>os</code>：操作系统支持列表。</li>\n<li><code>cpu</code>：CPU 架构的支持列表</li>\n<li><code>engine</code>：支持的 JavaScript 引擎列表</li>\n<li><code>builtin</code>：标识当前包是否是内建在底层系统的标准组件</li>\n<li><code>directories</code>：包目录说明</li>\n<li><code>implements</code>：实现规范的列表</li>\n<li><code>scripts</code>：脚本说明对象。主要被包管理器用于安装、编译、测试和卸载包。</li>\n</ul>\n<blockquote>\n<p>NPM 包规范额外的字段：</p>\n</blockquote>\n<ul>\n<li><p><code>author</code>：包作者</p>\n</li>\n<li><p><code>bin</code>：一些包作者希望包可以作为命令行工具使用。配置好 bin 字段后，通过</p>\n<pre><code>npm install package_name -g\n</code></pre>\n<p>命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行</p>\n</li>\n<li><p><code>main</code>：模块引入方法 <code>require()</code> 在引入包的时，会优先检查这个字段，并将其作为保重其余模块的入口</p>\n</li>\n</ul>\n<h3 id=\"必备属性\"><a href=\"#必备属性\" class=\"headerlink\" title=\"必备属性\"></a>必备属性</h3><h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><blockquote>\n<p><code>name</code> 字段定义了模块的名称，其命名时需要遵循官方的一些规范和建议：</p>\n</blockquote>\n<ul>\n<li>模块名会成为模块 URL、命令行中的一个参数或者一个文件夹名称，任何非 URL 安全的字符在模块名中都不能使用（我们可以使用 validate-npm-package-name 包来检测模块名是否合法）；</li>\n<li>语义化模块名，可以帮助开发者更快的找到需要的模块，并且避免意外获取错误的模块；</li>\n<li>若模块名称中存在一些符号，将符号去除后不得与现有的模块名重复，例如：由于 <code>react-router-dom</code> 已经存在，<code>react.router.dom</code>、<code>reactrouterdom</code> 都不可以再创建。</li>\n</ul>\n<blockquote>\n<p><code>name</code> 字段不能与其他模块名重复，我们可以执行以下命令查看模块名是否已经被使用：</p>\n</blockquote>\n<pre><code>npm view &lt;package-name&gt;\n</code></pre>\n<ul>\n<li>如果模块存在，可以查看该模块的基本信息</li>\n<li>如果该模块名称未被使用过，则会抛出 404 错误</li>\n</ul>\n<h3 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h3><blockquote>\n<p><code>npm</code> 包中的模块版本都需要遵循 SemVer 规范，相关介绍可查阅 npm 版本控制</p>\n</blockquote>\n<h3 id=\"描述信息\"><a href=\"#描述信息\" class=\"headerlink\" title=\"描述信息\"></a>描述信息</h3><h3 id=\"description-amp-keywords\"><a href=\"#description-amp-keywords\" class=\"headerlink\" title=\"description &amp; keywords\"></a>description &amp; keywords</h3><blockquote>\n<p><code>description</code> 字段用于添加模块的描述信息，便于用户了解该模块。</p>\n</blockquote>\n<blockquote>\n<p><code>keywords</code> 字段用于给模块添加关键字。</p>\n</blockquote>\n<blockquote>\n<p>当我们使用 npm 检索模块时，会对模块中的 <code>description</code> 字段和 <code>keywords</code> 字段进行匹配，写好 <code>package.json</code> 中的 <code>description</code> 和 <code>keywords</code> 将有利于增加我们模块的曝光率。</p>\n</blockquote>\n<h3 id=\"author\"><a href=\"#author\" class=\"headerlink\" title=\"author\"></a>author</h3><blockquote>\n<p><code>author</code> 字段用于描述主要作者。</p>\n</blockquote>\n<h3 id=\"contributors\"><a href=\"#contributors\" class=\"headerlink\" title=\"contributors\"></a>contributors</h3><blockquote>\n<p><code>contributors</code> 字段用于描述贡献者。</p>\n</blockquote>\n<h3 id=\"homepage\"><a href=\"#homepage\" class=\"headerlink\" title=\"homepage\"></a>homepage</h3><blockquote>\n<p><code>homepage</code> 字段用于描述项目的主页。</p>\n</blockquote>\n<h3 id=\"repository\"><a href=\"#repository\" class=\"headerlink\" title=\"repository\"></a>repository</h3><blockquote>\n<p><code>repository</code> 字段用于描述模块的代码仓库。</p>\n</blockquote>\n<h3 id=\"bugs\"><a href=\"#bugs\" class=\"headerlink\" title=\"bugs\"></a>bugs</h3><blockquote>\n<p><code>repository</code> 字段用于描述提交 BUG 的地址。</p>\n</blockquote>\n<h3 id=\"依赖配置\"><a href=\"#依赖配置\" class=\"headerlink\" title=\"依赖配置\"></a>依赖配置</h3><h3 id=\"dependencies\"><a href=\"#dependencies\" class=\"headerlink\" title=\"dependencies\"></a>dependencies</h3><blockquote>\n<p><code>dependencies</code> 字段指定了项目生产环境运行所依赖的模块（生产环境使用），如 <code>antd</code>、<code>react</code>、<code>moment</code> 等依赖库：</p>\n</blockquote>\n<ul>\n<li>它们是我们生产环境所需要的依赖项，在把项目作为一个 <code>npm</code> 包的时候，用户安装 <code>npm</code> 包时只会安装 <code>dependencies</code> 里面的依赖。</li>\n</ul>\n<h3 id=\"devDepenedencies\"><a href=\"#devDepenedencies\" class=\"headerlink\" title=\"devDepenedencies\"></a>devDepenedencies</h3><blockquote>\n<p><code>devDependencies</code> 字段指定了项目开发所需要的模块（开发环境使用），如 <code>webpack</code>、<code>typescript</code>、<code>babel</code> 等：</p>\n</blockquote>\n<ul>\n<li>在代码打包提交线上时，我们并不需要这些依赖包，所以我们将它放入 <code>devDependencies</code> 中。</li>\n</ul>\n<h3 id=\"peerDepenencies\"><a href=\"#peerDepenencies\" class=\"headerlink\" title=\"peerDepenencies\"></a>peerDepenencies</h3><blockquote>\n<p><code>peerDependencies</code> 字段的目的是提示宿主环境去安装满足插件 <code>peerDependencies</code> 所指定依赖的包，然后在插件 <code>import</code> 或者 <code>require</code> 所依赖的包的时候，永远都是引用宿主环境统一安装的 <code>npm</code> 包，最终解决插件与所依赖包不一致的问题。</p>\n</blockquote>\n<blockquote>\n<p>举个例子，就拿目前基于 React 的 UI 组件库 <code>ant-design@4.x</code> 来说，因该 UI 组件库只是提供一套 React 组件库，它要求宿主环境需要安装指定的 React 版本。具体可以看它 <code>package.json</code> 中的配置：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;peerDependencies&quot;: &#123;\n\n    &quot;react&quot;: &quot;&gt;=0&quot;,\n\n    &quot;react-dom&quot;: &quot;&gt;=0&quot;\n\n  &#125;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>它要求宿主环境安装 <code>react@&gt;=16.9.0</code> 和 <code>react-dom@&gt;=16.9.0</code> 的版本，而在每个 <code>antd</code> 组件的定义文件顶部：</p>\n</blockquote>\n<pre><code>import * as React from &#39;react&#39;;\n\nimport * as ReactDOM from &#39;react-dom&#39;;\n</code></pre>\n<blockquote>\n<p>组件中引入的 <code>react</code> 和 <code>react-dom</code> 包其实都是宿主环境提供的依赖包。</p>\n</blockquote>\n<blockquote>\n<p>有了 <code>package.json</code> 文件，开发直接使用 <code>npm install</code> &#x2F; <code>yarn install</code> 命令，就会在当前目录中自动安装所需要的模块，安装完成项目所需的运行和开发环境就配置好了。</p>\n</blockquote>\n<h3 id=\"optionalDependencies\"><a href=\"#optionalDependencies\" class=\"headerlink\" title=\"optionalDependencies\"></a>optionalDependencies</h3><blockquote>\n<p>不阻断安装依赖</p>\n</blockquote>\n<h3 id=\"bundledDependencies\"><a href=\"#bundledDependencies\" class=\"headerlink\" title=\"bundledDependencies\"></a>bundledDependencies</h3><blockquote>\n<p>打包依赖</p>\n</blockquote>\n<h3 id=\"目录文件\"><a href=\"#目录文件\" class=\"headerlink\" title=\"目录文件\"></a>目录文件</h3><h3 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h3><blockquote>\n<p><code>main</code> 字段是 <code>package.json</code> 中的另一种元数据功能，它可以用来指定加载的入口文件。假如你的项目是一个 <code>npm</code> 包，当用户安装你的包后，<code>require(my-module)</code> 返回的是 <code>main</code> 字段中所列出文件的 <code>module.exports</code> 属性。</p>\n</blockquote>\n<blockquote>\n<p>当不指定 <code>main</code> 字段时，默认值是模块根目录下面的 <code>index.js</code> 文件。</p>\n</blockquote>\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"bin\"></a>bin</h3><blockquote>\n<p>用过 <code>vue-cli</code> 或 <code>create-react-app</code> 等脚手架的朋友们，不知道你们有没有好奇过，为什么安装这些脚手架后，就可以使用类似 <code>vue create</code>&#x2F;<code>create-react-app</code> 之类的命令，其实这和 <code>package.json</code> 中的 <code>bin</code> 字段有关。</p>\n</blockquote>\n<blockquote>\n<p><code>bin</code> 字段用来指定各个内部命令对应的可执行文件的位置。当 <code>package.json</code> 提供了 <code>bin</code> 字段后，即相当于做了一个命令名和本地文件名的映射。</p>\n</blockquote>\n<blockquote>\n<p>当用户安装带有 <code>bin</code> 字段的包时，</p>\n</blockquote>\n<ul>\n<li><p>如果是全局安装，<code>npm</code> 将会使用符号链接把这些文件链接到</p>\n<pre><code>/usr/local/node_modules/.bin/\n</code></pre>\n</li>\n<li><p>如果是本地安装，会链接到 <code>./node_modules/.bin/</code></p>\n</li>\n</ul>\n<blockquote>\n<p>举个例子，如果要使用 <code>my-app-cli</code> 作为命令时，可以配置以下 <code>bin</code> 字段：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;bin&quot;: &#123;\n\n    &quot;my-app-cli&quot;: &quot;./bin/cli.js&quot;\n\n  &#125;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>上面代码指定，<code>my-app-cli</code> 命令对应的可执行文件为 <code>bin</code> 子目录下的 <code>cli.js</code>，因此在安装了 <code>my-app-cli</code> 包的项目中，就可以很方便地利用 <code>npm</code> 执行脚本：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;scripts&quot;: &#123;\n\n    &quot;start&quot;: &quot;node node_modules/.bin/my-app-cli&quot;\n\n  &#125;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>咦，怎么看起来和 <code>vue create</code>&#x2F;c<code>reate-react-app</code> 之类的命令不太像？原因：</p>\n</blockquote>\n<ul>\n<li>当需要 <code>node</code> 环境时就需要加上 <code>node</code> 前缀</li>\n<li>如果加上 <code>node</code> 前缀，就需要指定 <code>my-app-cli</code> 的路径 -&gt; <code>node_modules/.bin</code>，否则 <code>node my-app-cli</code> 会去查找当前路径下的 <code>my-app-cli.js</code>，这样肯定是不对。</li>\n</ul>\n<blockquote>\n<p>若要实现像 <code>vue create</code>&#x2F;<code>create-react-app</code> 之类的命令一样简便的方式，则可以在上文提到的 <code>bin</code> 子目录下可执行文件 <code>cli.js</code> 中的第一行写入以下命令：</p>\n</blockquote>\n<pre><code>#!/usr/bin/env node\n</code></pre>\n<blockquote>\n<p>这行命令的作用是告诉系统用 <code>node</code> 解析，这样命令就可以简写成 <code>my-app-cli</code> 了。</p>\n</blockquote>\n<h3 id=\"files\"><a href=\"#files\" class=\"headerlink\" title=\"files\"></a>files</h3><blockquote>\n<p><code>files</code> 字段用于描述我们使用 <code>npm publish</code> 命令后推送到 <code>npm</code> 服务器的文件列表，如果指定文件夹，则文件夹内的所有内容都会包含进来。</p>\n</blockquote>\n<blockquote>\n<p>我们可以查看下载的 <code>antd</code> 的 <code>package.json</code> 的 <code>files</code> 字段，内容如下：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;files&quot;: [&quot;dist&quot;, &quot;lib&quot;, &quot;es&quot;]\n\n&#125;\n</code></pre>\n<blockquote>\n<p>另外，我们还可以通过配置一个 <code>.npmignore</code> 文件来排除一些文件， 防止大量的垃圾文件推送到 npm 上。</p>\n</blockquote>\n<h3 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h3><h3 id=\"directories\"><a href=\"#directories\" class=\"headerlink\" title=\"directories\"></a>directories</h3><h3 id=\"脚本配置\"><a href=\"#脚本配置\" class=\"headerlink\" title=\"脚本配置\"></a>脚本配置</h3><h3 id=\"script\"><a href=\"#script\" class=\"headerlink\" title=\"script\"></a>script</h3><blockquote>\n<p><code>scripts</code> 字段是 <code>package.json</code> 中的一种元数据功能，它接受一个对象，对象的属性为可以通过 <code>npm run</code> 运行的脚本，值为实际运行的命令（通常是终端命令），如：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;scripts&quot;: &#123;\n\n    &quot;start&quot;: &quot;node index.js&quot;\n\n  &#125;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>将终端命令放入 <code>scripts</code> 字段，既可以记录它们又可以实现轻松重用。</p>\n</blockquote>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h3><h3 id=\"发布配置\"><a href=\"#发布配置\" class=\"headerlink\" title=\"发布配置\"></a>发布配置</h3><h3 id=\"private\"><a href=\"#private\" class=\"headerlink\" title=\"private\"></a>private</h3><blockquote>\n<p>一般公司的非开源项目，都会设置 <code>private</code> 属性的值为 <code>true</code>，这是因为 <code>npm</code> 拒绝发布私有模块，通过设置该字段可以防止私有模块被无意间发布出去。</p>\n</blockquote>\n<h3 id=\"preferGlobal\"><a href=\"#preferGlobal\" class=\"headerlink\" title=\"preferGlobal\"></a>preferGlobal</h3><h3 id=\"publishConfig\"><a href=\"#publishConfig\" class=\"headerlink\" title=\"publishConfig\"></a>publishConfig</h3><h3 id=\"os\"><a href=\"#os\" class=\"headerlink\" title=\"os\"></a>os</h3><blockquote>\n<p>假如我们开发了一个模块，只能跑在 <code>darwin</code> 系统下，我们需要保证 <code>windows</code> 用户不会安装到该模块，从而避免发生不必要的错误。</p>\n</blockquote>\n<blockquote>\n<p>这时候，使用 <code>os</code> 属性则可以帮助我们实现以上的需求，该属性可以指定模块适用系统的系统，或者指定不能安装的系统黑名单（当在系统黑名单中的系统中安装模块则会报错）：</p>\n</blockquote>\n<pre><code>&#123;\n\n  // 适用系统\n\n  &quot;os&quot;: [&quot;darwin&quot;, &quot;linux&quot;],\n\n  // 黑名单\n\n  &quot;os&quot;: [&quot;!win32&quot;]\n\n&#125;\n</code></pre>\n<blockquote>\n<blockquote>\n<p>Tips：在 node 环境下可以使用 <code>process.platform</code> 来判断操作系统。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"cpu\"><a href=\"#cpu\" class=\"headerlink\" title=\"cpu\"></a>cpu</h3><blockquote>\n<p>和上面的 <code>os</code> 字段类似，我们可以用 <code>cpu</code> 字段更精准的限制用户安装环境：</p>\n</blockquote>\n<pre><code>&#123;\n\n  // 适用 CPU\n\n  &quot;cpu&quot;: [&quot;x64&quot;, &quot;ia32&quot;],\n\n  // 黑名单\n\n  &quot;cpu&quot;: [&quot;!arm&quot;, &quot;!mips&quot;]\n\n&#125;\n</code></pre>\n<blockquote>\n<blockquote>\n<p>Tips：在 node 环境下可以使用 <code>process.arch</code> 来判断 cpu 架构。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"engines\"><a href=\"#engines\" class=\"headerlink\" title=\"engines\"></a>engines</h3><blockquote>\n<p>有时候，新拉一个项目的时候，由于和其他开发使用的 <code>node</code> 版本不同，导致会出现很多奇奇怪怪的问题（如某些依赖安装报错、依赖安装完项目跑步起来等）。</p>\n</blockquote>\n<blockquote>\n<p>为了实现项目开箱即用的伟大理想，这时候可以使用 <code>package.json</code> 的 <code>engines</code> 字段来指定项目 <code>node</code> 版本：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;engines&quot;: &#123;\n\n    &quot;node&quot;: &quot;&gt;=0&quot;\n\n  &#125;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>该字段也可以指定适用的 <code>npm</code> 版本：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;engines&quot;: &#123;\n\n    &quot;npm&quot;: &quot;&gt;= 0&quot;\n\n  &#125;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>需要注意的是，<code>engines</code> 属性仅起到一个说明的作用，当用户版本不符合指定值时也不影响依赖的安装。</p>\n</blockquote>\n<h3 id=\"自定义字段\"><a href=\"#自定义字段\" class=\"headerlink\" title=\"自定义字段\"></a>自定义字段</h3><blockquote>\n<p>一些第三方 npm 包，会在 package.json 中定义字段。</p>\n</blockquote>\n<blockquote>\n<p>例如 husky 等 pre-commit</p>\n</blockquote>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li>重新认识 package.json</li>\n<li>一文搞懂 peerDependencies</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"NPM-包描述文件\"><a href=\"#NPM-包描述文件\" class=\"headerlink\" title=\"NPM 包描述文件\"></a>NPM 包描述文件</h2><blockquote>\n<p><code>npm</code> 即 npde package module</p>\n</blockquote>\n<blockquote>\n<p>CommonJS 的包规范的定义由 <code>包结构</code> 和 <code>包描述文件</code> 两个部分组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。</p>\n</blockquote>\n<h3 id=\"包结构\"><a href=\"#包结构\" class=\"headerlink\" title=\"包结构\"></a>包结构</h3><blockquote>\n<p>包实际上是一个存档文件，即一个目录直接打包为 <code>.zip</code> 或 <code>.tar.gz</code> 格式的文件，安装后解压还原为目录。完全符合 CommonJS 规范的包目录应该包含如下这些文件。</p>\n</blockquote>\n<ul>\n<li><code>package.json</code>：包描述文件</li>\n<li><code>bin</code>：用于存放二进制文件的目录</li>\n<li><code>lib</code>：用于存放 JavaScript 代码的目录</li>\n<li><code>doc</code>：用于存放文档的目录</li>\n<li><code>test</code>：用于存放单元测试用例的代码</li>\n</ul>\n<h3 id=\"包描述文件\"><a href=\"#包描述文件\" class=\"headerlink\" title=\"包描述文件\"></a>包描述文件</h3><blockquote>\n<p>包描述文件用于表达非代码相关的信息，它是一个 JSON 格式的文件，位于包的根目录下。NPM 的所有行为都与包描述文件的字段息息相关。</p>\n</blockquote>\n<blockquote>\n<p>CommonJS 的包规范：</p>\n</blockquote>\n<ul>\n<li><code>name</code>：包名。由小写的字母和数字组成，可以包含 <code>.</code>、<code>_</code> 被 <code>-</code>，但不允许出现空格。</li>\n<li><code>descript</code>：包简介。</li>\n<li><code>version</code>：版本号。语义化的版本号，详细定义参看 <a href=\"http://semver.org/\">http://semver.org</a></li>\n<li><code>keywords</code>：关键词数组，用于分类搜索。</li>\n<li><code>maintainers</code>：包维护者列表。每个维护者由 name、email 和 web 这三个属性组成。</li>\n<li><code>contributors</code>：贡献者列表。</li>\n<li><code>bugs</code>：用于反馈 BUG 的网页地址或邮件地址</li>\n<li><code>licenses</code>：许可证列表。</li>\n<li><code>repositories</code>：托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码</li>\n<li><code>dependencies</code>：包所需要的依赖的包列表</li>\n<li><code>devDependencies</code>：开发时所需要的依赖列表。</li>\n<li><code>peerDependencies</code>：</li>\n</ul>\n<blockquote>\n<p><code>其他可选字段</code></p>\n</blockquote>\n<ul>\n<li><code>homepage</code>：当前包的网站地址</li>\n<li><code>os</code>：操作系统支持列表。</li>\n<li><code>cpu</code>：CPU 架构的支持列表</li>\n<li><code>engine</code>：支持的 JavaScript 引擎列表</li>\n<li><code>builtin</code>：标识当前包是否是内建在底层系统的标准组件</li>\n<li><code>directories</code>：包目录说明</li>\n<li><code>implements</code>：实现规范的列表</li>\n<li><code>scripts</code>：脚本说明对象。主要被包管理器用于安装、编译、测试和卸载包。</li>\n</ul>\n<blockquote>\n<p>NPM 包规范额外的字段：</p>\n</blockquote>\n<ul>\n<li><p><code>author</code>：包作者</p>\n</li>\n<li><p><code>bin</code>：一些包作者希望包可以作为命令行工具使用。配置好 bin 字段后，通过</p>\n<pre><code>npm install package_name -g\n</code></pre>\n<p>命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行</p>\n</li>\n<li><p><code>main</code>：模块引入方法 <code>require()</code> 在引入包的时，会优先检查这个字段，并将其作为保重其余模块的入口</p>\n</li>\n</ul>\n<h3 id=\"必备属性\"><a href=\"#必备属性\" class=\"headerlink\" title=\"必备属性\"></a>必备属性</h3><h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><blockquote>\n<p><code>name</code> 字段定义了模块的名称，其命名时需要遵循官方的一些规范和建议：</p>\n</blockquote>\n<ul>\n<li>模块名会成为模块 URL、命令行中的一个参数或者一个文件夹名称，任何非 URL 安全的字符在模块名中都不能使用（我们可以使用 validate-npm-package-name 包来检测模块名是否合法）；</li>\n<li>语义化模块名，可以帮助开发者更快的找到需要的模块，并且避免意外获取错误的模块；</li>\n<li>若模块名称中存在一些符号，将符号去除后不得与现有的模块名重复，例如：由于 <code>react-router-dom</code> 已经存在，<code>react.router.dom</code>、<code>reactrouterdom</code> 都不可以再创建。</li>\n</ul>\n<blockquote>\n<p><code>name</code> 字段不能与其他模块名重复，我们可以执行以下命令查看模块名是否已经被使用：</p>\n</blockquote>\n<pre><code>npm view &lt;package-name&gt;\n</code></pre>\n<ul>\n<li>如果模块存在，可以查看该模块的基本信息</li>\n<li>如果该模块名称未被使用过，则会抛出 404 错误</li>\n</ul>\n<h3 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h3><blockquote>\n<p><code>npm</code> 包中的模块版本都需要遵循 SemVer 规范，相关介绍可查阅 npm 版本控制</p>\n</blockquote>\n<h3 id=\"描述信息\"><a href=\"#描述信息\" class=\"headerlink\" title=\"描述信息\"></a>描述信息</h3><h3 id=\"description-amp-keywords\"><a href=\"#description-amp-keywords\" class=\"headerlink\" title=\"description &amp; keywords\"></a>description &amp; keywords</h3><blockquote>\n<p><code>description</code> 字段用于添加模块的描述信息，便于用户了解该模块。</p>\n</blockquote>\n<blockquote>\n<p><code>keywords</code> 字段用于给模块添加关键字。</p>\n</blockquote>\n<blockquote>\n<p>当我们使用 npm 检索模块时，会对模块中的 <code>description</code> 字段和 <code>keywords</code> 字段进行匹配，写好 <code>package.json</code> 中的 <code>description</code> 和 <code>keywords</code> 将有利于增加我们模块的曝光率。</p>\n</blockquote>\n<h3 id=\"author\"><a href=\"#author\" class=\"headerlink\" title=\"author\"></a>author</h3><blockquote>\n<p><code>author</code> 字段用于描述主要作者。</p>\n</blockquote>\n<h3 id=\"contributors\"><a href=\"#contributors\" class=\"headerlink\" title=\"contributors\"></a>contributors</h3><blockquote>\n<p><code>contributors</code> 字段用于描述贡献者。</p>\n</blockquote>\n<h3 id=\"homepage\"><a href=\"#homepage\" class=\"headerlink\" title=\"homepage\"></a>homepage</h3><blockquote>\n<p><code>homepage</code> 字段用于描述项目的主页。</p>\n</blockquote>\n<h3 id=\"repository\"><a href=\"#repository\" class=\"headerlink\" title=\"repository\"></a>repository</h3><blockquote>\n<p><code>repository</code> 字段用于描述模块的代码仓库。</p>\n</blockquote>\n<h3 id=\"bugs\"><a href=\"#bugs\" class=\"headerlink\" title=\"bugs\"></a>bugs</h3><blockquote>\n<p><code>repository</code> 字段用于描述提交 BUG 的地址。</p>\n</blockquote>\n<h3 id=\"依赖配置\"><a href=\"#依赖配置\" class=\"headerlink\" title=\"依赖配置\"></a>依赖配置</h3><h3 id=\"dependencies\"><a href=\"#dependencies\" class=\"headerlink\" title=\"dependencies\"></a>dependencies</h3><blockquote>\n<p><code>dependencies</code> 字段指定了项目生产环境运行所依赖的模块（生产环境使用），如 <code>antd</code>、<code>react</code>、<code>moment</code> 等依赖库：</p>\n</blockquote>\n<ul>\n<li>它们是我们生产环境所需要的依赖项，在把项目作为一个 <code>npm</code> 包的时候，用户安装 <code>npm</code> 包时只会安装 <code>dependencies</code> 里面的依赖。</li>\n</ul>\n<h3 id=\"devDepenedencies\"><a href=\"#devDepenedencies\" class=\"headerlink\" title=\"devDepenedencies\"></a>devDepenedencies</h3><blockquote>\n<p><code>devDependencies</code> 字段指定了项目开发所需要的模块（开发环境使用），如 <code>webpack</code>、<code>typescript</code>、<code>babel</code> 等：</p>\n</blockquote>\n<ul>\n<li>在代码打包提交线上时，我们并不需要这些依赖包，所以我们将它放入 <code>devDependencies</code> 中。</li>\n</ul>\n<h3 id=\"peerDepenencies\"><a href=\"#peerDepenencies\" class=\"headerlink\" title=\"peerDepenencies\"></a>peerDepenencies</h3><blockquote>\n<p><code>peerDependencies</code> 字段的目的是提示宿主环境去安装满足插件 <code>peerDependencies</code> 所指定依赖的包，然后在插件 <code>import</code> 或者 <code>require</code> 所依赖的包的时候，永远都是引用宿主环境统一安装的 <code>npm</code> 包，最终解决插件与所依赖包不一致的问题。</p>\n</blockquote>\n<blockquote>\n<p>举个例子，就拿目前基于 React 的 UI 组件库 <code>ant-design@4.x</code> 来说，因该 UI 组件库只是提供一套 React 组件库，它要求宿主环境需要安装指定的 React 版本。具体可以看它 <code>package.json</code> 中的配置：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;peerDependencies&quot;: &#123;\n\n    &quot;react&quot;: &quot;&gt;=0&quot;,\n\n    &quot;react-dom&quot;: &quot;&gt;=0&quot;\n\n  &#125;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>它要求宿主环境安装 <code>react@&gt;=16.9.0</code> 和 <code>react-dom@&gt;=16.9.0</code> 的版本，而在每个 <code>antd</code> 组件的定义文件顶部：</p>\n</blockquote>\n<pre><code>import * as React from &#39;react&#39;;\n\nimport * as ReactDOM from &#39;react-dom&#39;;\n</code></pre>\n<blockquote>\n<p>组件中引入的 <code>react</code> 和 <code>react-dom</code> 包其实都是宿主环境提供的依赖包。</p>\n</blockquote>\n<blockquote>\n<p>有了 <code>package.json</code> 文件，开发直接使用 <code>npm install</code> &#x2F; <code>yarn install</code> 命令，就会在当前目录中自动安装所需要的模块，安装完成项目所需的运行和开发环境就配置好了。</p>\n</blockquote>\n<h3 id=\"optionalDependencies\"><a href=\"#optionalDependencies\" class=\"headerlink\" title=\"optionalDependencies\"></a>optionalDependencies</h3><blockquote>\n<p>不阻断安装依赖</p>\n</blockquote>\n<h3 id=\"bundledDependencies\"><a href=\"#bundledDependencies\" class=\"headerlink\" title=\"bundledDependencies\"></a>bundledDependencies</h3><blockquote>\n<p>打包依赖</p>\n</blockquote>\n<h3 id=\"目录文件\"><a href=\"#目录文件\" class=\"headerlink\" title=\"目录文件\"></a>目录文件</h3><h3 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h3><blockquote>\n<p><code>main</code> 字段是 <code>package.json</code> 中的另一种元数据功能，它可以用来指定加载的入口文件。假如你的项目是一个 <code>npm</code> 包，当用户安装你的包后，<code>require(my-module)</code> 返回的是 <code>main</code> 字段中所列出文件的 <code>module.exports</code> 属性。</p>\n</blockquote>\n<blockquote>\n<p>当不指定 <code>main</code> 字段时，默认值是模块根目录下面的 <code>index.js</code> 文件。</p>\n</blockquote>\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"bin\"></a>bin</h3><blockquote>\n<p>用过 <code>vue-cli</code> 或 <code>create-react-app</code> 等脚手架的朋友们，不知道你们有没有好奇过，为什么安装这些脚手架后，就可以使用类似 <code>vue create</code>&#x2F;<code>create-react-app</code> 之类的命令，其实这和 <code>package.json</code> 中的 <code>bin</code> 字段有关。</p>\n</blockquote>\n<blockquote>\n<p><code>bin</code> 字段用来指定各个内部命令对应的可执行文件的位置。当 <code>package.json</code> 提供了 <code>bin</code> 字段后，即相当于做了一个命令名和本地文件名的映射。</p>\n</blockquote>\n<blockquote>\n<p>当用户安装带有 <code>bin</code> 字段的包时，</p>\n</blockquote>\n<ul>\n<li><p>如果是全局安装，<code>npm</code> 将会使用符号链接把这些文件链接到</p>\n<pre><code>/usr/local/node_modules/.bin/\n</code></pre>\n</li>\n<li><p>如果是本地安装，会链接到 <code>./node_modules/.bin/</code></p>\n</li>\n</ul>\n<blockquote>\n<p>举个例子，如果要使用 <code>my-app-cli</code> 作为命令时，可以配置以下 <code>bin</code> 字段：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;bin&quot;: &#123;\n\n    &quot;my-app-cli&quot;: &quot;./bin/cli.js&quot;\n\n  &#125;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>上面代码指定，<code>my-app-cli</code> 命令对应的可执行文件为 <code>bin</code> 子目录下的 <code>cli.js</code>，因此在安装了 <code>my-app-cli</code> 包的项目中，就可以很方便地利用 <code>npm</code> 执行脚本：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;scripts&quot;: &#123;\n\n    &quot;start&quot;: &quot;node node_modules/.bin/my-app-cli&quot;\n\n  &#125;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>咦，怎么看起来和 <code>vue create</code>&#x2F;c<code>reate-react-app</code> 之类的命令不太像？原因：</p>\n</blockquote>\n<ul>\n<li>当需要 <code>node</code> 环境时就需要加上 <code>node</code> 前缀</li>\n<li>如果加上 <code>node</code> 前缀，就需要指定 <code>my-app-cli</code> 的路径 -&gt; <code>node_modules/.bin</code>，否则 <code>node my-app-cli</code> 会去查找当前路径下的 <code>my-app-cli.js</code>，这样肯定是不对。</li>\n</ul>\n<blockquote>\n<p>若要实现像 <code>vue create</code>&#x2F;<code>create-react-app</code> 之类的命令一样简便的方式，则可以在上文提到的 <code>bin</code> 子目录下可执行文件 <code>cli.js</code> 中的第一行写入以下命令：</p>\n</blockquote>\n<pre><code>#!/usr/bin/env node\n</code></pre>\n<blockquote>\n<p>这行命令的作用是告诉系统用 <code>node</code> 解析，这样命令就可以简写成 <code>my-app-cli</code> 了。</p>\n</blockquote>\n<h3 id=\"files\"><a href=\"#files\" class=\"headerlink\" title=\"files\"></a>files</h3><blockquote>\n<p><code>files</code> 字段用于描述我们使用 <code>npm publish</code> 命令后推送到 <code>npm</code> 服务器的文件列表，如果指定文件夹，则文件夹内的所有内容都会包含进来。</p>\n</blockquote>\n<blockquote>\n<p>我们可以查看下载的 <code>antd</code> 的 <code>package.json</code> 的 <code>files</code> 字段，内容如下：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;files&quot;: [&quot;dist&quot;, &quot;lib&quot;, &quot;es&quot;]\n\n&#125;\n</code></pre>\n<blockquote>\n<p>另外，我们还可以通过配置一个 <code>.npmignore</code> 文件来排除一些文件， 防止大量的垃圾文件推送到 npm 上。</p>\n</blockquote>\n<h3 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h3><h3 id=\"directories\"><a href=\"#directories\" class=\"headerlink\" title=\"directories\"></a>directories</h3><h3 id=\"脚本配置\"><a href=\"#脚本配置\" class=\"headerlink\" title=\"脚本配置\"></a>脚本配置</h3><h3 id=\"script\"><a href=\"#script\" class=\"headerlink\" title=\"script\"></a>script</h3><blockquote>\n<p><code>scripts</code> 字段是 <code>package.json</code> 中的一种元数据功能，它接受一个对象，对象的属性为可以通过 <code>npm run</code> 运行的脚本，值为实际运行的命令（通常是终端命令），如：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;scripts&quot;: &#123;\n\n    &quot;start&quot;: &quot;node index.js&quot;\n\n  &#125;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>将终端命令放入 <code>scripts</code> 字段，既可以记录它们又可以实现轻松重用。</p>\n</blockquote>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h3><h3 id=\"发布配置\"><a href=\"#发布配置\" class=\"headerlink\" title=\"发布配置\"></a>发布配置</h3><h3 id=\"private\"><a href=\"#private\" class=\"headerlink\" title=\"private\"></a>private</h3><blockquote>\n<p>一般公司的非开源项目，都会设置 <code>private</code> 属性的值为 <code>true</code>，这是因为 <code>npm</code> 拒绝发布私有模块，通过设置该字段可以防止私有模块被无意间发布出去。</p>\n</blockquote>\n<h3 id=\"preferGlobal\"><a href=\"#preferGlobal\" class=\"headerlink\" title=\"preferGlobal\"></a>preferGlobal</h3><h3 id=\"publishConfig\"><a href=\"#publishConfig\" class=\"headerlink\" title=\"publishConfig\"></a>publishConfig</h3><h3 id=\"os\"><a href=\"#os\" class=\"headerlink\" title=\"os\"></a>os</h3><blockquote>\n<p>假如我们开发了一个模块，只能跑在 <code>darwin</code> 系统下，我们需要保证 <code>windows</code> 用户不会安装到该模块，从而避免发生不必要的错误。</p>\n</blockquote>\n<blockquote>\n<p>这时候，使用 <code>os</code> 属性则可以帮助我们实现以上的需求，该属性可以指定模块适用系统的系统，或者指定不能安装的系统黑名单（当在系统黑名单中的系统中安装模块则会报错）：</p>\n</blockquote>\n<pre><code>&#123;\n\n  // 适用系统\n\n  &quot;os&quot;: [&quot;darwin&quot;, &quot;linux&quot;],\n\n  // 黑名单\n\n  &quot;os&quot;: [&quot;!win32&quot;]\n\n&#125;\n</code></pre>\n<blockquote>\n<blockquote>\n<p>Tips：在 node 环境下可以使用 <code>process.platform</code> 来判断操作系统。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"cpu\"><a href=\"#cpu\" class=\"headerlink\" title=\"cpu\"></a>cpu</h3><blockquote>\n<p>和上面的 <code>os</code> 字段类似，我们可以用 <code>cpu</code> 字段更精准的限制用户安装环境：</p>\n</blockquote>\n<pre><code>&#123;\n\n  // 适用 CPU\n\n  &quot;cpu&quot;: [&quot;x64&quot;, &quot;ia32&quot;],\n\n  // 黑名单\n\n  &quot;cpu&quot;: [&quot;!arm&quot;, &quot;!mips&quot;]\n\n&#125;\n</code></pre>\n<blockquote>\n<blockquote>\n<p>Tips：在 node 环境下可以使用 <code>process.arch</code> 来判断 cpu 架构。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"engines\"><a href=\"#engines\" class=\"headerlink\" title=\"engines\"></a>engines</h3><blockquote>\n<p>有时候，新拉一个项目的时候，由于和其他开发使用的 <code>node</code> 版本不同，导致会出现很多奇奇怪怪的问题（如某些依赖安装报错、依赖安装完项目跑步起来等）。</p>\n</blockquote>\n<blockquote>\n<p>为了实现项目开箱即用的伟大理想，这时候可以使用 <code>package.json</code> 的 <code>engines</code> 字段来指定项目 <code>node</code> 版本：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;engines&quot;: &#123;\n\n    &quot;node&quot;: &quot;&gt;=0&quot;\n\n  &#125;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>该字段也可以指定适用的 <code>npm</code> 版本：</p>\n</blockquote>\n<pre><code>&#123;\n\n  &quot;engines&quot;: &#123;\n\n    &quot;npm&quot;: &quot;&gt;= 0&quot;\n\n  &#125;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>需要注意的是，<code>engines</code> 属性仅起到一个说明的作用，当用户版本不符合指定值时也不影响依赖的安装。</p>\n</blockquote>\n<h3 id=\"自定义字段\"><a href=\"#自定义字段\" class=\"headerlink\" title=\"自定义字段\"></a>自定义字段</h3><blockquote>\n<p>一些第三方 npm 包，会在 package.json 中定义字段。</p>\n</blockquote>\n<blockquote>\n<p>例如 husky 等 pre-commit</p>\n</blockquote>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li>重新认识 package.json</li>\n<li>一文搞懂 peerDependencies</li>\n</ul>\n"},{"title":"Npm脚本命令","date":"2023-02-08T03:32:00.000Z","_content":"\n## npm-cli 脚本命令\n\n-   npm access：在发布的包上设置访问级别\n-   npm adduser：Add a registry user account 添加仓库用户账户\n-   npm audit：Run a security audit 执行安全审计（自动安装应该更新的脆弱的模块包）\n-   bin：显示 npm bin 文件夹\n-   bugs：在浏览器中打开依赖包的 BUG 讨论社区\n-   build：构建依赖包\n-   cache：管理模块的缓存\n-   ci：Install a project with a clean slate\n-   completion：Tab Completion for npm\n-   config：管理 npm 配置文件\n-   dedupe：Reduce duplication\n-   deprecate：Deprecate a version of a package\n-   npm dist-tag：修改依赖包分发标签\n-   docs：在浏览器中打开依赖包的文档\n-   doctor：Check your environments\n-   edit：Edit an installed package\n-   explore：Browse an installed package\n-   help-search：Search npm help documentation\n-   help：查看某条命令的详细帮助\n-   hook：Manage registry hooks\n-   init：创建 npm 依赖包配置文件\n-   install-ci-test：Install a project with a clean slate and run tests\n-   install-test：Install package(s) and run tests\n-   install：安装依赖包\n-   link：符号连接包文件夹\n-   logout：Log out of the registry\n-   npm ls：列出已安装依赖包\n-   npm：javascript package manager\n-   org：Manage orgs\n-   outdated：检查过期的依赖包\n-   owner：Manage package owners\n-   pack：Create a tarball from a package\n-   ping：Ping npm registry\n-   prefix：显示路径前缀\n-   profile：变更注册表配置文件上的设置\n-   prune：删除无关的软件包\n-   publish：发布依赖包\n-   rebuild：重新构建依赖包\n-   repo：在浏览器中打开依赖包的储存仓库\n-   restart：Restart a package\n-   root：查看包的安装路径\n-   run-script：运行 npm script 脚本\n-   search：搜索依赖包\n-   shrinkwrap：Lock down dependency versions for publication\n-   star：收藏依赖包\n-   stars：查看依赖包收藏夹\n-   start：启动依赖包\n-   stop：停止依赖包\n-   team：Manage organization teams and team memberships\n-   test：测试依赖包\n-   token：管理鉴权令牌\n-   uninstall：移除依赖包\n-   unpublish：从公有仓库中移除依赖包\n-   update：U 更新模块\n-   version：查看模块版本\n-   npm view：查看模块的注册信息\n-   whoami：显示当前 npm 用户信息\n\n### npm init\n\n> 创建项目：\n\n```\n# 按提示输入项目信息\n\nnpm init\n\n# 使用默认值创建项目\n\nnpm init -y\n```\n\n### npm install\n\n> 安装依赖模块：\n\n```\nnpm install\n\n# 或者\n\nnpm i\n```\n\n### 安装多个模块\n\n> 无需为你要安装的每个模块都输入一遍 `npm i` 指令：\n\n```\nnpm i gulp-pug\n\nnpm i gulp-debug\n\nnpm i gulp-sass\n\n# 只需输入一行命令即可一次性批量安装模块\n\nnpm i gulp-pug gulp-debug gulp-sass\n\n# 更便捷的是，如果安装的所有模块的前缀是相同的，则可以这样安装，无需输入完整模块名\n\nnpm i gulp{-debug,-sass,-pug}\n```\n\n### 安装标识\n\n```\n# 安装包到生产环境依赖中\n\nnpm i gulp --save-prod\n\n# 更简化，你可以使用 `-P` 标识\n\nnpm i gulp -P\n\n# 同理，开发环境下的依赖安装，亦可使用 `-D` 代替 `--save-dev`\n\nnpm i gulp -D\n```\n\n> 当不带任何安装标识时，npm 默认将模块作为依赖项目添加到 `package.json` 文件中。如果你想避免这样，你可以使用 `no-save` 安装：\n\n```\nnpm i vue --no-save\n```\n\n### 安装指定版本\n\n```\n# 默认安装 latest 标签的版本\n\n# 如果没有指定 latest，就是最新发布的版本\n\nnpm install react\n\n# 如果你想安装一个不是最新版本的安装包\n\nnpm i react@0\n\n# 鉴于记住标签比记住版本数字容易，亦可使用 `npm v` 命令来查到的版本信息列表中的 `dist-tag` 来安装\n\nnpm i react@beta\n```\n\n### npm search\n\n```\n# 搜索依赖包\n\nnpm search <package-name>\n\nnpm search react\n\n# 或者\n\nnpm s <package-name>\n\nnpm se <package-name>\n\nnpm find <package-name>\n```\n\n### npm view\n\n```\n# 查看包信息\n\nnpm view <package-name>\n\nnpm view react\n\n# 或者\n\nnpm v react\n\n# 如果只想看安装包最近的版本信息\n\nnpm v <package-name> version\n\n# 如果想获取安装包完整的版本信息列表，可使用复数形式\n\nnpm v <package-name> versions\n```\n\n### 卸载模块\n\n> 如果你不想转到 `package.json` 文件并手动删除依赖包，则可以用以下方法删除：\n\n```\nnpm uninstall vue\n```\n\n> 这个命令会删除 `node_modules` 文件夹及 `package.json` 中对应的包。当然，你也可以用 `rm`、`un` 或 `r` 来达到相同的效果：\n\n`npm rm vue`\n\n> 如果由于某些原因，你只想从 `node_modules` 文件夹中删除安装包，但是想在 `package.json` 中保留其依赖项，那么你可以使用 `no-save` 标识。\n\n```\nnpm rm vue --no-save\n```\n\n### npm ls\n\n> `npm ls`此命令将以树状结构将已安装的软件包的所有版本及其依赖项打印到标准输出。\n\n```\n# 查看当前仓库使用模块（嵌套）\n\nnpm ls\n\n# 查看当前仓库使用模块（仅单层）\n\nnpm ls --depth 0\n\n# 查看全局模块包已安装模块\n\nnpm ls -g\n\n# 查看全局模块包已安装模块（仅单层）\n\nnpm ls -g --depth 0\n```\n\n### npm outdate\n\n> 大多数时候，你需要保持本地依赖的更新，你可以在项目目录下先查看一下安装包有没有版本更新：\n\n`npm outdate`\n\n### 执行测试\n\n```\nnpm run tests\n\nnpm test\n\nnpm t\n```\n\n### 显示可用脚本\n\n> 我们可以通过\n\n`npm run`\n\n### 安装 Github 包\n\n> 可以直接安装来自 Github Repo 的模块：\n\n```\nnpm i https://github.com/sindresorhus/gulp-debug\n```\n\n> 或者你可以忽略域名安装：\n\n```\nnpm i sindresorhus/gulp-debug\n```\n\n### 打开模块包仓库主页\n\n> 当然可以直接谷歌搜索，然后找到对应的包链接打开：\n\n```\nnpm repo create-react-app\n```\n\n### 列出所有 NPM 环境的可用变量\n\n> 你可以使用这个命令来列出所有 NPM 环境的可用变量：\n\n```\nnpm run env | grep npm_\n```\n\n> 默认情况下，npm 会重命名你的变量，给其加上前缀 `npm_package`，并将其结构保留在 `package.json` 文件中，即变为 `config_build_folder`。\n\n### 在 npm 脚本中使用 npm 变量\n\n> 你可以看到可用变量的完整列表，如果你想使用这些变量中的任何值，就可以在 `package.json` 中使用：\n\n```\n\"scripts\": {\n\n    \"build\": \"gulp build --dist $npm_package_config_build_folder\"\n\n}\n```\n\n> 当你执行 `npm run build` 的时候，实际执行的是这样的：\n\n```\ngulp build --dist ./dist\n```\n\n### 检查过期的依赖包\n\n```\n# 查看过期依赖包\n\nnpm outdated\n\n# 以 JSON 形式输出\n\nnpm outdated --json\n```\n\n### 设置镜像源\n\n> 临时使用\n\n```\nnpm --registry https://registry.npm.taobao.org install express\n```\n\n> 持久使用\n\n```\nnpm config set registry https://registry.npm.taobao.org\n```\n\n### npm create\n","source":"_posts/Npm/Npm脚本命令.md","raw":"---\ntitle: Npm脚本命令\ndate: 2023-02-08 11:32:00\ntags: Npm\n---\n\n## npm-cli 脚本命令\n\n-   npm access：在发布的包上设置访问级别\n-   npm adduser：Add a registry user account 添加仓库用户账户\n-   npm audit：Run a security audit 执行安全审计（自动安装应该更新的脆弱的模块包）\n-   bin：显示 npm bin 文件夹\n-   bugs：在浏览器中打开依赖包的 BUG 讨论社区\n-   build：构建依赖包\n-   cache：管理模块的缓存\n-   ci：Install a project with a clean slate\n-   completion：Tab Completion for npm\n-   config：管理 npm 配置文件\n-   dedupe：Reduce duplication\n-   deprecate：Deprecate a version of a package\n-   npm dist-tag：修改依赖包分发标签\n-   docs：在浏览器中打开依赖包的文档\n-   doctor：Check your environments\n-   edit：Edit an installed package\n-   explore：Browse an installed package\n-   help-search：Search npm help documentation\n-   help：查看某条命令的详细帮助\n-   hook：Manage registry hooks\n-   init：创建 npm 依赖包配置文件\n-   install-ci-test：Install a project with a clean slate and run tests\n-   install-test：Install package(s) and run tests\n-   install：安装依赖包\n-   link：符号连接包文件夹\n-   logout：Log out of the registry\n-   npm ls：列出已安装依赖包\n-   npm：javascript package manager\n-   org：Manage orgs\n-   outdated：检查过期的依赖包\n-   owner：Manage package owners\n-   pack：Create a tarball from a package\n-   ping：Ping npm registry\n-   prefix：显示路径前缀\n-   profile：变更注册表配置文件上的设置\n-   prune：删除无关的软件包\n-   publish：发布依赖包\n-   rebuild：重新构建依赖包\n-   repo：在浏览器中打开依赖包的储存仓库\n-   restart：Restart a package\n-   root：查看包的安装路径\n-   run-script：运行 npm script 脚本\n-   search：搜索依赖包\n-   shrinkwrap：Lock down dependency versions for publication\n-   star：收藏依赖包\n-   stars：查看依赖包收藏夹\n-   start：启动依赖包\n-   stop：停止依赖包\n-   team：Manage organization teams and team memberships\n-   test：测试依赖包\n-   token：管理鉴权令牌\n-   uninstall：移除依赖包\n-   unpublish：从公有仓库中移除依赖包\n-   update：U 更新模块\n-   version：查看模块版本\n-   npm view：查看模块的注册信息\n-   whoami：显示当前 npm 用户信息\n\n### npm init\n\n> 创建项目：\n\n```\n# 按提示输入项目信息\n\nnpm init\n\n# 使用默认值创建项目\n\nnpm init -y\n```\n\n### npm install\n\n> 安装依赖模块：\n\n```\nnpm install\n\n# 或者\n\nnpm i\n```\n\n### 安装多个模块\n\n> 无需为你要安装的每个模块都输入一遍 `npm i` 指令：\n\n```\nnpm i gulp-pug\n\nnpm i gulp-debug\n\nnpm i gulp-sass\n\n# 只需输入一行命令即可一次性批量安装模块\n\nnpm i gulp-pug gulp-debug gulp-sass\n\n# 更便捷的是，如果安装的所有模块的前缀是相同的，则可以这样安装，无需输入完整模块名\n\nnpm i gulp{-debug,-sass,-pug}\n```\n\n### 安装标识\n\n```\n# 安装包到生产环境依赖中\n\nnpm i gulp --save-prod\n\n# 更简化，你可以使用 `-P` 标识\n\nnpm i gulp -P\n\n# 同理，开发环境下的依赖安装，亦可使用 `-D` 代替 `--save-dev`\n\nnpm i gulp -D\n```\n\n> 当不带任何安装标识时，npm 默认将模块作为依赖项目添加到 `package.json` 文件中。如果你想避免这样，你可以使用 `no-save` 安装：\n\n```\nnpm i vue --no-save\n```\n\n### 安装指定版本\n\n```\n# 默认安装 latest 标签的版本\n\n# 如果没有指定 latest，就是最新发布的版本\n\nnpm install react\n\n# 如果你想安装一个不是最新版本的安装包\n\nnpm i react@0\n\n# 鉴于记住标签比记住版本数字容易，亦可使用 `npm v` 命令来查到的版本信息列表中的 `dist-tag` 来安装\n\nnpm i react@beta\n```\n\n### npm search\n\n```\n# 搜索依赖包\n\nnpm search <package-name>\n\nnpm search react\n\n# 或者\n\nnpm s <package-name>\n\nnpm se <package-name>\n\nnpm find <package-name>\n```\n\n### npm view\n\n```\n# 查看包信息\n\nnpm view <package-name>\n\nnpm view react\n\n# 或者\n\nnpm v react\n\n# 如果只想看安装包最近的版本信息\n\nnpm v <package-name> version\n\n# 如果想获取安装包完整的版本信息列表，可使用复数形式\n\nnpm v <package-name> versions\n```\n\n### 卸载模块\n\n> 如果你不想转到 `package.json` 文件并手动删除依赖包，则可以用以下方法删除：\n\n```\nnpm uninstall vue\n```\n\n> 这个命令会删除 `node_modules` 文件夹及 `package.json` 中对应的包。当然，你也可以用 `rm`、`un` 或 `r` 来达到相同的效果：\n\n`npm rm vue`\n\n> 如果由于某些原因，你只想从 `node_modules` 文件夹中删除安装包，但是想在 `package.json` 中保留其依赖项，那么你可以使用 `no-save` 标识。\n\n```\nnpm rm vue --no-save\n```\n\n### npm ls\n\n> `npm ls`此命令将以树状结构将已安装的软件包的所有版本及其依赖项打印到标准输出。\n\n```\n# 查看当前仓库使用模块（嵌套）\n\nnpm ls\n\n# 查看当前仓库使用模块（仅单层）\n\nnpm ls --depth 0\n\n# 查看全局模块包已安装模块\n\nnpm ls -g\n\n# 查看全局模块包已安装模块（仅单层）\n\nnpm ls -g --depth 0\n```\n\n### npm outdate\n\n> 大多数时候，你需要保持本地依赖的更新，你可以在项目目录下先查看一下安装包有没有版本更新：\n\n`npm outdate`\n\n### 执行测试\n\n```\nnpm run tests\n\nnpm test\n\nnpm t\n```\n\n### 显示可用脚本\n\n> 我们可以通过\n\n`npm run`\n\n### 安装 Github 包\n\n> 可以直接安装来自 Github Repo 的模块：\n\n```\nnpm i https://github.com/sindresorhus/gulp-debug\n```\n\n> 或者你可以忽略域名安装：\n\n```\nnpm i sindresorhus/gulp-debug\n```\n\n### 打开模块包仓库主页\n\n> 当然可以直接谷歌搜索，然后找到对应的包链接打开：\n\n```\nnpm repo create-react-app\n```\n\n### 列出所有 NPM 环境的可用变量\n\n> 你可以使用这个命令来列出所有 NPM 环境的可用变量：\n\n```\nnpm run env | grep npm_\n```\n\n> 默认情况下，npm 会重命名你的变量，给其加上前缀 `npm_package`，并将其结构保留在 `package.json` 文件中，即变为 `config_build_folder`。\n\n### 在 npm 脚本中使用 npm 变量\n\n> 你可以看到可用变量的完整列表，如果你想使用这些变量中的任何值，就可以在 `package.json` 中使用：\n\n```\n\"scripts\": {\n\n    \"build\": \"gulp build --dist $npm_package_config_build_folder\"\n\n}\n```\n\n> 当你执行 `npm run build` 的时候，实际执行的是这样的：\n\n```\ngulp build --dist ./dist\n```\n\n### 检查过期的依赖包\n\n```\n# 查看过期依赖包\n\nnpm outdated\n\n# 以 JSON 形式输出\n\nnpm outdated --json\n```\n\n### 设置镜像源\n\n> 临时使用\n\n```\nnpm --registry https://registry.npm.taobao.org install express\n```\n\n> 持久使用\n\n```\nnpm config set registry https://registry.npm.taobao.org\n```\n\n### npm create\n","slug":"Npm/Npm脚本命令","published":1,"updated":"2023-02-21T09:35:15.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iult000pbkh04v814wsg","content":"<h2 id=\"npm-cli-脚本命令\"><a href=\"#npm-cli-脚本命令\" class=\"headerlink\" title=\"npm-cli 脚本命令\"></a>npm-cli 脚本命令</h2><ul>\n<li>npm access：在发布的包上设置访问级别</li>\n<li>npm adduser：Add a registry user account 添加仓库用户账户</li>\n<li>npm audit：Run a security audit 执行安全审计（自动安装应该更新的脆弱的模块包）</li>\n<li>bin：显示 npm bin 文件夹</li>\n<li>bugs：在浏览器中打开依赖包的 BUG 讨论社区</li>\n<li>build：构建依赖包</li>\n<li>cache：管理模块的缓存</li>\n<li>ci：Install a project with a clean slate</li>\n<li>completion：Tab Completion for npm</li>\n<li>config：管理 npm 配置文件</li>\n<li>dedupe：Reduce duplication</li>\n<li>deprecate：Deprecate a version of a package</li>\n<li>npm dist-tag：修改依赖包分发标签</li>\n<li>docs：在浏览器中打开依赖包的文档</li>\n<li>doctor：Check your environments</li>\n<li>edit：Edit an installed package</li>\n<li>explore：Browse an installed package</li>\n<li>help-search：Search npm help documentation</li>\n<li>help：查看某条命令的详细帮助</li>\n<li>hook：Manage registry hooks</li>\n<li>init：创建 npm 依赖包配置文件</li>\n<li>install-ci-test：Install a project with a clean slate and run tests</li>\n<li>install-test：Install package(s) and run tests</li>\n<li>install：安装依赖包</li>\n<li>link：符号连接包文件夹</li>\n<li>logout：Log out of the registry</li>\n<li>npm ls：列出已安装依赖包</li>\n<li>npm：javascript package manager</li>\n<li>org：Manage orgs</li>\n<li>outdated：检查过期的依赖包</li>\n<li>owner：Manage package owners</li>\n<li>pack：Create a tarball from a package</li>\n<li>ping：Ping npm registry</li>\n<li>prefix：显示路径前缀</li>\n<li>profile：变更注册表配置文件上的设置</li>\n<li>prune：删除无关的软件包</li>\n<li>publish：发布依赖包</li>\n<li>rebuild：重新构建依赖包</li>\n<li>repo：在浏览器中打开依赖包的储存仓库</li>\n<li>restart：Restart a package</li>\n<li>root：查看包的安装路径</li>\n<li>run-script：运行 npm script 脚本</li>\n<li>search：搜索依赖包</li>\n<li>shrinkwrap：Lock down dependency versions for publication</li>\n<li>star：收藏依赖包</li>\n<li>stars：查看依赖包收藏夹</li>\n<li>start：启动依赖包</li>\n<li>stop：停止依赖包</li>\n<li>team：Manage organization teams and team memberships</li>\n<li>test：测试依赖包</li>\n<li>token：管理鉴权令牌</li>\n<li>uninstall：移除依赖包</li>\n<li>unpublish：从公有仓库中移除依赖包</li>\n<li>update：U 更新模块</li>\n<li>version：查看模块版本</li>\n<li>npm view：查看模块的注册信息</li>\n<li>whoami：显示当前 npm 用户信息</li>\n</ul>\n<h3 id=\"npm-init\"><a href=\"#npm-init\" class=\"headerlink\" title=\"npm init\"></a>npm init</h3><blockquote>\n<p>创建项目：</p>\n</blockquote>\n<pre><code># 按提示输入项目信息\n\nnpm init\n\n# 使用默认值创建项目\n\nnpm init -y\n</code></pre>\n<h3 id=\"npm-install\"><a href=\"#npm-install\" class=\"headerlink\" title=\"npm install\"></a>npm install</h3><blockquote>\n<p>安装依赖模块：</p>\n</blockquote>\n<pre><code>npm install\n\n# 或者\n\nnpm i\n</code></pre>\n<h3 id=\"安装多个模块\"><a href=\"#安装多个模块\" class=\"headerlink\" title=\"安装多个模块\"></a>安装多个模块</h3><blockquote>\n<p>无需为你要安装的每个模块都输入一遍 <code>npm i</code> 指令：</p>\n</blockquote>\n<pre><code>npm i gulp-pug\n\nnpm i gulp-debug\n\nnpm i gulp-sass\n\n# 只需输入一行命令即可一次性批量安装模块\n\nnpm i gulp-pug gulp-debug gulp-sass\n\n# 更便捷的是，如果安装的所有模块的前缀是相同的，则可以这样安装，无需输入完整模块名\n\nnpm i gulp&#123;-debug,-sass,-pug&#125;\n</code></pre>\n<h3 id=\"安装标识\"><a href=\"#安装标识\" class=\"headerlink\" title=\"安装标识\"></a>安装标识</h3><pre><code># 安装包到生产环境依赖中\n\nnpm i gulp --save-prod\n\n# 更简化，你可以使用 `-P` 标识\n\nnpm i gulp -P\n\n# 同理，开发环境下的依赖安装，亦可使用 `-D` 代替 `--save-dev`\n\nnpm i gulp -D\n</code></pre>\n<blockquote>\n<p>当不带任何安装标识时，npm 默认将模块作为依赖项目添加到 <code>package.json</code> 文件中。如果你想避免这样，你可以使用 <code>no-save</code> 安装：</p>\n</blockquote>\n<pre><code>npm i vue --no-save\n</code></pre>\n<h3 id=\"安装指定版本\"><a href=\"#安装指定版本\" class=\"headerlink\" title=\"安装指定版本\"></a>安装指定版本</h3><pre><code># 默认安装 latest 标签的版本\n\n# 如果没有指定 latest，就是最新发布的版本\n\nnpm install react\n\n# 如果你想安装一个不是最新版本的安装包\n\nnpm i react@0\n\n# 鉴于记住标签比记住版本数字容易，亦可使用 `npm v` 命令来查到的版本信息列表中的 `dist-tag` 来安装\n\nnpm i react@beta\n</code></pre>\n<h3 id=\"npm-search\"><a href=\"#npm-search\" class=\"headerlink\" title=\"npm search\"></a>npm search</h3><pre><code># 搜索依赖包\n\nnpm search &lt;package-name&gt;\n\nnpm search react\n\n# 或者\n\nnpm s &lt;package-name&gt;\n\nnpm se &lt;package-name&gt;\n\nnpm find &lt;package-name&gt;\n</code></pre>\n<h3 id=\"npm-view\"><a href=\"#npm-view\" class=\"headerlink\" title=\"npm view\"></a>npm view</h3><pre><code># 查看包信息\n\nnpm view &lt;package-name&gt;\n\nnpm view react\n\n# 或者\n\nnpm v react\n\n# 如果只想看安装包最近的版本信息\n\nnpm v &lt;package-name&gt; version\n\n# 如果想获取安装包完整的版本信息列表，可使用复数形式\n\nnpm v &lt;package-name&gt; versions\n</code></pre>\n<h3 id=\"卸载模块\"><a href=\"#卸载模块\" class=\"headerlink\" title=\"卸载模块\"></a>卸载模块</h3><blockquote>\n<p>如果你不想转到 <code>package.json</code> 文件并手动删除依赖包，则可以用以下方法删除：</p>\n</blockquote>\n<pre><code>npm uninstall vue\n</code></pre>\n<blockquote>\n<p>这个命令会删除 <code>node_modules</code> 文件夹及 <code>package.json</code> 中对应的包。当然，你也可以用 <code>rm</code>、<code>un</code> 或 <code>r</code> 来达到相同的效果：</p>\n</blockquote>\n<p><code>npm rm vue</code></p>\n<blockquote>\n<p>如果由于某些原因，你只想从 <code>node_modules</code> 文件夹中删除安装包，但是想在 <code>package.json</code> 中保留其依赖项，那么你可以使用 <code>no-save</code> 标识。</p>\n</blockquote>\n<pre><code>npm rm vue --no-save\n</code></pre>\n<h3 id=\"npm-ls\"><a href=\"#npm-ls\" class=\"headerlink\" title=\"npm ls\"></a>npm ls</h3><blockquote>\n<p><code>npm ls</code>此命令将以树状结构将已安装的软件包的所有版本及其依赖项打印到标准输出。</p>\n</blockquote>\n<pre><code># 查看当前仓库使用模块（嵌套）\n\nnpm ls\n\n# 查看当前仓库使用模块（仅单层）\n\nnpm ls --depth 0\n\n# 查看全局模块包已安装模块\n\nnpm ls -g\n\n# 查看全局模块包已安装模块（仅单层）\n\nnpm ls -g --depth 0\n</code></pre>\n<h3 id=\"npm-outdate\"><a href=\"#npm-outdate\" class=\"headerlink\" title=\"npm outdate\"></a>npm outdate</h3><blockquote>\n<p>大多数时候，你需要保持本地依赖的更新，你可以在项目目录下先查看一下安装包有没有版本更新：</p>\n</blockquote>\n<p><code>npm outdate</code></p>\n<h3 id=\"执行测试\"><a href=\"#执行测试\" class=\"headerlink\" title=\"执行测试\"></a>执行测试</h3><pre><code>npm run tests\n\nnpm test\n\nnpm t\n</code></pre>\n<h3 id=\"显示可用脚本\"><a href=\"#显示可用脚本\" class=\"headerlink\" title=\"显示可用脚本\"></a>显示可用脚本</h3><blockquote>\n<p>我们可以通过</p>\n</blockquote>\n<p><code>npm run</code></p>\n<h3 id=\"安装-Github-包\"><a href=\"#安装-Github-包\" class=\"headerlink\" title=\"安装 Github 包\"></a>安装 Github 包</h3><blockquote>\n<p>可以直接安装来自 Github Repo 的模块：</p>\n</blockquote>\n<pre><code>npm i https://github.com/sindresorhus/gulp-debug\n</code></pre>\n<blockquote>\n<p>或者你可以忽略域名安装：</p>\n</blockquote>\n<pre><code>npm i sindresorhus/gulp-debug\n</code></pre>\n<h3 id=\"打开模块包仓库主页\"><a href=\"#打开模块包仓库主页\" class=\"headerlink\" title=\"打开模块包仓库主页\"></a>打开模块包仓库主页</h3><blockquote>\n<p>当然可以直接谷歌搜索，然后找到对应的包链接打开：</p>\n</blockquote>\n<pre><code>npm repo create-react-app\n</code></pre>\n<h3 id=\"列出所有-NPM-环境的可用变量\"><a href=\"#列出所有-NPM-环境的可用变量\" class=\"headerlink\" title=\"列出所有 NPM 环境的可用变量\"></a>列出所有 NPM 环境的可用变量</h3><blockquote>\n<p>你可以使用这个命令来列出所有 NPM 环境的可用变量：</p>\n</blockquote>\n<pre><code>npm run env | grep npm_\n</code></pre>\n<blockquote>\n<p>默认情况下，npm 会重命名你的变量，给其加上前缀 <code>npm_package</code>，并将其结构保留在 <code>package.json</code> 文件中，即变为 <code>config_build_folder</code>。</p>\n</blockquote>\n<h3 id=\"在-npm-脚本中使用-npm-变量\"><a href=\"#在-npm-脚本中使用-npm-变量\" class=\"headerlink\" title=\"在 npm 脚本中使用 npm 变量\"></a>在 npm 脚本中使用 npm 变量</h3><blockquote>\n<p>你可以看到可用变量的完整列表，如果你想使用这些变量中的任何值，就可以在 <code>package.json</code> 中使用：</p>\n</blockquote>\n<pre><code>&quot;scripts&quot;: &#123;\n\n    &quot;build&quot;: &quot;gulp build --dist $npm_package_config_build_folder&quot;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>当你执行 <code>npm run build</code> 的时候，实际执行的是这样的：</p>\n</blockquote>\n<pre><code>gulp build --dist ./dist\n</code></pre>\n<h3 id=\"检查过期的依赖包\"><a href=\"#检查过期的依赖包\" class=\"headerlink\" title=\"检查过期的依赖包\"></a>检查过期的依赖包</h3><pre><code># 查看过期依赖包\n\nnpm outdated\n\n# 以 JSON 形式输出\n\nnpm outdated --json\n</code></pre>\n<h3 id=\"设置镜像源\"><a href=\"#设置镜像源\" class=\"headerlink\" title=\"设置镜像源\"></a>设置镜像源</h3><blockquote>\n<p>临时使用</p>\n</blockquote>\n<pre><code>npm --registry https://registry.npm.taobao.org install express\n</code></pre>\n<blockquote>\n<p>持久使用</p>\n</blockquote>\n<pre><code>npm config set registry https://registry.npm.taobao.org\n</code></pre>\n<h3 id=\"npm-create\"><a href=\"#npm-create\" class=\"headerlink\" title=\"npm create\"></a>npm create</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"npm-cli-脚本命令\"><a href=\"#npm-cli-脚本命令\" class=\"headerlink\" title=\"npm-cli 脚本命令\"></a>npm-cli 脚本命令</h2><ul>\n<li>npm access：在发布的包上设置访问级别</li>\n<li>npm adduser：Add a registry user account 添加仓库用户账户</li>\n<li>npm audit：Run a security audit 执行安全审计（自动安装应该更新的脆弱的模块包）</li>\n<li>bin：显示 npm bin 文件夹</li>\n<li>bugs：在浏览器中打开依赖包的 BUG 讨论社区</li>\n<li>build：构建依赖包</li>\n<li>cache：管理模块的缓存</li>\n<li>ci：Install a project with a clean slate</li>\n<li>completion：Tab Completion for npm</li>\n<li>config：管理 npm 配置文件</li>\n<li>dedupe：Reduce duplication</li>\n<li>deprecate：Deprecate a version of a package</li>\n<li>npm dist-tag：修改依赖包分发标签</li>\n<li>docs：在浏览器中打开依赖包的文档</li>\n<li>doctor：Check your environments</li>\n<li>edit：Edit an installed package</li>\n<li>explore：Browse an installed package</li>\n<li>help-search：Search npm help documentation</li>\n<li>help：查看某条命令的详细帮助</li>\n<li>hook：Manage registry hooks</li>\n<li>init：创建 npm 依赖包配置文件</li>\n<li>install-ci-test：Install a project with a clean slate and run tests</li>\n<li>install-test：Install package(s) and run tests</li>\n<li>install：安装依赖包</li>\n<li>link：符号连接包文件夹</li>\n<li>logout：Log out of the registry</li>\n<li>npm ls：列出已安装依赖包</li>\n<li>npm：javascript package manager</li>\n<li>org：Manage orgs</li>\n<li>outdated：检查过期的依赖包</li>\n<li>owner：Manage package owners</li>\n<li>pack：Create a tarball from a package</li>\n<li>ping：Ping npm registry</li>\n<li>prefix：显示路径前缀</li>\n<li>profile：变更注册表配置文件上的设置</li>\n<li>prune：删除无关的软件包</li>\n<li>publish：发布依赖包</li>\n<li>rebuild：重新构建依赖包</li>\n<li>repo：在浏览器中打开依赖包的储存仓库</li>\n<li>restart：Restart a package</li>\n<li>root：查看包的安装路径</li>\n<li>run-script：运行 npm script 脚本</li>\n<li>search：搜索依赖包</li>\n<li>shrinkwrap：Lock down dependency versions for publication</li>\n<li>star：收藏依赖包</li>\n<li>stars：查看依赖包收藏夹</li>\n<li>start：启动依赖包</li>\n<li>stop：停止依赖包</li>\n<li>team：Manage organization teams and team memberships</li>\n<li>test：测试依赖包</li>\n<li>token：管理鉴权令牌</li>\n<li>uninstall：移除依赖包</li>\n<li>unpublish：从公有仓库中移除依赖包</li>\n<li>update：U 更新模块</li>\n<li>version：查看模块版本</li>\n<li>npm view：查看模块的注册信息</li>\n<li>whoami：显示当前 npm 用户信息</li>\n</ul>\n<h3 id=\"npm-init\"><a href=\"#npm-init\" class=\"headerlink\" title=\"npm init\"></a>npm init</h3><blockquote>\n<p>创建项目：</p>\n</blockquote>\n<pre><code># 按提示输入项目信息\n\nnpm init\n\n# 使用默认值创建项目\n\nnpm init -y\n</code></pre>\n<h3 id=\"npm-install\"><a href=\"#npm-install\" class=\"headerlink\" title=\"npm install\"></a>npm install</h3><blockquote>\n<p>安装依赖模块：</p>\n</blockquote>\n<pre><code>npm install\n\n# 或者\n\nnpm i\n</code></pre>\n<h3 id=\"安装多个模块\"><a href=\"#安装多个模块\" class=\"headerlink\" title=\"安装多个模块\"></a>安装多个模块</h3><blockquote>\n<p>无需为你要安装的每个模块都输入一遍 <code>npm i</code> 指令：</p>\n</blockquote>\n<pre><code>npm i gulp-pug\n\nnpm i gulp-debug\n\nnpm i gulp-sass\n\n# 只需输入一行命令即可一次性批量安装模块\n\nnpm i gulp-pug gulp-debug gulp-sass\n\n# 更便捷的是，如果安装的所有模块的前缀是相同的，则可以这样安装，无需输入完整模块名\n\nnpm i gulp&#123;-debug,-sass,-pug&#125;\n</code></pre>\n<h3 id=\"安装标识\"><a href=\"#安装标识\" class=\"headerlink\" title=\"安装标识\"></a>安装标识</h3><pre><code># 安装包到生产环境依赖中\n\nnpm i gulp --save-prod\n\n# 更简化，你可以使用 `-P` 标识\n\nnpm i gulp -P\n\n# 同理，开发环境下的依赖安装，亦可使用 `-D` 代替 `--save-dev`\n\nnpm i gulp -D\n</code></pre>\n<blockquote>\n<p>当不带任何安装标识时，npm 默认将模块作为依赖项目添加到 <code>package.json</code> 文件中。如果你想避免这样，你可以使用 <code>no-save</code> 安装：</p>\n</blockquote>\n<pre><code>npm i vue --no-save\n</code></pre>\n<h3 id=\"安装指定版本\"><a href=\"#安装指定版本\" class=\"headerlink\" title=\"安装指定版本\"></a>安装指定版本</h3><pre><code># 默认安装 latest 标签的版本\n\n# 如果没有指定 latest，就是最新发布的版本\n\nnpm install react\n\n# 如果你想安装一个不是最新版本的安装包\n\nnpm i react@0\n\n# 鉴于记住标签比记住版本数字容易，亦可使用 `npm v` 命令来查到的版本信息列表中的 `dist-tag` 来安装\n\nnpm i react@beta\n</code></pre>\n<h3 id=\"npm-search\"><a href=\"#npm-search\" class=\"headerlink\" title=\"npm search\"></a>npm search</h3><pre><code># 搜索依赖包\n\nnpm search &lt;package-name&gt;\n\nnpm search react\n\n# 或者\n\nnpm s &lt;package-name&gt;\n\nnpm se &lt;package-name&gt;\n\nnpm find &lt;package-name&gt;\n</code></pre>\n<h3 id=\"npm-view\"><a href=\"#npm-view\" class=\"headerlink\" title=\"npm view\"></a>npm view</h3><pre><code># 查看包信息\n\nnpm view &lt;package-name&gt;\n\nnpm view react\n\n# 或者\n\nnpm v react\n\n# 如果只想看安装包最近的版本信息\n\nnpm v &lt;package-name&gt; version\n\n# 如果想获取安装包完整的版本信息列表，可使用复数形式\n\nnpm v &lt;package-name&gt; versions\n</code></pre>\n<h3 id=\"卸载模块\"><a href=\"#卸载模块\" class=\"headerlink\" title=\"卸载模块\"></a>卸载模块</h3><blockquote>\n<p>如果你不想转到 <code>package.json</code> 文件并手动删除依赖包，则可以用以下方法删除：</p>\n</blockquote>\n<pre><code>npm uninstall vue\n</code></pre>\n<blockquote>\n<p>这个命令会删除 <code>node_modules</code> 文件夹及 <code>package.json</code> 中对应的包。当然，你也可以用 <code>rm</code>、<code>un</code> 或 <code>r</code> 来达到相同的效果：</p>\n</blockquote>\n<p><code>npm rm vue</code></p>\n<blockquote>\n<p>如果由于某些原因，你只想从 <code>node_modules</code> 文件夹中删除安装包，但是想在 <code>package.json</code> 中保留其依赖项，那么你可以使用 <code>no-save</code> 标识。</p>\n</blockquote>\n<pre><code>npm rm vue --no-save\n</code></pre>\n<h3 id=\"npm-ls\"><a href=\"#npm-ls\" class=\"headerlink\" title=\"npm ls\"></a>npm ls</h3><blockquote>\n<p><code>npm ls</code>此命令将以树状结构将已安装的软件包的所有版本及其依赖项打印到标准输出。</p>\n</blockquote>\n<pre><code># 查看当前仓库使用模块（嵌套）\n\nnpm ls\n\n# 查看当前仓库使用模块（仅单层）\n\nnpm ls --depth 0\n\n# 查看全局模块包已安装模块\n\nnpm ls -g\n\n# 查看全局模块包已安装模块（仅单层）\n\nnpm ls -g --depth 0\n</code></pre>\n<h3 id=\"npm-outdate\"><a href=\"#npm-outdate\" class=\"headerlink\" title=\"npm outdate\"></a>npm outdate</h3><blockquote>\n<p>大多数时候，你需要保持本地依赖的更新，你可以在项目目录下先查看一下安装包有没有版本更新：</p>\n</blockquote>\n<p><code>npm outdate</code></p>\n<h3 id=\"执行测试\"><a href=\"#执行测试\" class=\"headerlink\" title=\"执行测试\"></a>执行测试</h3><pre><code>npm run tests\n\nnpm test\n\nnpm t\n</code></pre>\n<h3 id=\"显示可用脚本\"><a href=\"#显示可用脚本\" class=\"headerlink\" title=\"显示可用脚本\"></a>显示可用脚本</h3><blockquote>\n<p>我们可以通过</p>\n</blockquote>\n<p><code>npm run</code></p>\n<h3 id=\"安装-Github-包\"><a href=\"#安装-Github-包\" class=\"headerlink\" title=\"安装 Github 包\"></a>安装 Github 包</h3><blockquote>\n<p>可以直接安装来自 Github Repo 的模块：</p>\n</blockquote>\n<pre><code>npm i https://github.com/sindresorhus/gulp-debug\n</code></pre>\n<blockquote>\n<p>或者你可以忽略域名安装：</p>\n</blockquote>\n<pre><code>npm i sindresorhus/gulp-debug\n</code></pre>\n<h3 id=\"打开模块包仓库主页\"><a href=\"#打开模块包仓库主页\" class=\"headerlink\" title=\"打开模块包仓库主页\"></a>打开模块包仓库主页</h3><blockquote>\n<p>当然可以直接谷歌搜索，然后找到对应的包链接打开：</p>\n</blockquote>\n<pre><code>npm repo create-react-app\n</code></pre>\n<h3 id=\"列出所有-NPM-环境的可用变量\"><a href=\"#列出所有-NPM-环境的可用变量\" class=\"headerlink\" title=\"列出所有 NPM 环境的可用变量\"></a>列出所有 NPM 环境的可用变量</h3><blockquote>\n<p>你可以使用这个命令来列出所有 NPM 环境的可用变量：</p>\n</blockquote>\n<pre><code>npm run env | grep npm_\n</code></pre>\n<blockquote>\n<p>默认情况下，npm 会重命名你的变量，给其加上前缀 <code>npm_package</code>，并将其结构保留在 <code>package.json</code> 文件中，即变为 <code>config_build_folder</code>。</p>\n</blockquote>\n<h3 id=\"在-npm-脚本中使用-npm-变量\"><a href=\"#在-npm-脚本中使用-npm-变量\" class=\"headerlink\" title=\"在 npm 脚本中使用 npm 变量\"></a>在 npm 脚本中使用 npm 变量</h3><blockquote>\n<p>你可以看到可用变量的完整列表，如果你想使用这些变量中的任何值，就可以在 <code>package.json</code> 中使用：</p>\n</blockquote>\n<pre><code>&quot;scripts&quot;: &#123;\n\n    &quot;build&quot;: &quot;gulp build --dist $npm_package_config_build_folder&quot;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>当你执行 <code>npm run build</code> 的时候，实际执行的是这样的：</p>\n</blockquote>\n<pre><code>gulp build --dist ./dist\n</code></pre>\n<h3 id=\"检查过期的依赖包\"><a href=\"#检查过期的依赖包\" class=\"headerlink\" title=\"检查过期的依赖包\"></a>检查过期的依赖包</h3><pre><code># 查看过期依赖包\n\nnpm outdated\n\n# 以 JSON 形式输出\n\nnpm outdated --json\n</code></pre>\n<h3 id=\"设置镜像源\"><a href=\"#设置镜像源\" class=\"headerlink\" title=\"设置镜像源\"></a>设置镜像源</h3><blockquote>\n<p>临时使用</p>\n</blockquote>\n<pre><code>npm --registry https://registry.npm.taobao.org install express\n</code></pre>\n<blockquote>\n<p>持久使用</p>\n</blockquote>\n<pre><code>npm config set registry https://registry.npm.taobao.org\n</code></pre>\n<h3 id=\"npm-create\"><a href=\"#npm-create\" class=\"headerlink\" title=\"npm create\"></a>npm create</h3>"},{"title":"Npm版本控制","date":"2023-02-08T03:31:02.000Z","_content":"\n## npm 版本控制\n\n### 查看依赖包版本\n\n> 通过执行以下命令能够查看某个依赖包的最新版本。\n\n```\n# 查看某个 package 的注册信息\n\nnpm view <package-name>\n\n# 查看某个 package 的最新版本\n\nnpm view <package-name> version\n\n# 查看某个 package 在 npm 服务器上所发布过的版本\n\nnpm view <package-name> versions\n\n# 查看仓库依赖树上所有包的版本信息\n\nnpm ls\n```\n\n### 语义化版本规范\n\n> npm 中的包模块版本都需要遵循 SemVer（Semantic Version，语义化版本）规范，这是由 Github 起草的一个具有指导意义的，统一的版本号表示规则。\n\n### 标准版本\n\n> SemVer 规范的标准版本号采用 `X.Y.Z` 的格式，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须以数值来递增。\n\n-   主版本号（major）：当你做了不兼容的 API 修改\n-   次版本号（minor）：当你做了向下兼容的功能性新增\n-   修订号（patch）：当你做了向下兼容的问题修正。\n\n> 版本是严格递增的，例如：16.2.0 -> 16.2.1 -> 16.3.0 -> 16.4.0\n\n### 先行版本\n\n> 当某个版本改动比较大、并非稳定而且可能无法满足预期的兼容性需求时，你可能要先发布一个先行版本。\n\n> 先行版本的格式是在修订版本号后面加上一个连接号（`-`），再加上一连串以点（`.`）分割的标识符，标识符可以由英文、数字和连接号（`[0-9A-Za-z]`）组成。\n\n> 例如：\n\n```\n# 格式\n\nmajor.minor.patch-{identifier}.{identifier}.{identifier}\n\n# 示例 1：通常第一个 identifier 为版本号标签，关于版本号标签请看下文\n\n# 常用于先行版本的版本号标签是 beta、rc、experimental\n\n3-alpha.1\n```\n\n### 版本号标签\n\n> 常用的版本号标签如下：\n\n| 版本号标签   | 语义   | 说明                                                                                    |\n| :----------- | :----- | :-------------------------------------------------------------------------------------- |\n| latest       | 默认   | 不指定版本情况下默认安装的最新版本                                                      |\n| alpha        | 内测   | 内部测试版，一般不向外部发布，会有很多 BUG，一般只有测试人员使用                        |\n| beta         | 公测   | 也是测试版本，这个阶段的版本会一直加入新的功能，在 Alpha 版之后推出                     |\n| next         | 下一个 |                                                                                         |\n| rc           | 候选   | Release Candidate 系统平台上就是发行候选版本。RC 版不会再加入新的功能了，主要着重于除错 |\n| experimental | 实验   |                                                                                         |\n\n> 给版本号添加标签的方式有两种：\n\n```\n# 第一种方式：在发布时指定标签\n\n#  version-tag 替换为版本号标签的名称\n\nnpm publish --tag <version-tag>\n\n# 示例\n\nnpm publish --tag next react@0\n\nnpm publish --tag experimental vue@0\n\n# 第二种方式：发布后执行以下命令\n\n#  package-name 替换为 npm 包名字\n\n#  version 替换为 npm 包的指定版本\n\n#  version-tag 替换为版本号标签的名称\n\nnpm dist-tag add <package-name>@<version> <version-tag>\n\n# 示例\n\nnpm dist-tag add react@0 alpha\n\nnpm dist-tag add vue@0 next\n```\n\n### 版本号大小比较\n\n> 格式：\n\n```\nmajor.minor.patch-[pre-release]+[build-metadata]\n```\n\n> 版本号大小比较是从左往右依次比较 major、minor、patch、pre-release。build-metadata 对优先级无影响。\n\n> 现行版本优先级低于正式版本，如：\n\n-   ```\n    1-alpha.1 < 1\n    ```\n\n-   ```\n    0-alpha.1 < 0-beta < 0\n    ```\n\n> > 版本号大小与发版时间有关系吗？答案是 `没有关系`。\n\n> 例如：依次发布 `1.0.0-alpha.1`、`1.0.0-alpha.3`、`1.0.0-alpha.2`。用户安装了 `1.0.0-alpha.1`，此时升级版本会安装 `1.0.0-alpha.3`。\n\n> > 版本号升级与标签之间的关系？\n\n> 执行\n\n```\nnpm install <package-name>\n```\n\n或\n\n```\nnpm update <package-name>\n```\n\n等同于执行\n\n```\nnpm install <package-name>@latest\n```\n\n或\n\n```\nnpm update <pacakge-name>@latest\n```\n\n。用户当前版本低于 `latest` 标签下的最高版本，而低于其他标签下的版本时，会安装其他标签下的版本。\n\n> 例如：\n\n-   用户安装了 `1.0.0-alpha.1`（alpha），此时发布了 `1.0.0`（latest），用户升级后的版本是 `1.0.0`（latest）\n-   用户安装了 `1.0.0-alpha.1`（alpha），此时发布 `1.0.0-beta.0`（beta），用户升级后的版本时 `1.0.0-beta.0`（beta）\n-   用户安装了 `1.0.0`（latest），此时发布了 `2.0.0-alpha.1`（alpha），用户升级后的版本不变，仍然是 `1.0.0`（latest）\n\n### 版本工具使用\n\n> 在开发中肯定少不了对一些版本号的操作，如果这些版本号符合 SemVer 规范 ，我们可以借助用于操作版本的 npm 包 semver 来帮助我们进行比较版本大小、提取版本信息等操作。\n\n```\n# 安装工具\n\nnpm install semver\n```\n\n> 具体用法示例：\n\n```\n// 比较版本号大小\n\nsemver.gt('3', '7'); // false\n\nsemver.lt('3', '7'); // true\n\n// 判断版本号是否符合规范，返回解析后符合规范的版本号\n\nsemver.valid('3'); // '3'\n\nsemver.valid('a.b.c'); // null\n\n// 将其他版本号强制转换成 semver 版本号\n\nsemver.valid(semver.coerce('v2')); // '0'\n\nsemver.valid(semver.coerce('3-alpha')); // '7'\n\n// 一些其他用法\n\nsemver.clean('  =v3 '); // '3'\n\nsemver.satisfies('3', 'x || >= 0 || 0 - 23'); // true\n\nsemver.minVersion('>=0'); // '0'\n```\n\n> 更多关于 semver 用法，请查阅官网 https://github.com/npm/node-semver\n\n### 依赖版本管理\n\n> 我们经常看到，在 `package.json` 中各种依赖的不同写法：\n\n```\n\"dependencies\": {\n\n  \"signale\": \"0\",\n\n  \"figlet\": \"*\",\n\n  \"react\": \"x\",\n\n  \"table\": \"~6\",\n\n  \"yargs\": \"^0\"\n\n}\n```\n\n> 前三个容易理解：\n\n-   `\"signale\": \"1.4.0\"`：固定版本号\n-   `\"figlet\": \"*\"`：任意版本号（即 `>=0.0.0`）\n-   `\"react\": \"16.x\"`：匹配主要版本（`>=16.0.0 < 17.0.0`）\n-   `\"react\": \"16.3.x\"`：匹配主要版本和次要版本（`>=16.3.0 <16.4.0`）\n\n> 再看看后面两个，版本号包含 `~` 和 `^` 符号：\n\n-   `~`：当安装依赖时获取到有最新版本时，安装到 `x.y.z` 中 `z` 的最新版本。即保持主版本号、次版本号不变的情况下，保持修订号的最新版本\n-   `^`：当安装依赖时获取到由最新版本时，安装到 `x.y.z` 中 `y` 和 `z` 都为最新版本。即保持主版本号不变的情况下，保持次版本号、修订版本号为最新版本。\n\n> 在 `package.json` 中最常见应该时 `\"yargs\": \"^14.0.0\"` 这种格式的依赖，因为我们在使用\n\n```\nnpm install <package-name>\n```\n\n安装包时，`npm` 默认安装当前最新版本，然后在所安装的版本号前加 `^` 号。\n\n> 注意，当主版本号为 `0` 的情况，会被认为是一个不稳定版本，情况与上面不同：\n\n-   主版本号和次版本号都为 `0`: `^0.0.z`、`~0.0.z` 都被当作固定版本，安装依赖时均不会发生变化。 主版本号为 `0`: `^0.y.z` 表现和 `~0.y.z` 相同，只保持修订号为最新版本。\n\n> > `1.0.0` 的版本号用于界定公共 API。当你的软件发布到了正式环境，或者有稳定的 API 时，就可以发布 1.0.0 版本了。所以，当你决定对外部发布一个正式版本的 npm 包时，把它的版本标为 1.0.0。\n\n> 除此以外，还包含以下规则：\n\n-   `>`：接受高于指定版本的任何版本\n-   `>=` 接受等于或高于指定版本的任何版本\n-   `<=`：接受等于或低于指定版本的任何版本\n-   `<`：接受低于指定版本的任何版本\n-   `=`：接受确切的版本\n-   `-`：接受一定范围的版本，例如 `2.1.0 - 2.6.2`\n-   `||`：组合集合，例如 `< 2.1 || > 2.6`\n\n> 可以合并其中一些符号，例如\n\n```\n0 || >= 0 < 0\n```\n\n即使用 1.0.0 或从 1.1.0 开始但低于 1.2.0 的版本。\n\n### 锁定依赖版本\n\n> 实际开发中，经常会因为各种依赖不一致而产生奇怪的问题，或者在某些场景下，我们不希望依赖被更新，建议在开发中使用 package-lock.json。\n\n> 锁定依赖版本意味着在我们不手动执行更新的情况下，每次安装依赖都会安装固定版本。保证整个团队使用版本号一致的依赖。\n\n> 每次安装固定版本，无需计算依赖版本范围，大部分场景下能大大加速依赖安装时间。\n\n> 使用 package-lock.json 要确保 npm 的版本在 5.6 以上，因为在 5.0 - 5.6 中间，对 package-lock.json 的处理逻辑进行过几次更新，5.6 版本后处理逻辑逐渐稳定。\n\n> 关于 package-lock.json 详细的结构，我们会在后面的章节进行解析。\n\n### 定期更新依赖\n\n> 实际开发场景下，我们虽然不需要每次都去安装新的版本，仍然需要定时去升级依赖版本，来让我们享受依赖包升级带来的问题修复、性能提升、新特性更新。\n\n> 使用 `npm outdated` 可以帮助我们列出哪些还没有升级到最新版本的依赖：\n\n-   黄色表示不符合我们指定的语意化版本范围 - 不需要升级\n-   红色表示符合指定的语意化版本范围 - 需要升级\n\n> 执行 `npm update` 会升级所有的红色依赖。\n\n### 依赖版本控制的最佳实践\n\n### 参考资料\n\n-   语义化版本 2.0.0\n","source":"_posts/Npm/Npm版本控制.md","raw":"---\ntitle: Npm版本控制\ndate: 2023-02-08 11:31:02\ntags: Npm\n---\n\n## npm 版本控制\n\n### 查看依赖包版本\n\n> 通过执行以下命令能够查看某个依赖包的最新版本。\n\n```\n# 查看某个 package 的注册信息\n\nnpm view <package-name>\n\n# 查看某个 package 的最新版本\n\nnpm view <package-name> version\n\n# 查看某个 package 在 npm 服务器上所发布过的版本\n\nnpm view <package-name> versions\n\n# 查看仓库依赖树上所有包的版本信息\n\nnpm ls\n```\n\n### 语义化版本规范\n\n> npm 中的包模块版本都需要遵循 SemVer（Semantic Version，语义化版本）规范，这是由 Github 起草的一个具有指导意义的，统一的版本号表示规则。\n\n### 标准版本\n\n> SemVer 规范的标准版本号采用 `X.Y.Z` 的格式，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须以数值来递增。\n\n-   主版本号（major）：当你做了不兼容的 API 修改\n-   次版本号（minor）：当你做了向下兼容的功能性新增\n-   修订号（patch）：当你做了向下兼容的问题修正。\n\n> 版本是严格递增的，例如：16.2.0 -> 16.2.1 -> 16.3.0 -> 16.4.0\n\n### 先行版本\n\n> 当某个版本改动比较大、并非稳定而且可能无法满足预期的兼容性需求时，你可能要先发布一个先行版本。\n\n> 先行版本的格式是在修订版本号后面加上一个连接号（`-`），再加上一连串以点（`.`）分割的标识符，标识符可以由英文、数字和连接号（`[0-9A-Za-z]`）组成。\n\n> 例如：\n\n```\n# 格式\n\nmajor.minor.patch-{identifier}.{identifier}.{identifier}\n\n# 示例 1：通常第一个 identifier 为版本号标签，关于版本号标签请看下文\n\n# 常用于先行版本的版本号标签是 beta、rc、experimental\n\n3-alpha.1\n```\n\n### 版本号标签\n\n> 常用的版本号标签如下：\n\n| 版本号标签   | 语义   | 说明                                                                                    |\n| :----------- | :----- | :-------------------------------------------------------------------------------------- |\n| latest       | 默认   | 不指定版本情况下默认安装的最新版本                                                      |\n| alpha        | 内测   | 内部测试版，一般不向外部发布，会有很多 BUG，一般只有测试人员使用                        |\n| beta         | 公测   | 也是测试版本，这个阶段的版本会一直加入新的功能，在 Alpha 版之后推出                     |\n| next         | 下一个 |                                                                                         |\n| rc           | 候选   | Release Candidate 系统平台上就是发行候选版本。RC 版不会再加入新的功能了，主要着重于除错 |\n| experimental | 实验   |                                                                                         |\n\n> 给版本号添加标签的方式有两种：\n\n```\n# 第一种方式：在发布时指定标签\n\n#  version-tag 替换为版本号标签的名称\n\nnpm publish --tag <version-tag>\n\n# 示例\n\nnpm publish --tag next react@0\n\nnpm publish --tag experimental vue@0\n\n# 第二种方式：发布后执行以下命令\n\n#  package-name 替换为 npm 包名字\n\n#  version 替换为 npm 包的指定版本\n\n#  version-tag 替换为版本号标签的名称\n\nnpm dist-tag add <package-name>@<version> <version-tag>\n\n# 示例\n\nnpm dist-tag add react@0 alpha\n\nnpm dist-tag add vue@0 next\n```\n\n### 版本号大小比较\n\n> 格式：\n\n```\nmajor.minor.patch-[pre-release]+[build-metadata]\n```\n\n> 版本号大小比较是从左往右依次比较 major、minor、patch、pre-release。build-metadata 对优先级无影响。\n\n> 现行版本优先级低于正式版本，如：\n\n-   ```\n    1-alpha.1 < 1\n    ```\n\n-   ```\n    0-alpha.1 < 0-beta < 0\n    ```\n\n> > 版本号大小与发版时间有关系吗？答案是 `没有关系`。\n\n> 例如：依次发布 `1.0.0-alpha.1`、`1.0.0-alpha.3`、`1.0.0-alpha.2`。用户安装了 `1.0.0-alpha.1`，此时升级版本会安装 `1.0.0-alpha.3`。\n\n> > 版本号升级与标签之间的关系？\n\n> 执行\n\n```\nnpm install <package-name>\n```\n\n或\n\n```\nnpm update <package-name>\n```\n\n等同于执行\n\n```\nnpm install <package-name>@latest\n```\n\n或\n\n```\nnpm update <pacakge-name>@latest\n```\n\n。用户当前版本低于 `latest` 标签下的最高版本，而低于其他标签下的版本时，会安装其他标签下的版本。\n\n> 例如：\n\n-   用户安装了 `1.0.0-alpha.1`（alpha），此时发布了 `1.0.0`（latest），用户升级后的版本是 `1.0.0`（latest）\n-   用户安装了 `1.0.0-alpha.1`（alpha），此时发布 `1.0.0-beta.0`（beta），用户升级后的版本时 `1.0.0-beta.0`（beta）\n-   用户安装了 `1.0.0`（latest），此时发布了 `2.0.0-alpha.1`（alpha），用户升级后的版本不变，仍然是 `1.0.0`（latest）\n\n### 版本工具使用\n\n> 在开发中肯定少不了对一些版本号的操作，如果这些版本号符合 SemVer 规范 ，我们可以借助用于操作版本的 npm 包 semver 来帮助我们进行比较版本大小、提取版本信息等操作。\n\n```\n# 安装工具\n\nnpm install semver\n```\n\n> 具体用法示例：\n\n```\n// 比较版本号大小\n\nsemver.gt('3', '7'); // false\n\nsemver.lt('3', '7'); // true\n\n// 判断版本号是否符合规范，返回解析后符合规范的版本号\n\nsemver.valid('3'); // '3'\n\nsemver.valid('a.b.c'); // null\n\n// 将其他版本号强制转换成 semver 版本号\n\nsemver.valid(semver.coerce('v2')); // '0'\n\nsemver.valid(semver.coerce('3-alpha')); // '7'\n\n// 一些其他用法\n\nsemver.clean('  =v3 '); // '3'\n\nsemver.satisfies('3', 'x || >= 0 || 0 - 23'); // true\n\nsemver.minVersion('>=0'); // '0'\n```\n\n> 更多关于 semver 用法，请查阅官网 https://github.com/npm/node-semver\n\n### 依赖版本管理\n\n> 我们经常看到，在 `package.json` 中各种依赖的不同写法：\n\n```\n\"dependencies\": {\n\n  \"signale\": \"0\",\n\n  \"figlet\": \"*\",\n\n  \"react\": \"x\",\n\n  \"table\": \"~6\",\n\n  \"yargs\": \"^0\"\n\n}\n```\n\n> 前三个容易理解：\n\n-   `\"signale\": \"1.4.0\"`：固定版本号\n-   `\"figlet\": \"*\"`：任意版本号（即 `>=0.0.0`）\n-   `\"react\": \"16.x\"`：匹配主要版本（`>=16.0.0 < 17.0.0`）\n-   `\"react\": \"16.3.x\"`：匹配主要版本和次要版本（`>=16.3.0 <16.4.0`）\n\n> 再看看后面两个，版本号包含 `~` 和 `^` 符号：\n\n-   `~`：当安装依赖时获取到有最新版本时，安装到 `x.y.z` 中 `z` 的最新版本。即保持主版本号、次版本号不变的情况下，保持修订号的最新版本\n-   `^`：当安装依赖时获取到由最新版本时，安装到 `x.y.z` 中 `y` 和 `z` 都为最新版本。即保持主版本号不变的情况下，保持次版本号、修订版本号为最新版本。\n\n> 在 `package.json` 中最常见应该时 `\"yargs\": \"^14.0.0\"` 这种格式的依赖，因为我们在使用\n\n```\nnpm install <package-name>\n```\n\n安装包时，`npm` 默认安装当前最新版本，然后在所安装的版本号前加 `^` 号。\n\n> 注意，当主版本号为 `0` 的情况，会被认为是一个不稳定版本，情况与上面不同：\n\n-   主版本号和次版本号都为 `0`: `^0.0.z`、`~0.0.z` 都被当作固定版本，安装依赖时均不会发生变化。 主版本号为 `0`: `^0.y.z` 表现和 `~0.y.z` 相同，只保持修订号为最新版本。\n\n> > `1.0.0` 的版本号用于界定公共 API。当你的软件发布到了正式环境，或者有稳定的 API 时，就可以发布 1.0.0 版本了。所以，当你决定对外部发布一个正式版本的 npm 包时，把它的版本标为 1.0.0。\n\n> 除此以外，还包含以下规则：\n\n-   `>`：接受高于指定版本的任何版本\n-   `>=` 接受等于或高于指定版本的任何版本\n-   `<=`：接受等于或低于指定版本的任何版本\n-   `<`：接受低于指定版本的任何版本\n-   `=`：接受确切的版本\n-   `-`：接受一定范围的版本，例如 `2.1.0 - 2.6.2`\n-   `||`：组合集合，例如 `< 2.1 || > 2.6`\n\n> 可以合并其中一些符号，例如\n\n```\n0 || >= 0 < 0\n```\n\n即使用 1.0.0 或从 1.1.0 开始但低于 1.2.0 的版本。\n\n### 锁定依赖版本\n\n> 实际开发中，经常会因为各种依赖不一致而产生奇怪的问题，或者在某些场景下，我们不希望依赖被更新，建议在开发中使用 package-lock.json。\n\n> 锁定依赖版本意味着在我们不手动执行更新的情况下，每次安装依赖都会安装固定版本。保证整个团队使用版本号一致的依赖。\n\n> 每次安装固定版本，无需计算依赖版本范围，大部分场景下能大大加速依赖安装时间。\n\n> 使用 package-lock.json 要确保 npm 的版本在 5.6 以上，因为在 5.0 - 5.6 中间，对 package-lock.json 的处理逻辑进行过几次更新，5.6 版本后处理逻辑逐渐稳定。\n\n> 关于 package-lock.json 详细的结构，我们会在后面的章节进行解析。\n\n### 定期更新依赖\n\n> 实际开发场景下，我们虽然不需要每次都去安装新的版本，仍然需要定时去升级依赖版本，来让我们享受依赖包升级带来的问题修复、性能提升、新特性更新。\n\n> 使用 `npm outdated` 可以帮助我们列出哪些还没有升级到最新版本的依赖：\n\n-   黄色表示不符合我们指定的语意化版本范围 - 不需要升级\n-   红色表示符合指定的语意化版本范围 - 需要升级\n\n> 执行 `npm update` 会升级所有的红色依赖。\n\n### 依赖版本控制的最佳实践\n\n### 参考资料\n\n-   语义化版本 2.0.0\n","slug":"Npm/Npm版本控制","published":1,"updated":"2023-02-21T09:35:15.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iulv000rbkh0be0o486q","content":"<h2 id=\"npm-版本控制\"><a href=\"#npm-版本控制\" class=\"headerlink\" title=\"npm 版本控制\"></a>npm 版本控制</h2><h3 id=\"查看依赖包版本\"><a href=\"#查看依赖包版本\" class=\"headerlink\" title=\"查看依赖包版本\"></a>查看依赖包版本</h3><blockquote>\n<p>通过执行以下命令能够查看某个依赖包的最新版本。</p>\n</blockquote>\n<pre><code># 查看某个 package 的注册信息\n\nnpm view &lt;package-name&gt;\n\n# 查看某个 package 的最新版本\n\nnpm view &lt;package-name&gt; version\n\n# 查看某个 package 在 npm 服务器上所发布过的版本\n\nnpm view &lt;package-name&gt; versions\n\n# 查看仓库依赖树上所有包的版本信息\n\nnpm ls\n</code></pre>\n<h3 id=\"语义化版本规范\"><a href=\"#语义化版本规范\" class=\"headerlink\" title=\"语义化版本规范\"></a>语义化版本规范</h3><blockquote>\n<p>npm 中的包模块版本都需要遵循 SemVer（Semantic Version，语义化版本）规范，这是由 Github 起草的一个具有指导意义的，统一的版本号表示规则。</p>\n</blockquote>\n<h3 id=\"标准版本\"><a href=\"#标准版本\" class=\"headerlink\" title=\"标准版本\"></a>标准版本</h3><blockquote>\n<p>SemVer 规范的标准版本号采用 <code>X.Y.Z</code> 的格式，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须以数值来递增。</p>\n</blockquote>\n<ul>\n<li>主版本号（major）：当你做了不兼容的 API 修改</li>\n<li>次版本号（minor）：当你做了向下兼容的功能性新增</li>\n<li>修订号（patch）：当你做了向下兼容的问题修正。</li>\n</ul>\n<blockquote>\n<p>版本是严格递增的，例如：16.2.0 -&gt; 16.2.1 -&gt; 16.3.0 -&gt; 16.4.0</p>\n</blockquote>\n<h3 id=\"先行版本\"><a href=\"#先行版本\" class=\"headerlink\" title=\"先行版本\"></a>先行版本</h3><blockquote>\n<p>当某个版本改动比较大、并非稳定而且可能无法满足预期的兼容性需求时，你可能要先发布一个先行版本。</p>\n</blockquote>\n<blockquote>\n<p>先行版本的格式是在修订版本号后面加上一个连接号（<code>-</code>），再加上一连串以点（<code>.</code>）分割的标识符，标识符可以由英文、数字和连接号（<code>[0-9A-Za-z]</code>）组成。</p>\n</blockquote>\n<blockquote>\n<p>例如：</p>\n</blockquote>\n<pre><code># 格式\n\nmajor.minor.patch-&#123;identifier&#125;.&#123;identifier&#125;.&#123;identifier&#125;\n\n# 示例 1：通常第一个 identifier 为版本号标签，关于版本号标签请看下文\n\n# 常用于先行版本的版本号标签是 beta、rc、experimental\n\n3-alpha.1\n</code></pre>\n<h3 id=\"版本号标签\"><a href=\"#版本号标签\" class=\"headerlink\" title=\"版本号标签\"></a>版本号标签</h3><blockquote>\n<p>常用的版本号标签如下：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">版本号标签</th>\n<th align=\"left\">语义</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">latest</td>\n<td align=\"left\">默认</td>\n<td align=\"left\">不指定版本情况下默认安装的最新版本</td>\n</tr>\n<tr>\n<td align=\"left\">alpha</td>\n<td align=\"left\">内测</td>\n<td align=\"left\">内部测试版，一般不向外部发布，会有很多 BUG，一般只有测试人员使用</td>\n</tr>\n<tr>\n<td align=\"left\">beta</td>\n<td align=\"left\">公测</td>\n<td align=\"left\">也是测试版本，这个阶段的版本会一直加入新的功能，在 Alpha 版之后推出</td>\n</tr>\n<tr>\n<td align=\"left\">next</td>\n<td align=\"left\">下一个</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">rc</td>\n<td align=\"left\">候选</td>\n<td align=\"left\">Release Candidate 系统平台上就是发行候选版本。RC 版不会再加入新的功能了，主要着重于除错</td>\n</tr>\n<tr>\n<td align=\"left\">experimental</td>\n<td align=\"left\">实验</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>给版本号添加标签的方式有两种：</p>\n</blockquote>\n<pre><code># 第一种方式：在发布时指定标签\n\n#  version-tag 替换为版本号标签的名称\n\nnpm publish --tag &lt;version-tag&gt;\n\n# 示例\n\nnpm publish --tag next react@0\n\nnpm publish --tag experimental vue@0\n\n# 第二种方式：发布后执行以下命令\n\n#  package-name 替换为 npm 包名字\n\n#  version 替换为 npm 包的指定版本\n\n#  version-tag 替换为版本号标签的名称\n\nnpm dist-tag add &lt;package-name&gt;@&lt;version&gt; &lt;version-tag&gt;\n\n# 示例\n\nnpm dist-tag add react@0 alpha\n\nnpm dist-tag add vue@0 next\n</code></pre>\n<h3 id=\"版本号大小比较\"><a href=\"#版本号大小比较\" class=\"headerlink\" title=\"版本号大小比较\"></a>版本号大小比较</h3><blockquote>\n<p>格式：</p>\n</blockquote>\n<pre><code>major.minor.patch-[pre-release]+[build-metadata]\n</code></pre>\n<blockquote>\n<p>版本号大小比较是从左往右依次比较 major、minor、patch、pre-release。build-metadata 对优先级无影响。</p>\n</blockquote>\n<blockquote>\n<p>现行版本优先级低于正式版本，如：</p>\n</blockquote>\n<ul>\n<li><pre><code>1-alpha.1 &lt; 1\n</code></pre>\n</li>\n<li><pre><code>0-alpha.1 &lt; 0-beta &lt; 0\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<blockquote>\n<p>版本号大小与发版时间有关系吗？答案是 <code>没有关系</code>。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>例如：依次发布 <code>1.0.0-alpha.1</code>、<code>1.0.0-alpha.3</code>、<code>1.0.0-alpha.2</code>。用户安装了 <code>1.0.0-alpha.1</code>，此时升级版本会安装 <code>1.0.0-alpha.3</code>。</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>版本号升级与标签之间的关系？</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>执行</p>\n</blockquote>\n<pre><code>npm install &lt;package-name&gt;\n</code></pre>\n<p>或</p>\n<pre><code>npm update &lt;package-name&gt;\n</code></pre>\n<p>等同于执行</p>\n<pre><code>npm install &lt;package-name&gt;@latest\n</code></pre>\n<p>或</p>\n<pre><code>npm update &lt;pacakge-name&gt;@latest\n</code></pre>\n<p>。用户当前版本低于 <code>latest</code> 标签下的最高版本，而低于其他标签下的版本时，会安装其他标签下的版本。</p>\n<blockquote>\n<p>例如：</p>\n</blockquote>\n<ul>\n<li>用户安装了 <code>1.0.0-alpha.1</code>（alpha），此时发布了 <code>1.0.0</code>（latest），用户升级后的版本是 <code>1.0.0</code>（latest）</li>\n<li>用户安装了 <code>1.0.0-alpha.1</code>（alpha），此时发布 <code>1.0.0-beta.0</code>（beta），用户升级后的版本时 <code>1.0.0-beta.0</code>（beta）</li>\n<li>用户安装了 <code>1.0.0</code>（latest），此时发布了 <code>2.0.0-alpha.1</code>（alpha），用户升级后的版本不变，仍然是 <code>1.0.0</code>（latest）</li>\n</ul>\n<h3 id=\"版本工具使用\"><a href=\"#版本工具使用\" class=\"headerlink\" title=\"版本工具使用\"></a>版本工具使用</h3><blockquote>\n<p>在开发中肯定少不了对一些版本号的操作，如果这些版本号符合 SemVer 规范 ，我们可以借助用于操作版本的 npm 包 semver 来帮助我们进行比较版本大小、提取版本信息等操作。</p>\n</blockquote>\n<pre><code># 安装工具\n\nnpm install semver\n</code></pre>\n<blockquote>\n<p>具体用法示例：</p>\n</blockquote>\n<pre><code>// 比较版本号大小\n\nsemver.gt(&#39;3&#39;, &#39;7&#39;); // false\n\nsemver.lt(&#39;3&#39;, &#39;7&#39;); // true\n\n// 判断版本号是否符合规范，返回解析后符合规范的版本号\n\nsemver.valid(&#39;3&#39;); // &#39;3&#39;\n\nsemver.valid(&#39;a.b.c&#39;); // null\n\n// 将其他版本号强制转换成 semver 版本号\n\nsemver.valid(semver.coerce(&#39;v2&#39;)); // &#39;0&#39;\n\nsemver.valid(semver.coerce(&#39;3-alpha&#39;)); // &#39;7&#39;\n\n// 一些其他用法\n\nsemver.clean(&#39;  =v3 &#39;); // &#39;3&#39;\n\nsemver.satisfies(&#39;3&#39;, &#39;x || &gt;= 0 || 0 - 23&#39;); // true\n\nsemver.minVersion(&#39;&gt;=0&#39;); // &#39;0&#39;\n</code></pre>\n<blockquote>\n<p>更多关于 semver 用法，请查阅官网 <a href=\"https://github.com/npm/node-semver\">https://github.com/npm/node-semver</a></p>\n</blockquote>\n<h3 id=\"依赖版本管理\"><a href=\"#依赖版本管理\" class=\"headerlink\" title=\"依赖版本管理\"></a>依赖版本管理</h3><blockquote>\n<p>我们经常看到，在 <code>package.json</code> 中各种依赖的不同写法：</p>\n</blockquote>\n<pre><code>&quot;dependencies&quot;: &#123;\n\n  &quot;signale&quot;: &quot;0&quot;,\n\n  &quot;figlet&quot;: &quot;*&quot;,\n\n  &quot;react&quot;: &quot;x&quot;,\n\n  &quot;table&quot;: &quot;~6&quot;,\n\n  &quot;yargs&quot;: &quot;^0&quot;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>前三个容易理解：</p>\n</blockquote>\n<ul>\n<li><code>&quot;signale&quot;: &quot;1.4.0&quot;</code>：固定版本号</li>\n<li><code>&quot;figlet&quot;: &quot;*&quot;</code>：任意版本号（即 <code>&gt;=0.0.0</code>）</li>\n<li><code>&quot;react&quot;: &quot;16.x&quot;</code>：匹配主要版本（<code>&gt;=16.0.0 &lt; 17.0.0</code>）</li>\n<li><code>&quot;react&quot;: &quot;16.3.x&quot;</code>：匹配主要版本和次要版本（<code>&gt;=16.3.0 &lt;16.4.0</code>）</li>\n</ul>\n<blockquote>\n<p>再看看后面两个，版本号包含 <code>~</code> 和 <code>^</code> 符号：</p>\n</blockquote>\n<ul>\n<li><code>~</code>：当安装依赖时获取到有最新版本时，安装到 <code>x.y.z</code> 中 <code>z</code> 的最新版本。即保持主版本号、次版本号不变的情况下，保持修订号的最新版本</li>\n<li><code>^</code>：当安装依赖时获取到由最新版本时，安装到 <code>x.y.z</code> 中 <code>y</code> 和 <code>z</code> 都为最新版本。即保持主版本号不变的情况下，保持次版本号、修订版本号为最新版本。</li>\n</ul>\n<blockquote>\n<p>在 <code>package.json</code> 中最常见应该时 <code>&quot;yargs&quot;: &quot;^14.0.0&quot;</code> 这种格式的依赖，因为我们在使用</p>\n</blockquote>\n<pre><code>npm install &lt;package-name&gt;\n</code></pre>\n<p>安装包时，<code>npm</code> 默认安装当前最新版本，然后在所安装的版本号前加 <code>^</code> 号。</p>\n<blockquote>\n<p>注意，当主版本号为 <code>0</code> 的情况，会被认为是一个不稳定版本，情况与上面不同：</p>\n</blockquote>\n<ul>\n<li>主版本号和次版本号都为 <code>0</code>: <code>^0.0.z</code>、<code>~0.0.z</code> 都被当作固定版本，安装依赖时均不会发生变化。 主版本号为 <code>0</code>: <code>^0.y.z</code> 表现和 <code>~0.y.z</code> 相同，只保持修订号为最新版本。</li>\n</ul>\n<blockquote>\n<blockquote>\n<p><code>1.0.0</code> 的版本号用于界定公共 API。当你的软件发布到了正式环境，或者有稳定的 API 时，就可以发布 1.0.0 版本了。所以，当你决定对外部发布一个正式版本的 npm 包时，把它的版本标为 1.0.0。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>除此以外，还包含以下规则：</p>\n</blockquote>\n<ul>\n<li><code>&gt;</code>：接受高于指定版本的任何版本</li>\n<li><code>&gt;=</code> 接受等于或高于指定版本的任何版本</li>\n<li><code>&lt;=</code>：接受等于或低于指定版本的任何版本</li>\n<li><code>&lt;</code>：接受低于指定版本的任何版本</li>\n<li><code>=</code>：接受确切的版本</li>\n<li><code>-</code>：接受一定范围的版本，例如 <code>2.1.0 - 2.6.2</code></li>\n<li><code>||</code>：组合集合，例如 <code>&lt; 2.1 || &gt; 2.6</code></li>\n</ul>\n<blockquote>\n<p>可以合并其中一些符号，例如</p>\n</blockquote>\n<pre><code>0 || &gt;= 0 &lt; 0\n</code></pre>\n<p>即使用 1.0.0 或从 1.1.0 开始但低于 1.2.0 的版本。</p>\n<h3 id=\"锁定依赖版本\"><a href=\"#锁定依赖版本\" class=\"headerlink\" title=\"锁定依赖版本\"></a>锁定依赖版本</h3><blockquote>\n<p>实际开发中，经常会因为各种依赖不一致而产生奇怪的问题，或者在某些场景下，我们不希望依赖被更新，建议在开发中使用 package-lock.json。</p>\n</blockquote>\n<blockquote>\n<p>锁定依赖版本意味着在我们不手动执行更新的情况下，每次安装依赖都会安装固定版本。保证整个团队使用版本号一致的依赖。</p>\n</blockquote>\n<blockquote>\n<p>每次安装固定版本，无需计算依赖版本范围，大部分场景下能大大加速依赖安装时间。</p>\n</blockquote>\n<blockquote>\n<p>使用 package-lock.json 要确保 npm 的版本在 5.6 以上，因为在 5.0 - 5.6 中间，对 package-lock.json 的处理逻辑进行过几次更新，5.6 版本后处理逻辑逐渐稳定。</p>\n</blockquote>\n<blockquote>\n<p>关于 package-lock.json 详细的结构，我们会在后面的章节进行解析。</p>\n</blockquote>\n<h3 id=\"定期更新依赖\"><a href=\"#定期更新依赖\" class=\"headerlink\" title=\"定期更新依赖\"></a>定期更新依赖</h3><blockquote>\n<p>实际开发场景下，我们虽然不需要每次都去安装新的版本，仍然需要定时去升级依赖版本，来让我们享受依赖包升级带来的问题修复、性能提升、新特性更新。</p>\n</blockquote>\n<blockquote>\n<p>使用 <code>npm outdated</code> 可以帮助我们列出哪些还没有升级到最新版本的依赖：</p>\n</blockquote>\n<ul>\n<li>黄色表示不符合我们指定的语意化版本范围 - 不需要升级</li>\n<li>红色表示符合指定的语意化版本范围 - 需要升级</li>\n</ul>\n<blockquote>\n<p>执行 <code>npm update</code> 会升级所有的红色依赖。</p>\n</blockquote>\n<h3 id=\"依赖版本控制的最佳实践\"><a href=\"#依赖版本控制的最佳实践\" class=\"headerlink\" title=\"依赖版本控制的最佳实践\"></a>依赖版本控制的最佳实践</h3><h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li>语义化版本 2.0.0</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"npm-版本控制\"><a href=\"#npm-版本控制\" class=\"headerlink\" title=\"npm 版本控制\"></a>npm 版本控制</h2><h3 id=\"查看依赖包版本\"><a href=\"#查看依赖包版本\" class=\"headerlink\" title=\"查看依赖包版本\"></a>查看依赖包版本</h3><blockquote>\n<p>通过执行以下命令能够查看某个依赖包的最新版本。</p>\n</blockquote>\n<pre><code># 查看某个 package 的注册信息\n\nnpm view &lt;package-name&gt;\n\n# 查看某个 package 的最新版本\n\nnpm view &lt;package-name&gt; version\n\n# 查看某个 package 在 npm 服务器上所发布过的版本\n\nnpm view &lt;package-name&gt; versions\n\n# 查看仓库依赖树上所有包的版本信息\n\nnpm ls\n</code></pre>\n<h3 id=\"语义化版本规范\"><a href=\"#语义化版本规范\" class=\"headerlink\" title=\"语义化版本规范\"></a>语义化版本规范</h3><blockquote>\n<p>npm 中的包模块版本都需要遵循 SemVer（Semantic Version，语义化版本）规范，这是由 Github 起草的一个具有指导意义的，统一的版本号表示规则。</p>\n</blockquote>\n<h3 id=\"标准版本\"><a href=\"#标准版本\" class=\"headerlink\" title=\"标准版本\"></a>标准版本</h3><blockquote>\n<p>SemVer 规范的标准版本号采用 <code>X.Y.Z</code> 的格式，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须以数值来递增。</p>\n</blockquote>\n<ul>\n<li>主版本号（major）：当你做了不兼容的 API 修改</li>\n<li>次版本号（minor）：当你做了向下兼容的功能性新增</li>\n<li>修订号（patch）：当你做了向下兼容的问题修正。</li>\n</ul>\n<blockquote>\n<p>版本是严格递增的，例如：16.2.0 -&gt; 16.2.1 -&gt; 16.3.0 -&gt; 16.4.0</p>\n</blockquote>\n<h3 id=\"先行版本\"><a href=\"#先行版本\" class=\"headerlink\" title=\"先行版本\"></a>先行版本</h3><blockquote>\n<p>当某个版本改动比较大、并非稳定而且可能无法满足预期的兼容性需求时，你可能要先发布一个先行版本。</p>\n</blockquote>\n<blockquote>\n<p>先行版本的格式是在修订版本号后面加上一个连接号（<code>-</code>），再加上一连串以点（<code>.</code>）分割的标识符，标识符可以由英文、数字和连接号（<code>[0-9A-Za-z]</code>）组成。</p>\n</blockquote>\n<blockquote>\n<p>例如：</p>\n</blockquote>\n<pre><code># 格式\n\nmajor.minor.patch-&#123;identifier&#125;.&#123;identifier&#125;.&#123;identifier&#125;\n\n# 示例 1：通常第一个 identifier 为版本号标签，关于版本号标签请看下文\n\n# 常用于先行版本的版本号标签是 beta、rc、experimental\n\n3-alpha.1\n</code></pre>\n<h3 id=\"版本号标签\"><a href=\"#版本号标签\" class=\"headerlink\" title=\"版本号标签\"></a>版本号标签</h3><blockquote>\n<p>常用的版本号标签如下：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">版本号标签</th>\n<th align=\"left\">语义</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">latest</td>\n<td align=\"left\">默认</td>\n<td align=\"left\">不指定版本情况下默认安装的最新版本</td>\n</tr>\n<tr>\n<td align=\"left\">alpha</td>\n<td align=\"left\">内测</td>\n<td align=\"left\">内部测试版，一般不向外部发布，会有很多 BUG，一般只有测试人员使用</td>\n</tr>\n<tr>\n<td align=\"left\">beta</td>\n<td align=\"left\">公测</td>\n<td align=\"left\">也是测试版本，这个阶段的版本会一直加入新的功能，在 Alpha 版之后推出</td>\n</tr>\n<tr>\n<td align=\"left\">next</td>\n<td align=\"left\">下一个</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">rc</td>\n<td align=\"left\">候选</td>\n<td align=\"left\">Release Candidate 系统平台上就是发行候选版本。RC 版不会再加入新的功能了，主要着重于除错</td>\n</tr>\n<tr>\n<td align=\"left\">experimental</td>\n<td align=\"left\">实验</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>给版本号添加标签的方式有两种：</p>\n</blockquote>\n<pre><code># 第一种方式：在发布时指定标签\n\n#  version-tag 替换为版本号标签的名称\n\nnpm publish --tag &lt;version-tag&gt;\n\n# 示例\n\nnpm publish --tag next react@0\n\nnpm publish --tag experimental vue@0\n\n# 第二种方式：发布后执行以下命令\n\n#  package-name 替换为 npm 包名字\n\n#  version 替换为 npm 包的指定版本\n\n#  version-tag 替换为版本号标签的名称\n\nnpm dist-tag add &lt;package-name&gt;@&lt;version&gt; &lt;version-tag&gt;\n\n# 示例\n\nnpm dist-tag add react@0 alpha\n\nnpm dist-tag add vue@0 next\n</code></pre>\n<h3 id=\"版本号大小比较\"><a href=\"#版本号大小比较\" class=\"headerlink\" title=\"版本号大小比较\"></a>版本号大小比较</h3><blockquote>\n<p>格式：</p>\n</blockquote>\n<pre><code>major.minor.patch-[pre-release]+[build-metadata]\n</code></pre>\n<blockquote>\n<p>版本号大小比较是从左往右依次比较 major、minor、patch、pre-release。build-metadata 对优先级无影响。</p>\n</blockquote>\n<blockquote>\n<p>现行版本优先级低于正式版本，如：</p>\n</blockquote>\n<ul>\n<li><pre><code>1-alpha.1 &lt; 1\n</code></pre>\n</li>\n<li><pre><code>0-alpha.1 &lt; 0-beta &lt; 0\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<blockquote>\n<p>版本号大小与发版时间有关系吗？答案是 <code>没有关系</code>。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>例如：依次发布 <code>1.0.0-alpha.1</code>、<code>1.0.0-alpha.3</code>、<code>1.0.0-alpha.2</code>。用户安装了 <code>1.0.0-alpha.1</code>，此时升级版本会安装 <code>1.0.0-alpha.3</code>。</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>版本号升级与标签之间的关系？</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>执行</p>\n</blockquote>\n<pre><code>npm install &lt;package-name&gt;\n</code></pre>\n<p>或</p>\n<pre><code>npm update &lt;package-name&gt;\n</code></pre>\n<p>等同于执行</p>\n<pre><code>npm install &lt;package-name&gt;@latest\n</code></pre>\n<p>或</p>\n<pre><code>npm update &lt;pacakge-name&gt;@latest\n</code></pre>\n<p>。用户当前版本低于 <code>latest</code> 标签下的最高版本，而低于其他标签下的版本时，会安装其他标签下的版本。</p>\n<blockquote>\n<p>例如：</p>\n</blockquote>\n<ul>\n<li>用户安装了 <code>1.0.0-alpha.1</code>（alpha），此时发布了 <code>1.0.0</code>（latest），用户升级后的版本是 <code>1.0.0</code>（latest）</li>\n<li>用户安装了 <code>1.0.0-alpha.1</code>（alpha），此时发布 <code>1.0.0-beta.0</code>（beta），用户升级后的版本时 <code>1.0.0-beta.0</code>（beta）</li>\n<li>用户安装了 <code>1.0.0</code>（latest），此时发布了 <code>2.0.0-alpha.1</code>（alpha），用户升级后的版本不变，仍然是 <code>1.0.0</code>（latest）</li>\n</ul>\n<h3 id=\"版本工具使用\"><a href=\"#版本工具使用\" class=\"headerlink\" title=\"版本工具使用\"></a>版本工具使用</h3><blockquote>\n<p>在开发中肯定少不了对一些版本号的操作，如果这些版本号符合 SemVer 规范 ，我们可以借助用于操作版本的 npm 包 semver 来帮助我们进行比较版本大小、提取版本信息等操作。</p>\n</blockquote>\n<pre><code># 安装工具\n\nnpm install semver\n</code></pre>\n<blockquote>\n<p>具体用法示例：</p>\n</blockquote>\n<pre><code>// 比较版本号大小\n\nsemver.gt(&#39;3&#39;, &#39;7&#39;); // false\n\nsemver.lt(&#39;3&#39;, &#39;7&#39;); // true\n\n// 判断版本号是否符合规范，返回解析后符合规范的版本号\n\nsemver.valid(&#39;3&#39;); // &#39;3&#39;\n\nsemver.valid(&#39;a.b.c&#39;); // null\n\n// 将其他版本号强制转换成 semver 版本号\n\nsemver.valid(semver.coerce(&#39;v2&#39;)); // &#39;0&#39;\n\nsemver.valid(semver.coerce(&#39;3-alpha&#39;)); // &#39;7&#39;\n\n// 一些其他用法\n\nsemver.clean(&#39;  =v3 &#39;); // &#39;3&#39;\n\nsemver.satisfies(&#39;3&#39;, &#39;x || &gt;= 0 || 0 - 23&#39;); // true\n\nsemver.minVersion(&#39;&gt;=0&#39;); // &#39;0&#39;\n</code></pre>\n<blockquote>\n<p>更多关于 semver 用法，请查阅官网 <a href=\"https://github.com/npm/node-semver\">https://github.com/npm/node-semver</a></p>\n</blockquote>\n<h3 id=\"依赖版本管理\"><a href=\"#依赖版本管理\" class=\"headerlink\" title=\"依赖版本管理\"></a>依赖版本管理</h3><blockquote>\n<p>我们经常看到，在 <code>package.json</code> 中各种依赖的不同写法：</p>\n</blockquote>\n<pre><code>&quot;dependencies&quot;: &#123;\n\n  &quot;signale&quot;: &quot;0&quot;,\n\n  &quot;figlet&quot;: &quot;*&quot;,\n\n  &quot;react&quot;: &quot;x&quot;,\n\n  &quot;table&quot;: &quot;~6&quot;,\n\n  &quot;yargs&quot;: &quot;^0&quot;\n\n&#125;\n</code></pre>\n<blockquote>\n<p>前三个容易理解：</p>\n</blockquote>\n<ul>\n<li><code>&quot;signale&quot;: &quot;1.4.0&quot;</code>：固定版本号</li>\n<li><code>&quot;figlet&quot;: &quot;*&quot;</code>：任意版本号（即 <code>&gt;=0.0.0</code>）</li>\n<li><code>&quot;react&quot;: &quot;16.x&quot;</code>：匹配主要版本（<code>&gt;=16.0.0 &lt; 17.0.0</code>）</li>\n<li><code>&quot;react&quot;: &quot;16.3.x&quot;</code>：匹配主要版本和次要版本（<code>&gt;=16.3.0 &lt;16.4.0</code>）</li>\n</ul>\n<blockquote>\n<p>再看看后面两个，版本号包含 <code>~</code> 和 <code>^</code> 符号：</p>\n</blockquote>\n<ul>\n<li><code>~</code>：当安装依赖时获取到有最新版本时，安装到 <code>x.y.z</code> 中 <code>z</code> 的最新版本。即保持主版本号、次版本号不变的情况下，保持修订号的最新版本</li>\n<li><code>^</code>：当安装依赖时获取到由最新版本时，安装到 <code>x.y.z</code> 中 <code>y</code> 和 <code>z</code> 都为最新版本。即保持主版本号不变的情况下，保持次版本号、修订版本号为最新版本。</li>\n</ul>\n<blockquote>\n<p>在 <code>package.json</code> 中最常见应该时 <code>&quot;yargs&quot;: &quot;^14.0.0&quot;</code> 这种格式的依赖，因为我们在使用</p>\n</blockquote>\n<pre><code>npm install &lt;package-name&gt;\n</code></pre>\n<p>安装包时，<code>npm</code> 默认安装当前最新版本，然后在所安装的版本号前加 <code>^</code> 号。</p>\n<blockquote>\n<p>注意，当主版本号为 <code>0</code> 的情况，会被认为是一个不稳定版本，情况与上面不同：</p>\n</blockquote>\n<ul>\n<li>主版本号和次版本号都为 <code>0</code>: <code>^0.0.z</code>、<code>~0.0.z</code> 都被当作固定版本，安装依赖时均不会发生变化。 主版本号为 <code>0</code>: <code>^0.y.z</code> 表现和 <code>~0.y.z</code> 相同，只保持修订号为最新版本。</li>\n</ul>\n<blockquote>\n<blockquote>\n<p><code>1.0.0</code> 的版本号用于界定公共 API。当你的软件发布到了正式环境，或者有稳定的 API 时，就可以发布 1.0.0 版本了。所以，当你决定对外部发布一个正式版本的 npm 包时，把它的版本标为 1.0.0。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>除此以外，还包含以下规则：</p>\n</blockquote>\n<ul>\n<li><code>&gt;</code>：接受高于指定版本的任何版本</li>\n<li><code>&gt;=</code> 接受等于或高于指定版本的任何版本</li>\n<li><code>&lt;=</code>：接受等于或低于指定版本的任何版本</li>\n<li><code>&lt;</code>：接受低于指定版本的任何版本</li>\n<li><code>=</code>：接受确切的版本</li>\n<li><code>-</code>：接受一定范围的版本，例如 <code>2.1.0 - 2.6.2</code></li>\n<li><code>||</code>：组合集合，例如 <code>&lt; 2.1 || &gt; 2.6</code></li>\n</ul>\n<blockquote>\n<p>可以合并其中一些符号，例如</p>\n</blockquote>\n<pre><code>0 || &gt;= 0 &lt; 0\n</code></pre>\n<p>即使用 1.0.0 或从 1.1.0 开始但低于 1.2.0 的版本。</p>\n<h3 id=\"锁定依赖版本\"><a href=\"#锁定依赖版本\" class=\"headerlink\" title=\"锁定依赖版本\"></a>锁定依赖版本</h3><blockquote>\n<p>实际开发中，经常会因为各种依赖不一致而产生奇怪的问题，或者在某些场景下，我们不希望依赖被更新，建议在开发中使用 package-lock.json。</p>\n</blockquote>\n<blockquote>\n<p>锁定依赖版本意味着在我们不手动执行更新的情况下，每次安装依赖都会安装固定版本。保证整个团队使用版本号一致的依赖。</p>\n</blockquote>\n<blockquote>\n<p>每次安装固定版本，无需计算依赖版本范围，大部分场景下能大大加速依赖安装时间。</p>\n</blockquote>\n<blockquote>\n<p>使用 package-lock.json 要确保 npm 的版本在 5.6 以上，因为在 5.0 - 5.6 中间，对 package-lock.json 的处理逻辑进行过几次更新，5.6 版本后处理逻辑逐渐稳定。</p>\n</blockquote>\n<blockquote>\n<p>关于 package-lock.json 详细的结构，我们会在后面的章节进行解析。</p>\n</blockquote>\n<h3 id=\"定期更新依赖\"><a href=\"#定期更新依赖\" class=\"headerlink\" title=\"定期更新依赖\"></a>定期更新依赖</h3><blockquote>\n<p>实际开发场景下，我们虽然不需要每次都去安装新的版本，仍然需要定时去升级依赖版本，来让我们享受依赖包升级带来的问题修复、性能提升、新特性更新。</p>\n</blockquote>\n<blockquote>\n<p>使用 <code>npm outdated</code> 可以帮助我们列出哪些还没有升级到最新版本的依赖：</p>\n</blockquote>\n<ul>\n<li>黄色表示不符合我们指定的语意化版本范围 - 不需要升级</li>\n<li>红色表示符合指定的语意化版本范围 - 需要升级</li>\n</ul>\n<blockquote>\n<p>执行 <code>npm update</code> 会升级所有的红色依赖。</p>\n</blockquote>\n<h3 id=\"依赖版本控制的最佳实践\"><a href=\"#依赖版本控制的最佳实践\" class=\"headerlink\" title=\"依赖版本控制的最佳实践\"></a>依赖版本控制的最佳实践</h3><h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li>语义化版本 2.0.0</li>\n</ul>\n"},{"title":"Npm配置文件","date":"2023-02-08T03:32:46.000Z","_content":"\n## 配置文件\n\n-   .npmrc\n-   .npmignore\n-   .npm\n\n### .npmrc\n\n```\n# 查看 .npmrc 文件在哪里\n\nnpm config ls -l\n```\n\n> npm 的缓存目录在哪里\n\n```\nnpm config get cache\n```\n\n> npm 的全局 node 包在哪里\n\n> 那些通过 `npm install xxx -g` 或者 `cnpm install xxx -g` 或者 `yarn global add xxx` 安装的 `xxx` 文件，到底安装在什么地方？\n\n```\nnpm config get prefix\n```\n\n> 默认情况下：\n\n-   Windows 系统的路径基础部分是： `%APPDATA%/npm/`\n-   MacOS 系统下路径基础部分是 `/usr/local`\n\n> 默认的全局安装包位置：\n\n-   Windows 系统下路径是：\n\n    ```\n    %APPDATA%/npm/node_modules/\n    ```\n\n-   MacOS 系统下路径是：\n\n    ```\n    /usr/local/lib/node_modules/\n    ```\n\n> 当然对于全局包路径的查看，还可以使用下面的命令：`npm root -g`\n\n### .npmignore\n\n### .npm\n","source":"_posts/Npm/Npm配置文件.md","raw":"---\ntitle: Npm配置文件\ndate: 2023-02-08 11:32:46\ntags: Npm\n---\n\n## 配置文件\n\n-   .npmrc\n-   .npmignore\n-   .npm\n\n### .npmrc\n\n```\n# 查看 .npmrc 文件在哪里\n\nnpm config ls -l\n```\n\n> npm 的缓存目录在哪里\n\n```\nnpm config get cache\n```\n\n> npm 的全局 node 包在哪里\n\n> 那些通过 `npm install xxx -g` 或者 `cnpm install xxx -g` 或者 `yarn global add xxx` 安装的 `xxx` 文件，到底安装在什么地方？\n\n```\nnpm config get prefix\n```\n\n> 默认情况下：\n\n-   Windows 系统的路径基础部分是： `%APPDATA%/npm/`\n-   MacOS 系统下路径基础部分是 `/usr/local`\n\n> 默认的全局安装包位置：\n\n-   Windows 系统下路径是：\n\n    ```\n    %APPDATA%/npm/node_modules/\n    ```\n\n-   MacOS 系统下路径是：\n\n    ```\n    /usr/local/lib/node_modules/\n    ```\n\n> 当然对于全局包路径的查看，还可以使用下面的命令：`npm root -g`\n\n### .npmignore\n\n### .npm\n","slug":"Npm/Npm配置文件","published":1,"updated":"2023-02-21T09:35:15.105Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iulw000tbkh07oewff05","content":"<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><ul>\n<li>.npmrc</li>\n<li>.npmignore</li>\n<li>.npm</li>\n</ul>\n<h3 id=\"npmrc\"><a href=\"#npmrc\" class=\"headerlink\" title=\".npmrc\"></a>.npmrc</h3><pre><code># 查看 .npmrc 文件在哪里\n\nnpm config ls -l\n</code></pre>\n<blockquote>\n<p>npm 的缓存目录在哪里</p>\n</blockquote>\n<pre><code>npm config get cache\n</code></pre>\n<blockquote>\n<p>npm 的全局 node 包在哪里</p>\n</blockquote>\n<blockquote>\n<p>那些通过 <code>npm install xxx -g</code> 或者 <code>cnpm install xxx -g</code> 或者 <code>yarn global add xxx</code> 安装的 <code>xxx</code> 文件，到底安装在什么地方？</p>\n</blockquote>\n<pre><code>npm config get prefix\n</code></pre>\n<blockquote>\n<p>默认情况下：</p>\n</blockquote>\n<ul>\n<li>Windows 系统的路径基础部分是： <code>%APPDATA%/npm/</code></li>\n<li>MacOS 系统下路径基础部分是 <code>/usr/local</code></li>\n</ul>\n<blockquote>\n<p>默认的全局安装包位置：</p>\n</blockquote>\n<ul>\n<li><p>Windows 系统下路径是：</p>\n<pre><code>%APPDATA%/npm/node_modules/\n</code></pre>\n</li>\n<li><p>MacOS 系统下路径是：</p>\n<pre><code>/usr/local/lib/node_modules/\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>当然对于全局包路径的查看，还可以使用下面的命令：<code>npm root -g</code></p>\n</blockquote>\n<h3 id=\"npmignore\"><a href=\"#npmignore\" class=\"headerlink\" title=\".npmignore\"></a>.npmignore</h3><h3 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\".npm\"></a>.npm</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><ul>\n<li>.npmrc</li>\n<li>.npmignore</li>\n<li>.npm</li>\n</ul>\n<h3 id=\"npmrc\"><a href=\"#npmrc\" class=\"headerlink\" title=\".npmrc\"></a>.npmrc</h3><pre><code># 查看 .npmrc 文件在哪里\n\nnpm config ls -l\n</code></pre>\n<blockquote>\n<p>npm 的缓存目录在哪里</p>\n</blockquote>\n<pre><code>npm config get cache\n</code></pre>\n<blockquote>\n<p>npm 的全局 node 包在哪里</p>\n</blockquote>\n<blockquote>\n<p>那些通过 <code>npm install xxx -g</code> 或者 <code>cnpm install xxx -g</code> 或者 <code>yarn global add xxx</code> 安装的 <code>xxx</code> 文件，到底安装在什么地方？</p>\n</blockquote>\n<pre><code>npm config get prefix\n</code></pre>\n<blockquote>\n<p>默认情况下：</p>\n</blockquote>\n<ul>\n<li>Windows 系统的路径基础部分是： <code>%APPDATA%/npm/</code></li>\n<li>MacOS 系统下路径基础部分是 <code>/usr/local</code></li>\n</ul>\n<blockquote>\n<p>默认的全局安装包位置：</p>\n</blockquote>\n<ul>\n<li><p>Windows 系统下路径是：</p>\n<pre><code>%APPDATA%/npm/node_modules/\n</code></pre>\n</li>\n<li><p>MacOS 系统下路径是：</p>\n<pre><code>/usr/local/lib/node_modules/\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>当然对于全局包路径的查看，还可以使用下面的命令：<code>npm root -g</code></p>\n</blockquote>\n<h3 id=\"npmignore\"><a href=\"#npmignore\" class=\"headerlink\" title=\".npmignore\"></a>.npmignore</h3><h3 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\".npm\"></a>.npm</h3>"},{"title":"2023个人总结","date":"2023-01-28T01:11:44.000Z","_content":"\n## 技能\n\n- php(version 4.0) 2015 放弃\n- jquery (version 1.64) 2015 放弃\n- angular(version 1.54) 2016 放弃\n- express(v 2.0) 2016 放弃\n- react(v 15.6) 2017 放弃\n- nextjs(v 7.0) 2018 放弃\n- nestjs(v 6.0) 2018 放弃\n- vue(v 2.0) 2018 使用\n- nuxtjs(v 2.0) 2019 使用\n- vue(v 3.0) 2022 使用\n- nuxtjs(v 3.0) 2022 使用\n- python(v 3.8) 2022 学习\n- flask(v 2.1) 2022 学习\n\n### 2023计划\n\n- 英语学习\n- python学习\n- web3学习\n","source":"_posts/Personal/2023个人总结.md","raw":"---\ntitle: 2023个人总结\ndate: 2023-01-28 09:11:44\ntags: 总结\n---\n\n## 技能\n\n- php(version 4.0) 2015 放弃\n- jquery (version 1.64) 2015 放弃\n- angular(version 1.54) 2016 放弃\n- express(v 2.0) 2016 放弃\n- react(v 15.6) 2017 放弃\n- nextjs(v 7.0) 2018 放弃\n- nestjs(v 6.0) 2018 放弃\n- vue(v 2.0) 2018 使用\n- nuxtjs(v 2.0) 2019 使用\n- vue(v 3.0) 2022 使用\n- nuxtjs(v 3.0) 2022 使用\n- python(v 3.8) 2022 学习\n- flask(v 2.1) 2022 学习\n\n### 2023计划\n\n- 英语学习\n- python学习\n- web3学习\n","slug":"Personal/2023个人总结","published":1,"updated":"2023-02-21T09:35:15.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iulx000wbkh0c7epbk4s","content":"<h2 id=\"技能\"><a href=\"#技能\" class=\"headerlink\" title=\"技能\"></a>技能</h2><ul>\n<li>php(version 4.0) 2015 放弃</li>\n<li>jquery (version 1.64) 2015 放弃</li>\n<li>angular(version 1.54) 2016 放弃</li>\n<li>express(v 2.0) 2016 放弃</li>\n<li>react(v 15.6) 2017 放弃</li>\n<li>nextjs(v 7.0) 2018 放弃</li>\n<li>nestjs(v 6.0) 2018 放弃</li>\n<li>vue(v 2.0) 2018 使用</li>\n<li>nuxtjs(v 2.0) 2019 使用</li>\n<li>vue(v 3.0) 2022 使用</li>\n<li>nuxtjs(v 3.0) 2022 使用</li>\n<li>python(v 3.8) 2022 学习</li>\n<li>flask(v 2.1) 2022 学习</li>\n</ul>\n<h3 id=\"2023计划\"><a href=\"#2023计划\" class=\"headerlink\" title=\"2023计划\"></a>2023计划</h3><ul>\n<li>英语学习</li>\n<li>python学习</li>\n<li>web3学习</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"技能\"><a href=\"#技能\" class=\"headerlink\" title=\"技能\"></a>技能</h2><ul>\n<li>php(version 4.0) 2015 放弃</li>\n<li>jquery (version 1.64) 2015 放弃</li>\n<li>angular(version 1.54) 2016 放弃</li>\n<li>express(v 2.0) 2016 放弃</li>\n<li>react(v 15.6) 2017 放弃</li>\n<li>nextjs(v 7.0) 2018 放弃</li>\n<li>nestjs(v 6.0) 2018 放弃</li>\n<li>vue(v 2.0) 2018 使用</li>\n<li>nuxtjs(v 2.0) 2019 使用</li>\n<li>vue(v 3.0) 2022 使用</li>\n<li>nuxtjs(v 3.0) 2022 使用</li>\n<li>python(v 3.8) 2022 学习</li>\n<li>flask(v 2.1) 2022 学习</li>\n</ul>\n<h3 id=\"2023计划\"><a href=\"#2023计划\" class=\"headerlink\" title=\"2023计划\"></a>2023计划</h3><ul>\n<li>英语学习</li>\n<li>python学习</li>\n<li>web3学习</li>\n</ul>\n"},{"title":"Ubuntu18安装nginx","date":"2023-01-11T04:04:03.000Z","_content":"\n### **apt安装**sudo apt update\n\n```jsx\nsudo apt install nginx\n\nnginx -V\n\n默认安装路径 /etc/nginx/nginx.conf\n```\n\n### **nginx安装位置**\n\n```jsx\n**whereis nginx**\n```\n\n### **启动**\n\n```jsx\nservice nginx start\n```\n\n### **检查nginx配置文件**\n\n```jsx\nservice nginx reload\n```\n\n### **重启**\n\n```jsx\nnginx -s reopen\n```\n\n### **停止**\n\n```jsx\nnginx -s stop\n```\n\n### 端口占用\n\n```jsx\n查看端口\nnetstat -lntp\n\nnginx端口\ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      248057/nginx: master\n\n结束端口\nkill 248057\n\n重启nginx\nservice nginx restart\n\n```\n","source":"_posts/Ubuntu/ubuntu18安装nginx.md","raw":"---\ntitle: Ubuntu18安装nginx\ndate: 2023-01-11 12:04:03\ntags: Ubuntu\n---\n\n### **apt安装**sudo apt update\n\n```jsx\nsudo apt install nginx\n\nnginx -V\n\n默认安装路径 /etc/nginx/nginx.conf\n```\n\n### **nginx安装位置**\n\n```jsx\n**whereis nginx**\n```\n\n### **启动**\n\n```jsx\nservice nginx start\n```\n\n### **检查nginx配置文件**\n\n```jsx\nservice nginx reload\n```\n\n### **重启**\n\n```jsx\nnginx -s reopen\n```\n\n### **停止**\n\n```jsx\nnginx -s stop\n```\n\n### 端口占用\n\n```jsx\n查看端口\nnetstat -lntp\n\nnginx端口\ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      248057/nginx: master\n\n结束端口\nkill 248057\n\n重启nginx\nservice nginx restart\n\n```\n","slug":"Ubuntu/ubuntu18安装nginx","published":1,"updated":"2023-02-21T09:35:15.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clee2iulx000ybkh0br42el8z","content":"<h3 id=\"apt安装sudo-apt-update\"><a href=\"#apt安装sudo-apt-update\" class=\"headerlink\" title=\"apt安装sudo apt update\"></a><strong>apt安装</strong>sudo apt update</h3><pre><code class=\"jsx\">sudo apt install nginx\n\nnginx -V\n\n默认安装路径 /etc/nginx/nginx.conf\n</code></pre>\n<h3 id=\"nginx安装位置\"><a href=\"#nginx安装位置\" class=\"headerlink\" title=\"nginx安装位置\"></a><strong>nginx安装位置</strong></h3><pre><code class=\"jsx\">**whereis nginx**\n</code></pre>\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a><strong>启动</strong></h3><pre><code class=\"jsx\">service nginx start\n</code></pre>\n<h3 id=\"检查nginx配置文件\"><a href=\"#检查nginx配置文件\" class=\"headerlink\" title=\"检查nginx配置文件\"></a><strong>检查nginx配置文件</strong></h3><pre><code class=\"jsx\">service nginx reload\n</code></pre>\n<h3 id=\"重启\"><a href=\"#重启\" class=\"headerlink\" title=\"重启\"></a><strong>重启</strong></h3><pre><code class=\"jsx\">nginx -s reopen\n</code></pre>\n<h3 id=\"停止\"><a href=\"#停止\" class=\"headerlink\" title=\"停止\"></a><strong>停止</strong></h3><pre><code class=\"jsx\">nginx -s stop\n</code></pre>\n<h3 id=\"端口占用\"><a href=\"#端口占用\" class=\"headerlink\" title=\"端口占用\"></a>端口占用</h3><pre><code class=\"jsx\">查看端口\nnetstat -lntp\n\nnginx端口\ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      248057/nginx: master\n\n结束端口\nkill 248057\n\n重启nginx\nservice nginx restart\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"apt安装sudo-apt-update\"><a href=\"#apt安装sudo-apt-update\" class=\"headerlink\" title=\"apt安装sudo apt update\"></a><strong>apt安装</strong>sudo apt update</h3><pre><code class=\"jsx\">sudo apt install nginx\n\nnginx -V\n\n默认安装路径 /etc/nginx/nginx.conf\n</code></pre>\n<h3 id=\"nginx安装位置\"><a href=\"#nginx安装位置\" class=\"headerlink\" title=\"nginx安装位置\"></a><strong>nginx安装位置</strong></h3><pre><code class=\"jsx\">**whereis nginx**\n</code></pre>\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a><strong>启动</strong></h3><pre><code class=\"jsx\">service nginx start\n</code></pre>\n<h3 id=\"检查nginx配置文件\"><a href=\"#检查nginx配置文件\" class=\"headerlink\" title=\"检查nginx配置文件\"></a><strong>检查nginx配置文件</strong></h3><pre><code class=\"jsx\">service nginx reload\n</code></pre>\n<h3 id=\"重启\"><a href=\"#重启\" class=\"headerlink\" title=\"重启\"></a><strong>重启</strong></h3><pre><code class=\"jsx\">nginx -s reopen\n</code></pre>\n<h3 id=\"停止\"><a href=\"#停止\" class=\"headerlink\" title=\"停止\"></a><strong>停止</strong></h3><pre><code class=\"jsx\">nginx -s stop\n</code></pre>\n<h3 id=\"端口占用\"><a href=\"#端口占用\" class=\"headerlink\" title=\"端口占用\"></a>端口占用</h3><pre><code class=\"jsx\">查看端口\nnetstat -lntp\n\nnginx端口\ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      248057/nginx: master\n\n结束端口\nkill 248057\n\n重启nginx\nservice nginx restart\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clee2iulk000dbkh0f2c58ka6","category_id":"clee2iuln000hbkh07greea34","_id":"clee2iulv000sbkh043uf54ih"},{"post_id":"clee2iulm000fbkh07j3i55yt","category_id":"clee2iuln000hbkh07greea34","_id":"clee2iulx000xbkh0b1c1fory"}],"PostTag":[{"post_id":"clee2iul80001bkh0cpwn0pp0","tag_id":"clee2iule0004bkh05t8513i4","_id":"clee2iulj000bbkh0fx6wezss"},{"post_id":"clee2iulc0003bkh01zo69fu4","tag_id":"clee2iulj000abkh0evnv1q1j","_id":"clee2iulm000gbkh0du3dgktv"},{"post_id":"clee2iulg0006bkh0der4csj4","tag_id":"clee2iull000ebkh094iefbx7","_id":"clee2iulr000lbkh0cg15enfl"},{"post_id":"clee2iulh0008bkh0b3ur3dmd","tag_id":"clee2iulp000jbkh0f2mo0gur","_id":"clee2iulv000qbkh0c0qwgbof"},{"post_id":"clee2iuli0009bkh0d2obgfzc","tag_id":"clee2iult000obkh00bwn8gyw","_id":"clee2iulw000vbkh09u590yj4"},{"post_id":"clee2iulj000cbkh0d8zmeukp","tag_id":"clee2iulw000ubkh02g1hasmt","_id":"clee2iuly0010bkh0fr0kanxp"},{"post_id":"clee2iulk000dbkh0f2c58ka6","tag_id":"clee2iuly000zbkh01bq7a7pr","_id":"clee2iulz0012bkh0bfukfzo6"},{"post_id":"clee2iulm000fbkh07j3i55yt","tag_id":"clee2iuly000zbkh01bq7a7pr","_id":"clee2ium00015bkh0cejxhbo9"},{"post_id":"clee2iulm000fbkh07j3i55yt","tag_id":"clee2iulz0013bkh03cf81tcz","_id":"clee2ium00016bkh085ijd1ua"},{"post_id":"clee2iuln000ibkh0h76m9crn","tag_id":"clee2iulz0014bkh0gnd58fxn","_id":"clee2ium00018bkh08cg0b6e3"},{"post_id":"clee2iulq000kbkh0fh7d0jkj","tag_id":"clee2ium00017bkh060ow0eiv","_id":"clee2ium1001abkh08sc6gebr"},{"post_id":"clee2iulr000mbkh07df3f5w8","tag_id":"clee2ium00019bkh0bd3bggtk","_id":"clee2ium1001cbkh0clbe0ja1"},{"post_id":"clee2iult000pbkh04v814wsg","tag_id":"clee2ium00019bkh0bd3bggtk","_id":"clee2ium1001ebkh0cjp4gxw8"},{"post_id":"clee2iulv000rbkh0be0o486q","tag_id":"clee2ium00019bkh0bd3bggtk","_id":"clee2ium2001gbkh0elmp5hgu"},{"post_id":"clee2iulw000tbkh07oewff05","tag_id":"clee2ium00019bkh0bd3bggtk","_id":"clee2ium2001ibkh0b8l6bk54"},{"post_id":"clee2iulx000wbkh0c7epbk4s","tag_id":"clee2ium2001hbkh01lyc1wse","_id":"clee2ium3001kbkh0hil44jl5"},{"post_id":"clee2iulx000ybkh0br42el8z","tag_id":"clee2ium2001jbkh0ey713y3c","_id":"clee2ium3001lbkh0dubxfm4d"}],"Tag":[{"name":"工具","_id":"clee2iule0004bkh05t8513i4"},{"name":"SEO","_id":"clee2iulj000abkh0evnv1q1j"},{"name":"Python","_id":"clee2iull000ebkh094iefbx7"},{"name":"React","_id":"clee2iulp000jbkh0f2mo0gur"},{"name":"Git","_id":"clee2iult000obkh00bwn8gyw"},{"name":"Mysql","_id":"clee2iulw000ubkh02g1hasmt"},{"name":"Nginx","_id":"clee2iuly000zbkh01bq7a7pr"},{"name":"Https","_id":"clee2iulz0013bkh03cf81tcz"},{"name":"Node","_id":"clee2iulz0014bkh0gnd58fxn"},{"name":"npm","_id":"clee2ium00017bkh060ow0eiv"},{"name":"Npm","_id":"clee2ium00019bkh0bd3bggtk"},{"name":"总结","_id":"clee2ium2001hbkh01lyc1wse"},{"name":"Ubuntu","_id":"clee2ium2001jbkh0ey713y3c"}]}}